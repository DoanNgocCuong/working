**

# ALL IN ONE - FOLDER STRUCTURES BEST PRACTICES

  

**Author**: Manus AI

**Date**: Dec 19, 2025

  

---

  

## Introduction

  

In the world of software engineering, the way a project's files and directories are organized is more than just a matter of preference; it is a critical component of the project's architecture that has far-reaching implications for maintainability, scalability, and collaboration. A well-designed folder structure serves as a blueprint for the application, making it intuitive for developers to navigate, understand, and extend the codebase. Conversely, a poorly organized project can quickly devolve into a tangled mess of dependencies, making it difficult to debug, test, and scale. This report provides a comprehensive guide to folder structure best practices, drawing on an analysis of real-world projects and extensive research into established architectural patterns. The goal is to synthesize these findings into a unified, "all-in-one" approach that can be adapted to a wide range of software projects.

  

## Analysis of Provided Source Code Examples

  

To ground our discussion in real-world examples, we began by analyzing the folder structures of four distinct software projects. These projects, while varied in their specific implementations, revealed several common architectural patterns and organizational strategies. The following table summarizes the key characteristics of each project's folder structure.

  

| Project Name                  | Primary Architectural Pattern | Key Characteristics                                                                                                                              |

| ----------------------------- | ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |

| `robot-lesson-agent`          | Feature-based & Layered       | Organizes code into feature-specific modules (`agent`, `asr`, `tts`) while also maintaining a separation of concerns with `api`, `common`, and `workers` directories. |

| `robot-context-handling`      | Layered Architecture          | Exhibits a classic layered structure with clear separation between `api`, `services`, `repositories`, and `db` layers. Employs API versioning (`v1`). |

| `robot_fast_response`         | Layered Architecture          | Nearly identical to `robot-context-handling`, demonstrating a consistent application of the layered pattern with a focus on modular services.         |

| `agenda_agent_prompting_UI`   | Simple Frontend Structure     | A basic frontend application with assets grouped by type (`css`, `js`, `image`), typical for simple, static web projects.                        |

  

From this analysis, several common patterns emerged:

  

- **Layered Architecture**: A predominant pattern was the separation of the application into distinct layers, typically `api`, `services` (business logic), `repositories` (data access), and `db` (database). This separation is fundamental to achieving a clean, maintainable codebase.

- **Feature-Based Modules**: The `robot-lesson-agent` project demonstrated a feature-based approach, where code related to a specific feature is grouped together. This is a powerful pattern for managing complexity in larger applications.

- **Centralized Configuration**: All projects utilized a centralized location for configuration, either in a `core` or `common` directory, to manage application-wide settings.

- **API Versioning**: The use of a `v1` subdirectory within the `api` layer indicates a forward-thinking approach to API design, allowing for future changes without breaking existing clients.

- **Separation of Concerns**: Across all the backend projects, there was a clear effort to separate different aspects of the application, such as background jobs (`workers` or `background`), caching (`cache`), and testing (`tests`).

  

These observations from the provided source codes align with established industry best practices and provide a practical foundation for our deeper exploration of folder structure patterns.

  

## Core Principles of Effective Folder Structures

  

Before diving into specific architectural patterns, it is essential to understand the fundamental principles that underpin any effective folder structure. These principles serve as a guide for making sound architectural decisions, regardless of the specific technologies or frameworks being used.

  

> "By ‘structure’ we mean the decisions you make concerning how your project best meets its objective. We need to consider how to best leverage Python’s features to create clean, effective code. In practical terms, ‘structure’ means making clean code whose logic and dependencies are clear as well as how the files and folders are organized in the filesystem." [1]

  

Four core principles are paramount:

  

1.  **Separation of Concerns (SoC)**: This is arguably the most important principle. SoC dictates that an application should be divided into distinct sections, each addressing a separate concern. For example, the user interface, business logic, and data access should all be handled by different parts of the application. This separation makes the codebase easier to understand, maintain, and test.

  

2.  **Scalability**: A well-structured project should be able to grow in complexity without requiring a major overhaul. This means that adding new features or increasing the number of developers working on the project should be a relatively straightforward process. Both feature-based and layered architectures, when implemented correctly, can contribute to a project's scalability.

  

3.  **Testability**: The ability to easily test the different components of an application is crucial for ensuring its quality and reliability. A good folder structure facilitates testing by isolating business logic from the web framework, database, and other external dependencies. This allows for the creation of focused unit tests that can be run quickly and efficiently.

  

4.  **Flexibility**: In the ever-evolving world of software development, the ability to adapt to new technologies and requirements is essential. A flexible architecture allows for parts of the application to be swapped out with minimal impact on the rest of the system. For example, you might want to switch from a monolithic to a microservices architecture, or from a relational to a NoSQL database. A well-designed folder structure can make these transitions significantly smoother.

  

By keeping these principles in mind, we can now explore the specific architectural patterns that help to realize them in practice.

  
  

## Architectural Patterns for Folder Structures

  

Several architectural patterns have emerged as industry standards for organizing software projects. These patterns provide a high-level framework for structuring an application, and the choice of which pattern to use often depends on the project's size, complexity, and team dynamics. The most prominent of these are the Layered Architecture, Clean Architecture, and Feature-Based Architecture.

  

### Layered Architecture

  

The Layered Architecture pattern, as seen in the `robot-context-handling` and `robot_fast_response` projects, is one of the most common and straightforward approaches to structuring an application. It divides the application into horizontal layers, with each layer having a specific responsibility. A typical layered architecture consists of the following four layers:

  

1.  **Presentation Layer**: This is the topmost layer, responsible for handling all user interface and user interaction logic. In a web application, this layer would contain the views, templates, and controllers that render the UI and handle HTTP requests.

2.  **Business Layer (or Service Layer)**: This layer contains the core business logic of the application. It orchestrates the application's workflows and enforces its business rules. This layer is where the main functionality of the application resides.

3.  **Persistence Layer (or Data Access Layer)**: This layer is responsible for all communication with the data store. It abstracts the details of the database implementation from the rest of the application, providing a clean API for data retrieval and storage.

4.  **Database Layer**: This is the actual data storage system, such as a relational database (e.g., PostgreSQL, MySQL) or a NoSQL database (e.g., MongoDB).

  

The key principle of the layered architecture is that dependencies should only flow in one direction: from a higher layer to a lower layer. For example, the Presentation Layer can call the Business Layer, but the Business Layer should not have any knowledge of the Presentation Layer. This unidirectional dependency flow helps to reduce coupling and improve maintainability.

  

### Clean Architecture

  

Clean Architecture, a concept popularized by Robert C. Martin ("Uncle Bob"), takes the principles of the layered architecture a step further. It is a more formal and strict approach to structuring an application, with a strong emphasis on the separation of concerns and the independence of the core business logic from external frameworks and technologies. Clean Architecture is also organized into four layers, but with a different focus:

  

1.  **Domain Layer**: This is the innermost layer and the core of the application. It contains the enterprise-wide business rules and entities. This layer is completely independent of any other layer and should not be affected by changes in frameworks or UI.

2.  **Application Layer**: This layer contains the application-specific business rules. It orchestrates the use cases of the application, using the entities and business rules defined in the Domain Layer.

3.  **Infrastructure Layer**: This layer contains the implementations of the interfaces defined in the layers below it. This includes things like database access, file system access, and network communication. It is where the application interacts with the outside world.

4.  **Presentation Layer**: This is the outermost layer, responsible for presenting data to the user and receiving user input. It is the entry point to the application.

  

The key rule of Clean Architecture is the **Dependency Rule**, which states that source code dependencies can only point inwards. Nothing in an inner circle can know anything at all about something in an outer circle. This rule ensures that the core business logic of the application remains pure and uncontaminated by external concerns.

  

### Feature-Based Architecture

  

In contrast to the horizontal slicing of the layered and clean architectures, the Feature-Based Architecture organizes the codebase into vertical slices, with each slice representing a specific feature of the application. This approach, as seen in the `robot-lesson-agent` project, is particularly well-suited for larger and more complex applications.

  

In a feature-based structure, all the code related to a single feature—including its API endpoints, business logic, data models, and UI components—is grouped together in a single directory. This makes it easy for developers to work on a specific feature without having to navigate through a complex and deeply nested directory structure. It also promotes modularity and reduces the risk of conflicts between different teams working on different features.

  

## The "All-in-One" Recommended Folder Structure

  

Drawing upon the analysis of the provided source codes and the research into established architectural patterns, we can now propose a hybrid, "all-in-one" folder structure that combines the best of these approaches. This structure is designed to be scalable, maintainable, and flexible, making it suitable for a wide range of Python backend projects.

  

```

/your_project

├── app/                      # Main application source code

│   ├── api/                  # API layer (e.g., FastAPI, Flask)

│   │   ├── v1/               # API versioning

│   │   │   ├── endpoints/    # Feature-specific endpoints

│   │   │   │   ├── users.py

│   │   │   │   └── products.py

│   │   │   └── dependencies.py # API dependencies

│   ├── core/                 # App-wide configurations and startup logic

│   │   ├── config.py         # Application configuration

│   │   └── security.py       # Security settings (e.g., JWT, CORS)

│   ├── domain/               # Domain layer (Clean Architecture)

│   │   ├── models/           # ORM models (e.g., SQLAlchemy)

│   │   ├── schemas/          # Pydantic schemas for data validation

│   │   └── repositories.py   # Abstract repository interfaces

│   ├── services/             # Business logic layer (Service Layer)

│   │   ├── user_service.py

│   │   └── product_service.py

│   ├── infrastructure/         # Infrastructure layer (Clean Architecture)

│   │   ├── db/               # Database connection and session management

│   │   ├── cache/            # Caching implementation (e.g., Redis)

│   │   └── background/       # Background job processing (e.g., Celery)

│   ├── utils/                # Reusable utilities

│   └── main.py               # Application entry point

├── tests/                    # Test suite

│   ├── unit/                 # Unit tests

│   └── integration/          # Integration tests

├── migrations/               # Database migrations

├── .env                      # Environment variables

├── requirements.txt          # Project dependencies

├── setup.py                  # Packaging and distribution

├── README.md                 # Project documentation

└── LICENSE                   # Project license

```

  

This structure incorporates the following best practices:

  

- **Layered and Clean Architecture Principles**: The structure is organized into distinct layers (`api`, `core`, `domain`, `services`, `infrastructure`), adhering to the principles of both Layered and Clean Architecture. The `domain` layer is at the core, containing the business models and rules, while the `services` layer orchestrates the business logic. The `infrastructure` layer provides the concrete implementations for external services.

- **Feature-Based Organization within Layers**: Within the `api/endpoints` and `services` directories, the code is organized by feature (e.g., `users`, `products`). This makes it easy to locate and work on the code related to a specific feature.

- **Separation of Models and Schemas**: The `domain` layer contains both the ORM `models` and the Pydantic `schemas`. This separation is crucial for maintaining a stable API contract while allowing the database schema to evolve independently.

- **Clear Separation of Concerns**: Each directory has a clear and well-defined responsibility, from the `api` layer handling HTTP requests to the `infrastructure` layer managing external services.

- **Comprehensive Project Root**: The root of the project contains all the necessary files for managing the project, including `requirements.txt` for dependencies, `setup.py` for packaging, `README.md` for documentation, and `LICENSE` for legal information.

  

## Conclusion

  

A well-designed folder structure is not a luxury; it is a necessity for any serious software project. By embracing the principles of separation of concerns, scalability, testability, and flexibility, and by adopting established architectural patterns such as the Layered, Clean, and Feature-Based architectures, we can create codebases that are not only easy to work with but also resilient to the inevitable changes and challenges that come with software development. The "all-in-one" folder structure proposed in this report provides a practical and effective blueprint for achieving these goals, enabling developers to build robust, maintainable, and scalable applications.

  

---

  

## References

  

[1] The Hitchhiker's Guide to Python. (n.d.). *Structuring Your Project*. Retrieved from https://docs.python-guide.org/writing/structure/

  

[2] Lopez, I. (2024, September 3). *Organizing Project Folder Structure: Function-Based vs Feature-Based*. Medium. Retrieved from https://medium.com/@ikonija.bogojevic/organizing-project-folder-structure-function-based-vs-feature-based-168596b6d169

  

[3] Jovanović, M. (2022, September 24). *How To Approach Clean Architecture Folder Structure*. Retrieved from https://www.milanjovanovic.tech/blog/clean-architecture-folder-structure

  

[4] Cherif, Y. (2024, November 27). *Understanding the Layered Architecture Pattern: A Comprehensive Guide*. DEV Community. Retrieved from https://dev.to/yasmine_ddec94f4d4/understanding-the-layered-architecture-pattern-a-comprehensive-guide-1e2j

  

[5] Pythonworld. (2025, July 22). *The Architecture Blueprint Every Python Backend Project Needs*. Medium. Retrieved from https://medium.com/the-pythonworld/the-architecture-blueprint-every-python-backend-project-needs-207216931123

  
  
  

Dưới đây là bản dịch toàn văn tài liệu sang tiếng Việt, giữ nguyên cấu trúc và nội dung gốc:

# TẤT CẢ TRONG MỘT - CÁC THỰC HÀNH TỐT NHẤT VỀ CẤU TRÚC THƯ MỤC

Tác giả: Manus AI

Ngày: 19 tháng 12 năm 2025

## 

---

Giới thiệu

Trong thế giới kỹ thuật phần mềm, cách tổ chức các tệp và thư mục của dự án không chỉ là vấn đề sở thích cá nhân; đó là một thành phần quan trọng của kiến trúc dự án, có tác động sâu rộng đến khả năng bảo trì, khả năng mở rộng và sự cộng tác. Một cấu trúc thư mục được thiết kế tốt đóng vai trò như một bản thiết kế (blueprint) cho ứng dụng, giúp các lập trình viên dễ dàng điều hướng, hiểu và mở rộng mã nguồn. Ngược lại, một dự án được tổ chức kém có thể nhanh chóng biến thành một mớ hỗn độn các sự phụ thuộc, gây khó khăn cho việc gỡ lỗi, kiểm thử và mở rộng quy mô. Báo cáo này cung cấp một hướng dẫn toàn diện về các thực hành tốt nhất cho cấu trúc thư mục, dựa trên phân tích các dự án thực tế và nghiên cứu sâu rộng về các mẫu kiến trúc đã được thiết lập. Mục tiêu là tổng hợp những phát hiện này thành một cách tiếp cận "tất cả trong một" (all-in-one) thống nhất, có thể thích ứng với nhiều loại dự án phần mềm.

## Phân Tích Các Ví Dụ Mã Nguồn Được Cung Cấp

Để thảo luận dựa trên thực tế, chúng tôi bắt đầu bằng việc phân tích cấu trúc thư mục của bốn dự án phần mềm riêng biệt. Các dự án này, mặc dù khác nhau về cách triển khai cụ thể, nhưng đã tiết lộ một số mẫu kiến trúc và chiến lược tổ chức chung. Bảng sau đây tóm tắt các đặc điểm chính của cấu trúc thư mục từng dự án.

|   |   |   |
|---|---|---|
|Tên Dự Án|Mẫu Kiến Trúc Chính|Các Đặc Điểm Chính|
|robot-lesson-agent|Dựa trên tính năng & Phân lớp|Tổ chức mã thành các mô-đun cụ thể theo tính năng (agent, asr, tts) đồng thời duy trì sự tách biệt các mối quan tâm với các thư mục api, common, và workers.|
|robot-context-handling|Kiến trúc Phân lớp|Thể hiện cấu trúc phân lớp cổ điển với sự tách biệt rõ ràng giữa các lớp api, services (dịch vụ), repositories (kho chứa), và db (cơ sở dữ liệu). Sử dụng phiên bản hóa API (v1).|
|robot_fast_response|Kiến trúc Phân lớp|Gần như giống hệt robot-context-handling, thể hiện sự áp dụng nhất quán của mẫu phân lớp với trọng tâm là các dịch vụ dạng mô-đun.|
|agenda_agent_prompting_UI|Cấu trúc Frontend Đơn giản|Một ứng dụng frontend cơ bản với các tài nguyên được nhóm theo loại (css, js, image), điển hình cho các dự án web tĩnh, đơn giản.|

Từ phân tích này, một số mẫu chung đã nổi lên:

- Kiến trúc Phân lớp (Layered Architecture): Một mẫu chiếm ưu thế là việc tách ứng dụng thành các lớp riêng biệt, điển hình là api, services (logic nghiệp vụ), repositories (truy cập dữ liệu), và db (cơ sở dữ liệu). Sự tách biệt này là nền tảng để đạt được một cơ sở mã sạch và dễ bảo trì.
    
- Mô-đun Dựa trên Tính năng (Feature-Based Modules): Dự án robot-lesson-agent đã thể hiện cách tiếp cận dựa trên tính năng, nơi mã liên quan đến một tính năng cụ thể được nhóm lại với nhau. Đây là một mẫu mạnh mẽ để quản lý sự phức tạp trong các ứng dụng lớn hơn.
    
- Cấu hình Tập trung: Tất cả các dự án đều sử dụng một vị trí tập trung cho cấu hình, hoặc trong thư mục core hoặc common, để quản lý các thiết lập trên toàn ứng dụng.
    
- Phiên bản hóa API: Việc sử dụng thư mục con v1 trong lớp api cho thấy tư duy hướng tới tương lai trong thiết kế API, cho phép thay đổi sau này mà không làm hỏng các client hiện có.
    
- Phân tách các Mối quan tâm (Separation of Concerns): Trên tất cả các dự án backend, có một nỗ lực rõ ràng để tách biệt các khía cạnh khác nhau của ứng dụng, chẳng hạn như các công việc nền (workers hoặc background), bộ nhớ đệm (cache), và kiểm thử (tests).
    

Những quan sát từ mã nguồn được cung cấp này phù hợp với các thực hành tốt nhất đã được thiết lập trong ngành và cung cấp một nền tảng thực tế cho việc khám phá sâu hơn các mẫu cấu trúc thư mục của chúng tôi.

## Các Nguyên Tắc Cốt Lõi của Cấu Trúc Thư Mục Hiệu Quả

Trước khi đi sâu vào các mẫu kiến trúc cụ thể, điều cần thiết là phải hiểu các nguyên tắc cơ bản làm nền tảng cho bất kỳ cấu trúc thư mục hiệu quả nào. Các nguyên tắc này đóng vai trò là kim chỉ nam cho việc đưa ra các quyết định kiến trúc đúng đắn, bất kể công nghệ hoặc framework cụ thể nào đang được sử dụng.

"Bởi 'cấu trúc', chúng tôi muốn nói đến các quyết định bạn đưa ra liên quan đến cách dự án của bạn đáp ứng tốt nhất mục tiêu của nó. Chúng ta cần xem xét cách tận dụng tốt nhất các tính năng của Python để tạo ra mã sạch, hiệu quả. Về mặt thực tế, 'cấu trúc' có nghĩa là tạo ra mã sạch với logic và các phụ thuộc rõ ràng cũng như cách các tệp và thư mục được tổ chức trong hệ thống tệp." [1]

Bốn nguyên tắc cốt lõi là tối quan trọng:

1. Phân Tách Các Mối Quan Tâm (Separation of Concerns - SoC): Đây được cho là nguyên tắc quan trọng nhất. SoC quy định rằng một ứng dụng nên được chia thành các phần riêng biệt, mỗi phần giải quyết một mối quan tâm riêng. Ví dụ: giao diện người dùng, logic nghiệp vụ và truy cập dữ liệu đều nên được xử lý bởi các phần khác nhau của ứng dụng. Sự tách biệt này giúp cơ sở mã dễ hiểu, dễ bảo trì và dễ kiểm thử hơn.
    
2. Khả năng Mở rộng (Scalability): Một dự án có cấu trúc tốt phải có khả năng phát triển về độ phức tạp mà không cần đại tu lớn. Điều này có nghĩa là việc thêm các tính năng mới hoặc tăng số lượng lập trình viên làm việc trong dự án phải là một quy trình tương đối đơn giản. Cả kiến trúc dựa trên tính năng và kiến trúc phân lớp, khi được triển khai chính xác, đều có thể đóng góp vào khả năng mở rộng của dự án.
    
3. Khả năng Kiểm thử (Testability): Khả năng dễ dàng kiểm thử các thành phần khác nhau của một ứng dụng là rất quan trọng để đảm bảo chất lượng và độ tin cậy của nó. Một cấu trúc thư mục tốt tạo điều kiện thuận lợi cho việc kiểm thử bằng cách cô lập logic nghiệp vụ khỏi web framework, cơ sở dữ liệu và các phụ thuộc bên ngoài khác. Điều này cho phép tạo ra các bài kiểm tra đơn vị (unit test) tập trung có thể chạy nhanh chóng và hiệu quả.
    
4. Tính Linh hoạt (Flexibility): Trong thế giới phát triển phần mềm luôn thay đổi, khả năng thích ứng với các công nghệ và yêu cầu mới là rất cần thiết. Một kiến trúc linh hoạt cho phép thay thế các phần của ứng dụng với tác động tối thiểu đến phần còn lại của hệ thống. Ví dụ: bạn có thể muốn chuyển từ kiến trúc nguyên khối (monolithic) sang kiến trúc vi dịch vụ (microservices), hoặc từ cơ sở dữ liệu quan hệ sang NoSQL. Một cấu trúc thư mục được thiết kế tốt có thể làm cho các quá trình chuyển đổi này mượt mà hơn đáng kể.
    

Bằng cách ghi nhớ các nguyên tắc này, bây giờ chúng ta có thể khám phá các mẫu kiến trúc cụ thể giúp hiện thực hóa chúng trong thực tế.

## Các Mẫu Kiến Trúc cho Cấu Trúc Thư Mục

Một số mẫu kiến trúc đã nổi lên như là tiêu chuẩn ngành để tổ chức các dự án phần mềm. Các mẫu này cung cấp một khung cấp cao để cấu trúc ứng dụng, và việc lựa chọn sử dụng mẫu nào thường phụ thuộc vào quy mô, độ phức tạp của dự án và động lực của nhóm. Nổi bật nhất trong số này là Kiến trúc Phân lớp (Layered Architecture), Kiến trúc Sạch (Clean Architecture) và Kiến trúc Dựa trên Tính năng (Feature-Based Architecture).

### Kiến trúc Phân lớp (Layered Architecture)

Mẫu Kiến trúc Phân lớp, như thấy trong các dự án robot-context-handling và robot_fast_response, là một trong những cách tiếp cận phổ biến và đơn giản nhất để cấu trúc một ứng dụng. Nó chia ứng dụng thành các lớp ngang, với mỗi lớp có một trách nhiệm cụ thể. Một kiến trúc phân lớp điển hình bao gồm bốn lớp sau:

1. Lớp Trình Bày (Presentation Layer): Đây là lớp trên cùng, chịu trách nhiệm xử lý tất cả giao diện người dùng và logic tương tác người dùng. Trong một ứng dụng web, lớp này sẽ chứa các view, template và controller để render UI và xử lý các yêu cầu HTTP.
    
2. Lớp Nghiệp Vụ (Business Layer hoặc Service Layer): Lớp này chứa logic nghiệp vụ cốt lõi của ứng dụng. Nó điều phối các quy trình làm việc của ứng dụng và thực thi các quy tắc kinh doanh. Đây là nơi chứa chức năng chính của ứng dụng.
    
3. Lớp Lưu Trữ (Persistence Layer hoặc Data Access Layer): Lớp này chịu trách nhiệm cho tất cả giao tiếp với kho dữ liệu. Nó trừu tượng hóa các chi tiết triển khai cơ sở dữ liệu khỏi phần còn lại của ứng dụng, cung cấp một API sạch để truy xuất và lưu trữ dữ liệu.
    
4. Lớp Cơ Sở Dữ Liệu (Database Layer): Đây là hệ thống lưu trữ dữ liệu thực tế, chẳng hạn như cơ sở dữ liệu quan hệ (ví dụ: PostgreSQL, MySQL) hoặc cơ sở dữ liệu NoSQL (ví dụ: MongoDB).
    

Nguyên tắc chính của kiến trúc phân lớp là các phụ thuộc chỉ nên chảy theo một hướng: từ lớp cao hơn xuống lớp thấp hơn. Ví dụ, Lớp Trình Bày có thể gọi Lớp Nghiệp Vụ, nhưng Lớp Nghiệp Vụ không nên có bất kỳ kiến thức nào về Lớp Trình Bày. Luồng phụ thuộc một chiều này giúp giảm sự kết dính (coupling) và cải thiện khả năng bảo trì.

### Kiến trúc Sạch (Clean Architecture)

Kiến trúc Sạch, một khái niệm được phổ biến bởi Robert C. Martin ("Uncle Bob"), đưa các nguyên tắc của kiến trúc phân lớp tiến thêm một bước. Đây là một cách tiếp cận chính thức và nghiêm ngặt hơn để cấu trúc ứng dụng, với sự nhấn mạnh mạnh mẽ vào việc phân tách các mối quan tâm và sự độc lập của logic nghiệp vụ cốt lõi khỏi các framework và công nghệ bên ngoài. Kiến trúc Sạch cũng được tổ chức thành bốn lớp, nhưng với trọng tâm khác:

1. Lớp Miền (Domain Layer): Đây là lớp trong cùng và là cốt lõi của ứng dụng. Nó chứa các quy tắc kinh doanh và thực thể (entities) trên toàn doanh nghiệp. Lớp này hoàn toàn độc lập với bất kỳ lớp nào khác và không bị ảnh hưởng bởi những thay đổi trong framework hoặc UI.
    
2. Lớp Ứng Dụng (Application Layer): Lớp này chứa các quy tắc kinh doanh cụ thể của ứng dụng. Nó điều phối các trường hợp sử dụng (use cases) của ứng dụng, sử dụng các thực thể và quy tắc kinh doanh được xác định trong Lớp Miền.
    
3. Lớp Cơ Sở Hạ Tầng (Infrastructure Layer): Lớp này chứa các triển khai của các giao diện (interfaces) được xác định trong các lớp bên dưới nó. Điều này bao gồm những thứ như truy cập cơ sở dữ liệu, truy cập hệ thống tệp và giao tiếp mạng. Đây là nơi ứng dụng tương tác với thế giới bên ngoài.
    
4. Lớp Trình Bày (Presentation Layer): Đây là lớp ngoài cùng, chịu trách nhiệm trình bày dữ liệu cho người dùng và nhận đầu vào từ người dùng. Nó là điểm nhập của ứng dụng.
    

Quy tắc chính của Kiến trúc Sạch là Quy Tắc Phụ Thuộc (Dependency Rule), quy định rằng các phụ thuộc mã nguồn chỉ có thể trỏ vào trong. Không có gì trong vòng tròn bên trong có thể biết bất cứ điều gì về một cái gì đó trong vòng tròn bên ngoài. Quy tắc này đảm bảo rằng logic nghiệp vụ cốt lõi của ứng dụng vẫn thuần khiết và không bị nhiễm bẩn bởi các mối quan tâm bên ngoài.

### Kiến trúc Dựa trên Tính năng (Feature-Based Architecture)

Ngược lại với việc cắt lát ngang của kiến trúc phân lớp và kiến trúc sạch, Kiến trúc Dựa trên Tính năng tổ chức cơ sở mã thành các lát cắt dọc, với mỗi lát đại diện cho một tính năng cụ thể của ứng dụng. Cách tiếp cận này, như thấy trong dự án robot-lesson-agent, đặc biệt phù hợp cho các ứng dụng lớn và phức tạp hơn.

Trong cấu trúc dựa trên tính năng, tất cả mã liên quan đến một tính năng đơn lẻ—bao gồm các endpoint API, logic nghiệp vụ, mô hình dữ liệu và các thành phần UI—được nhóm lại với nhau trong một thư mục duy nhất. Điều này giúp các lập trình viên dễ dàng làm việc trên một tính năng cụ thể mà không phải điều hướng qua một cấu trúc thư mục phức tạp và lồng nhau sâu. Nó cũng thúc đẩy tính mô-đun và giảm nguy cơ xung đột giữa các nhóm khác nhau làm việc trên các tính năng khác nhau.

## Cấu Trúc Thư Mục "Tất Cả Trong Một" Được Đề Xuất

Dựa trên phân tích các mã nguồn được cung cấp và nghiên cứu về các mẫu kiến trúc đã được thiết lập, bây giờ chúng tôi có thể đề xuất một cấu trúc thư mục lai, "tất cả trong một", kết hợp những điểm tốt nhất của các cách tiếp cận này. Cấu trúc này được thiết kế để có thể mở rộng, bảo trì và linh hoạt, phù hợp cho nhiều loại dự án backend Python.

  
  
  

/your_project  
├── app/                      # Mã nguồn ứng dụng chính  
│   ├── api/                  # Lớp API (ví dụ: FastAPI, Flask)  
│   │   ├── v1/               # Phiên bản hóa API  
│   │   │   ├── endpoints/    # Các endpoint cụ thể theo tính năng  
│   │   │   │   ├── users.py  
│   │   │   │   └── products.py  
│   │   │   └── dependencies.py # Các phụ thuộc API  
│   ├── core/                 # Cấu hình toàn ứng dụng và logic khởi động  
│   │   ├── config.py         # Cấu hình ứng dụng  
│   │   └── security.py       # Cài đặt bảo mật (ví dụ: JWT, CORS)  
│   ├── domain/               # Lớp miền (Kiến trúc Sạch)  
│   │   ├── models/           # Các mô hình ORM (ví dụ: SQLAlchemy)  
│   │   ├── schemas/          # Các schema Pydantic để xác thực dữ liệu  
│   │   └── repositories.py   # Các giao diện kho chứa trừu tượng  
│   ├── services/             # Lớp logic nghiệp vụ (Lớp Dịch vụ)  
│   │   ├── user_service.py  
│   │   └── product_service.py  
│   ├── infrastructure/       # Lớp cơ sở hạ tầng (Kiến trúc Sạch)  
│   │   ├── db/               # Kết nối cơ sở dữ liệu và quản lý phiên  
│   │   ├── cache/            # Triển khai bộ nhớ đệm (ví dụ: Redis)  
│   │   └── background/       # Xử lý công việc nền (ví dụ: Celery)  
│   ├── utils/                # Các tiện ích có thể tái sử dụng  
│   └── main.py               # Điểm nhập ứng dụng  
├── tests/                    # Bộ kiểm thử (Test suite)  
│   ├── unit/                 # Kiểm thử đơn vị (Unit tests)  
│   └── integration/          # Kiểm thử tích hợp (Integration tests)  
├── migrations/               # Migrations cơ sở dữ liệu  
├── .env                      # Biến môi trường  
├── requirements.txt          # Các phụ thuộc của dự án  
├── setup.py                  # Đóng gói và phân phối  
├── README.md                 # Tài liệu dự án  
└── LICENSE                   # Giấy phép dự án  
  

Cấu trúc này kết hợp các thực hành tốt nhất sau:

- Nguyên tắc Kiến trúc Phân lớp và Kiến trúc Sạch: Cấu trúc được tổ chức thành các lớp riêng biệt (api, core, domain, services, infrastructure), tuân thủ các nguyên tắc của cả Kiến trúc Phân lớp và Kiến trúc Sạch. Lớp domain nằm ở cốt lõi, chứa các mô hình và quy tắc kinh doanh, trong khi lớp services điều phối logic nghiệp vụ. Lớp infrastructure cung cấp các triển khai cụ thể cho các dịch vụ bên ngoài.
    
- Tổ chức Dựa trên Tính năng trong các Lớp: Trong các thư mục api/endpoints và services, mã được tổ chức theo tính năng (ví dụ: users, products). Điều này giúp dễ dàng xác định vị trí và làm việc trên mã liên quan đến một tính năng cụ thể.
    
- Tách biệt giữa Mô hình và Schema: Lớp domain chứa cả models ORM và schemas Pydantic. Sự tách biệt này rất quan trọng để duy trì một hợp đồng API ổn định trong khi cho phép lược đồ cơ sở dữ liệu phát triển độc lập.
    
- Phân Tách Rõ Ràng các Mối Quan Tâm: Mỗi thư mục có một trách nhiệm rõ ràng và được xác định rõ, từ lớp api xử lý các yêu cầu HTTP đến lớp infrastructure quản lý các dịch vụ bên ngoài.
    
- Gốc Dự Án Toàn Diện: Thư mục gốc của dự án chứa tất cả các tệp cần thiết để quản lý dự án, bao gồm requirements.txt cho các phụ thuộc, setup.py để đóng gói, README.md cho tài liệu, và LICENSE cho thông tin pháp lý.
    

## Kết luận

Một cấu trúc thư mục được thiết kế tốt không phải là điều xa xỉ; nó là một sự cần thiết cho bất kỳ dự án phần mềm nghiêm túc nào. Bằng cách nắm lấy các nguyên tắc phân tách các mối quan tâm, khả năng mở rộng, khả năng kiểm thử và tính linh hoạt, và bằng cách áp dụng các mẫu kiến trúc đã được thiết lập như Kiến trúc Phân lớp, Kiến trúc Sạch và Kiến trúc Dựa trên Tính năng, chúng ta có thể tạo ra các cơ sở mã không chỉ dễ làm việc mà còn kiên cường trước những thay đổi và thách thức không thể tránh khỏi đi kèm với việc phát triển phần mềm. Cấu trúc thư mục "tất cả trong một" được đề xuất trong báo cáo này cung cấp một bản thiết kế thực tế và hiệu quả để đạt được các mục tiêu này, cho phép các lập trình viên xây dựng các ứng dụng mạnh mẽ, dễ bảo trì và có thể mở rộng.

## 

---

Tài liệu tham khảo

[1] The Hitchhiker's Guide to Python. (n.d.). Structuring Your Project. Retrieved from [https://docs.python-guide.org/writing/structure/](https://docs.python-guide.org/writing/structure/)

[2] Lopez, I. (2024, September 3). Organizing Project Folder Structure: Function-Based vs Feature-Based. Medium. Retrieved from [https://medium.com/@ikonija.bogojevic/organizing-project-folder-structure-function-based-vs-feature-based-168596b6d169](https://medium.com/@ikonija.bogojevic/organizing-project-folder-structure-function-based-vs-feature-based-168596b6d169)

[3] Jovanović, M. (2022, September 24). How To Approach Clean Architecture Folder Structure. Retrieved from [https://www.milanjovanovic.tech/blog/clean-architecture-folder-structure](https://www.milanjovanovic.tech/blog/clean-architecture-folder-structure)

[4] Cherif, Y. (2024, November 27). Understanding the Layered Architecture Pattern: A Comprehensive Guide. DEV Community. Retrieved from [https://dev.to/yasmine_ddec94f4d4/understanding-the-layered-architecture-pattern-a-comprehensive-guide-1e2j](https://dev.to/yasmine_ddec94f4d4/understanding-the-layered-architecture-pattern-a-comprehensive-guide-1e2j)

[5] Pythonworld. (2025, July 22). The Architecture Blueprint Every Python Backend Project Needs. Medium. Retrieved from [https://medium.com/the-pythonworld/the-architecture-blueprint-every-python-backend-project-needs-207216931123](https://medium.com/the-pythonworld/the-architecture-blueprint-every-python-backend-project-needs-207216931123)

**