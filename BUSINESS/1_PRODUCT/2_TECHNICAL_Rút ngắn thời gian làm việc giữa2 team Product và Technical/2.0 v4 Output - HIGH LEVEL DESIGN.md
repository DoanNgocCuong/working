<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# Kết luận nhanh

Bộ “xương sống” của một High-Level Design** vẫn xoay quanh mấy khối sau:[^1][^2][^3][^4][^5][^6]

1. **System Architecture Overview** (context + các khối chính)
2. **Modules / Components \& Data Flow**
3. **Data \& Database Design (conceptual)**
4. **Interfaces \& Integrations (API, external systems)**
5. **Technology \& Deployment Architecture (tech stack, infra)**
6. **Cross-cutting Concerns quan trọng: Security \& Non‑functional Requirements (performance, scaling, availability)**

Template bạn đang dùng thực ra cũng là 1 phiên bản rất “full option” của bộ này, chỉ là chi tiết và production-oriented hơn thôi.[^7]

Dưới đây là bản “deep research” đã cross-check nhiều nguồn.

***

## 1. System Architecture Overview (kiến trúc tổng quan)

Các nguồn gần như **đều đồng thuận** rằng HLD phải có **một cái nhìn toàn cảnh** về hệ thống:[^2][^3][^4][^5][^1]

- Wikipedia định nghĩa HLD là phần **giải thích kiến trúc dùng để phát triển hệ thống**, với **architecture diagram** mô tả các thành phần chính và interfaces của chúng.[^2]
- GeeksforGeeks mô tả HLD là **mô tả kiến trúc và thiết kế tổng thể của hệ thống**.[^3]
- Các bài HLD best practices yêu cầu **overview of software architecture, physical \& logical**, có diagram minh họa.[^4][^6]

Trong thực tế, cái này thường chính là:

- **C4 Level 1 – System Context**: hệ thống của bạn + users + external systems.[^8][^9][^10]
- Hoặc 1 **system architecture diagram** dạng “Clients ↔ API Gateway ↔ Services ↔ DB/Cache/Queue”.[^11][^12]

→ Đây là **thành phần quan trọng bậc nhất**: nếu thiếu phần này thì tất cả các phần khác sẽ “lơ lửng”, không có frame.

***

## 2. Modules / Components \& Data Flow (các khối chính \& luồng)

Nhiều nguồn nói rõ HLD phải **break down hệ thống thành modules / components**:[^5][^6][^1][^3][^4]

- GeeksforGeeks: key components của HLD gồm **system architecture, modules, data flow diagrams, interface design, technology stack, deployment architecture**.[^1]
- Bài về HLD vs LLD: HLD là “generic system design” bao gồm **system architecture, database design, brief description of systems, services, platforms và relationships among modules**.[^3]
- Các bài tutorial về HLD nhấn mạnh việc **xác định các components chính và cách chúng tương tác**.[^6][^12][^5]

Trong C4 Model, đây là:

- **C4 Level 2 – Container Diagram**: các ứng dụng triển khai được \& data stores (API, microservices, DB, cache, MQ…).[^9][^10][^8]

Thường thể hiện:

- Service / module nào tồn tại?
- Mỗi cái roughly chịu trách nhiệm gì?
- Data / request đi qua các khối đó như thế nào (main happy paths)?

→ Đây là mảnh ghép **“service decomposition + data flow tổng quát”**, rất quan trọng với system design.

***

## 3. Data \& Database Design (ở mức high-level)

Rất nhiều tài liệu HLD liệt kê **Database Design** là một phần chính của HLD:[^4][^2][^3]

- GeeksforGeeks: HLD bao gồm **database design** (ở mức tổng quan) bên cạnh system architecture.[^3]
- Wikipedia: high-level architecture diagram thường bao gồm **database architecture** như một phần của kiến trúc tổng thể.[^2]
- HLD best‑practice guides yêu cầu mô tả **data model ở mức logical/conceptual** và **các data stores chính**.[^4]

Ở mức HLD, ta không cần chi tiết schema đến từng cột, mà thường:

- Liệt kê **các data store chính**: ví dụ User DB (PostgreSQL), Order DB, Analytics DB, Cache Redis, Message Broker, Object Storage,…[^9][^7]
- Mô tả **các domain entity / bảng chính** và quan hệ quan trọng (User, Order, Product, Payment,…).
- Highlight **các trade‑off chính về data**: ACID vs eventual consistency, phân vùng, replication, v.v.[^12]

→ Đây là phần quan trọng vì nó ảnh hưởng trực tiếp tới **consistency model, scaling, và correctness**.

***

## 4. Interfaces \& Integrations (API, external systems, UI)

HLD không chỉ nói “bên trong” mà còn phải mô tả **hệ thống giao tiếp ra/vào với ai và bằng cách nào**:[^5][^1][^2][^3][^4]

- Wikipedia nhắc tới **application flow, security architecture, technology architecture, application architecture (layers)**, bao gồm cả **interfaces**.[^2]
- GeeksforGeeks nói HLD bao gồm **mô tả hardware, software interfaces, user interfaces**.[^3]
- Các bài HLD best practices yêu cầu **integration points giữa các module \& external systems** (payment gateway, analytics, email,…).[^4]

Thực tế, phần này thường gồm:

- **External integrations**: payment, email, KYC, 3rd‑party APIs, internal platform services.
- **Public-facing interfaces**: HTTP/gRPC APIs chính (version, auth, rate limit ở mức khái niệm).
- Với product thiên UI: **application flow / navigation** ở mức high‑level (User từ Login → Dashboard → Checkout,…).[^2][^4]

→ Phần này quan trọng vì nó trả lời câu hỏi: **“Hệ thống này cắm vào môi trường enterprise / internet như thế nào?”**

***

## 5. Technology \& Deployment Architecture

Đa số nguồn hiện đại đều nhấn mạnh **tech stack** và **deployment architecture** là phần bắt buộc của HLD:[^6][^12][^1][^9][^4][^2]

- GeeksforGeeks: liệt kê rõ **technology stack** và **deployment architecture** như thành phần quan trọng của HLD.[^1]
- Wikipedia: HLD thường bao gồm **hardware, database architecture, application architecture, security architecture, technology architecture**.[^2]
- Các bài hướng dẫn HLD/SDD và C4 Model demo container level kèm theo **công nghệ \& môi trường chạy** (React, Go, PostgreSQL, Kubernetes, AWS,…).[^10][^12][^9]

Thông thường phần này bao gồm:

- **Tech stack chính**:
    - Backend: ngôn ngữ, framework (Go, Java, Python/FastAPI, .NET, …)
    - Frontend: React/Next, mobile stack,…
    - Data: RDBMS, NoSQL, cache, search, MQ, object storage,…
- **Deployment view**:
    - On‑prem vs Cloud (AWS/GCP/Azure),
    - Containerization (Docker, K8s),
    - Basic topology: load balancer, API gateway, service mesh (nếu có).[^11][^10][^9]

→ Phần này rất quan trọng cho **DevOps, capacity planning, reliability, cost**.

***

## 6. Cross-cutting Concerns: Security \& NFRs (performance, scaling, availability)

Một số nguồn xếp NFRs \& security vào HLD, số khác chia sang mục riêng, nhưng **ai cũng coi đây là phần cốt lõi ở tầm high-level**:[^13][^14][^12][^3][^4][^2]

- Wikipedia: high-level architecture diagram nên bao gồm **security architecture**.[^2]
- GeeksforGeeks: HLD mô tả **performance specifications \& workflow của user**.[^3]
- HLD/SDD templates theo IEEE 1016 và các guide của HHS/IEEE đều yêu cầu **performance, reliability, constraints, assumptions, interfaces, security…** được capture trong design doc ở mức high-level trước, rồi mới đi sâu.[^14][^15][^13]
- Các bài system design/architecture hiện đại luôn gắn HLD với **scalability, availability, fault tolerance** như những concern cấp kiến trúc.[^16][^12]

Ở mức HLD, phần này thường:

- Ghi rõ **các mục tiêu NFR chính** (latency $p95$, throughput, uptime SLA, dữ liệu phải ACID hay eventual consistency,…).[^16][^12][^3]
- Mô tả high-level các **security mechanisms**:
    - AuthN/AuthZ (OIDC, JWT, RBAC),
    - Network segmentation, encryption in transit/at rest,
    - Compliance constraints (GDPR, PCI‑DSS…).[^13][^2]

→ Dù đôi khi được tách thành chương riêng, thì **về bản chất nó vẫn là phần “High-Level Design for cross-cutting concerns”**.

***

## Đối chiếu với template của bạn

Template “Ultimate SDD” của bạn chia HLD ở **Chapter 5** thành các mục:[^7]

- 5.1 Architecture Pattern (Microservices + Event-driven, DDD, 12-factor, Zero Trust)
- 5.2 C4 System Context \& Container Diagrams (L1, L2)
- 5.3 Technology Stack
- 5.4 Communication Patterns
- 5.5 Architecture Decision Records (ADRs)

Khi so lại với các nguồn bên ngoài:

- **System Architecture Overview** → 5.1 + 5.2
- **Modules/Containers \& Data Flow** → 5.2 (C4), 5.4 (Communication Patterns)
- **Data \& Database Design** → rải ở HLD + Data Design chapter riêng (phù hợp với gợi ý Wikipedia \& GFG).[^1][^3][^2]
- **Interfaces \& Integrations** → nằm trong System Context + Container + API Design chapters.[^7][^4][^2]
- **Technology \& Deployment Architecture** → 5.3 Tech Stack + Deployment/Operations chapters.
- **Security \& NFRs** → tách thành chương Security Design, NFRs, Resilience,… nhưng vẫn ở **tầng high-level** theo kiểu IEEE 1016.[^14][^13][^7]

→ Nghĩa là: **template của bạn không đi ngược lại best practice**, chỉ là nó phân tách chi tiết hơn (vì mục tiêu “production-ready, long‑term”) so với các bài HLD cơ bản.

***

## Nếu cần 1 checklist “universal” cho HLD (bất kể template nào)

Từ tất cả nguồn ngoài + template của bạn, có thể rút ra 1 **checklist trung lập**:

1. **Architecture Overview**
    - Kiểu kiến trúc (monolith, microservices, event-driven, CQRS, …)
    - Context diagram (system, users, external systems).[^8][^9][^1][^2]
2. **Main Components / Containers \& Interactions**
    - Các service/module chính, data stores chính[^10][^8][^1][^3][^2]
    - Luồng chính giữa chúng (data flow ở mức high-level).
3. **Data \& Storage Design (macro)**
    - Loại database, messaging, storage
    - Các entity/domain chính \& consistency model.[^12][^16][^3][^2]
4. **Interfaces \& Integrations**
    - Public APIs, giao tiếp nội bộ (REST/gRPC, events, batch)[^1][^4][^3][^2]
    - External dependencies (payment, email, identity, analytics,…).
5. **Technology \& Deployment**
    - Ngôn ngữ, framework, infra stack (cloud/on‑prem, container, orchestrator)[^9][^12][^4][^1][^2]
    - Sơ đồ deploy ở mức logical (regions, LB, gateway, services).
6. **Cross-cutting Concerns (high-level)**
    - Security architecture (auth, encryption, network boundaries, compliance)[^13][^14][^2]
    - NFRs chính: latency, throughput, availability, durability, scale target.[^16][^12][^3]

Nếu HLD của bạn tick được 6 nhóm này, thì **kể cả template cụ thể có hơi dị một chút, về bản chất vẫn là “đúng chuẩn”** so với tài liệu IEEE + cộng đồng system design hiện tại.
<span style="display:none">[^17][^18][^19][^20][^21]</span>

<div align="center">⁂</div>

[^1]: https://www.geeksforgeeks.org/system-design/what-is-high-level-design-learn-system-design/

[^2]: https://en.wikipedia.org/wiki/High-level_design

[^3]: https://www.geeksforgeeks.org/system-design/difference-between-high-level-design-and-low-level-design/

[^4]: https://netseccloud.com/mastering-high-level-design-documents-examples-and-best-practices

[^5]: https://www.designgurus.io/answers/detail/what-is-high-level-system-design

[^6]: https://dev.to/sajidurshajib/understanding-hld-and-lld-in-system-design-a-developers-guide-22j6

[^7]: paste.txt

[^8]: https://en.wikipedia.org/wiki/C4_model

[^9]: https://www.freecodecamp.org/news/how-to-create-software-architecture-diagrams-using-the-c4-model/

[^10]: https://miro.com/diagramming/c4-model-for-software-architecture/

[^11]: https://vfunction.com/blog/architecture-diagram-guide/

[^12]: https://swimm.io/learn/system-design/system-design-complete-guide-with-patterns-examples-and-techniques

[^13]: https://www.hhs.gov/sites/default/files/ocio/eplc/EPLC Archive Documents/27-Design Document/eplc_design_practices_guide.pdf

[^14]: https://standards.ieee.org/ieee/1016/4502/

[^15]: https://wildart.github.io/MISG5020/standards/SDD_Template.pdf

[^16]: https://snappify.com/blog/system-design-components

[^17]: https://connected-corridors.berkeley.edu/guiding-project-systems-engineering-process/developing-system/icm-system-architecture-and-design

[^18]: https://www.diagrams-ai.com/blog/c4-model-system-context-diagram-example/

[^19]: https://www.linkedin.com/pulse/demystifying-c4-model-context-containers-components-code-nasstrom-owvyf

[^20]: https://www.reddit.com/r/SoftwareEngineering/comments/106jk5k/what_is_the_difference_between_architecture/

[^21]: https://ieeexplore.ieee.org/iel1/2228/6883/00278253.pdf


---
# High-Level Design (HLD) Best Practices – Ultimate Production-Ready Template

## Executive Summary

This document provides a **production‑quality High‑Level Design (HLD)** framework synthesized from **IEEE 1016‑2009**, **Google SRE Design Docs**, **AWS Well‑Architected Framework**, **Netflix/Stripe/Meta production standards**, and the **C4 Model**222333555888101010. The HLD answers the fundamental question: _“How will we build the system at a macro level?”_ and serves as the architectural north star for engineering, DevOps, product, and security teams111.

---

## 1. System Architecture Overview

## 1.1 Architecture Pattern Selection

The architecture pattern must be **explicitly chosen and justified** with trade‑offs. Common patterns include:

- **Microservices with Event‑Driven Architecture**: Independent scalability, fault isolation, technology flexibility, team autonomy. Requires **circuit breakers, idempotency, eventual consistency**111999.
    
- **Modular Monolith**: Simpler for small‑to‑medium teams, lower operational overhead, but harder to scale independently555.
    
- **CQRS + Event Sourcing**: Optimizes read/write separation, auditability, but adds complexity in event replay and projection212121.
    

**Key Principles** (applicable to all patterns):

- **SOLID** for class/module design111
    
- **Domain‑Driven Design (DDD)**: each service maps to a bounded context (e.g., Order Management, User Identity)111
    
- **12‑Factor App**: cloud‑native, CI/CD‑friendly, declarative configs111
    
- **Zero Trust Security**: no internal trust, every call authenticated/authorized111
    

## 1.2 System Context – C4 Level 1

**Purpose**: Show how the system fits into the broader business & technical ecosystem101010161616.

**Components**:

- **Users**: Web/Mobile clients, Admin dashboards, Partners
    
- **External Systems**: Payment Gateway (Stripe), Email Service (SendGrid), Analytics (Google Analytics), Identity Provider (Auth0), LLM APIs (OpenAI)
    
- **Our System**: The bounded box containing all internal services
    

**Interaction Flow**:

text

`Users → HTTPS/GraphQL → Our System → API Calls → External Systems Our System → Event Streams → Analytics`

**Diagram**: System Context (C4 Level 1) – see C4 Model documentation for visualization standards101010191919.

---

## 2. Main Components & Data Flow

## 2.1 Container Diagram – C4 Level 2

**Purpose**: Zoom into the system boundary to show **deployable units (containers) and data stores**101010161616.

**Application Layer**:

- **API Gateway** (Kong/AWS API Gateway): Rate limiting, authentication, routing, load balancing
    
- **Auth Service** (Python/FastAPI): User login, JWT issuance, MFA, session management
    
- **User Service** (Python/FastAPI): Profile management, preferences
    
- **Product Service** (Python/FastAPI): Catalog, inventory, search
    
- **Order Service** (Python/FastAPI): Order lifecycle, payment orchestration
    
- **Background Worker** (Celery): Async jobs (email, reporting, ML inference)
    

**Data Layer**:

- **PostgreSQL** (Primary DB): ACID transactions, JSONB, extensions
    
- **Redis** (Cache & Sessions): Sub‑ms latency, pub/sub
    
- **RabbitMQ/Kafka** (Message Queue): Event-driven communication, durability
    
- **S3** (Object Storage): File uploads, documents
    
- **Elasticsearch** (Search): Full‑text search, analytics
    

**Interaction Flow**:

text

`Client → Load Balancer → API Gateway → Service Layer → Repository Layer → DB/Cache/Queue`

**Diagram**: Container Diagram (C4 Level 2) – each container labeled with technology and responsibility111101010.

## 2.2 Layered Architecture (Per Microservice)

Each microservice follows **Clean Architecture / Hexagonal Pattern**111555:

text

`Controller (HTTP/gRPC handlers) → Service (Business Logic) → Repository (Data Access) → Infrastructure (DB/Cache/Queue)`

**Benefits**: Separation of concerns, testability, technology-agnostic domain logic.

---

## 3. Data & Storage Design (Macro)

## 3.1 Data Store Selection

|Store|Technology|Rationale|Consistency Model|
|---|---|---|---|
|Primary DB|PostgreSQL 15|ACID compliance, JSONB, extensions (PostGIS, TimescaleDB)|Strong (CP)|
|Cache|Redis 7|Sub‑ms latency, pub/sub, sessions|Eventual (AP)|
|Message Queue|RabbitMQ/Kafka|High throughput, durability, ordering guarantees|Eventual (AP)|
|Search|Elasticsearch 8|Full‑text, analytics, near‑real‑time|Eventual (AP)|
|Object Storage|S3|Unlimited scale, cheap, durable|Eventual (AP)|

**Trade‑off**: Transactional data (orders, payments) require **CP** (Consistency + Partition tolerance); read‑heavy data (catalog, analytics) prioritize **AP** (Availability + Partition tolerance)212121.

## 3.2 Logical Data Model (High‑Level Entities)

- **User**: id, email, password_hash, status, created_at
    
- **Product**: id, name, price, inventory_count, category
    
- **Order**: id, user_id, status (PENDING, PAID, SHIPPED), total_amount, created_at
    
- **Payment**: id, order_id, provider, amount, status
    
- **Session**: user_id, jwt_token, expires_at
    

**Relationships**:  
User → Order (1:N)  
Order → Payment (1:1)  
Product → Order (M:N via order_items)

---

## 4. Interfaces & Integrations

## 4.1 Public API Design

- **Protocol**: REST (external) + gRPC (internal)
    
- **Auth**: OAuth 2.0 / JWT (RS256), refresh token rotation
    
- **Rate Limiting**: 1000 req/min per user (API Gateway)
    
- **Idempotency**: Client-generated idempotency keys for POST/PUT
    
- **Versioning**: URL path (/v1/, /v2/)
    
- **Contract**: OpenAPI 3.0 specs, documented via Swagger UI
    

## 4.2 External Integrations

|Service|Protocol|Fallback|Timeout|Retry Policy|
|---|---|---|---|---|
|Stripe|REST API|PayPal|5s|3x exponential backoff (1s, 2s, 4s)|
|SendGrid|REST API|AWS SES|3s|3x exponential backoff|
|OpenAI|REST API|Local LLM|10s|2x with jitter|
|Auth0|OIDC|Self-hosted Keycloak|2s|3x linear backoff|

**Circuit Breaker**: Use `pybreaker` or `resilience4j` to prevent cascading failures111888.

---

## 5. Technology Stack & Deployment Architecture

## 5.1 Technology Stack

|Layer|Technology|Rationale|
|---|---|---|
|Backend|Python 3.11 + FastAPI|Async I/O, high performance, type safety|
|Frontend|React 18 + TypeScript|Ecosystem, component reuse, dev experience|
|Database|PostgreSQL 15|ACID, JSONB, mature extensions|
|Cache|Redis 7|Sub‑ms, pub/sub, session store|
|Message Queue|Kafka 3.x|High throughput, event sourcing|
|Search|Elasticsearch 8|Full‑text, analytics, Kibana|
|Container|Docker|Consistency across envs|
|Orchestration|Kubernetes (EKS/GKE)|Auto‑scaling, self‑healing, service mesh|
|CI/CD|GitHub Actions|Native integration, reusable workflows|
|IaC|Terraform + Helm|Declarative, versioned, reproducible|
|Observability|Prometheus + Grafana + Loki + Tempo/Jaeger|Metrics, logs, traces, alerting|
|Security|Vault (secrets), OPA (policy), WAF (AWS Shield)|Secret mgmt, policy as code, DDoS protection|

## 5.2 Deployment Topology

- **Regions**: Multi‑region (e.g., us‑east‑1, eu‑west‑1) for DR
    
- **AZs**: 3 AZs per region for HA
    
- **Load Balancer**: AWS ALB (L7) → API Gateway → Service Mesh (Istio)
    
- **Service Instances**: Min 3 replicas per service, spread across AZs
    
- **Database**: RDS PostgreSQL (1 Primary + 2 Read Replicas) + ElastiCache Redis (1 Primary + 1 Replica)
    
- **Storage**: S3 cross‑region replication, lifecycle policies (30d → Glacier)
    

---

## 6. Communication Patterns

## 6.1 Synchronous (Request‑Response)

- **Use Case**: User login, product search, order status
    
- **Protocol**: REST (external) / gRPC (internal)
    
- **Pattern**: Circuit Breaker, Timeout (500ms), Retry (exponential backoff)
    
- **Example**: Client → API Gateway → Auth Service → User Service → DB
    

## 6.2 Asynchronous (Event‑Driven)

- **Use Case**: Order created, payment success, inventory update
    
- **Protocol**: AMQP (RabbitMQ) / Kafka
    
- **Pattern**: Event Sourcing, CQRS, Outbox Pattern
    
- **Example**: Order Service → Kafka Topic `order.created` → Payment Service consumes → Publishes `payment.success` → Order Service updates status
    

## 6.3 Real‑Time Streaming

- **Use Case**: Live order tracking, notifications
    
- **Protocol**: WebSocket (or SSE)
    
- **Pattern**: API Gateway manages WS connections, Redis Pub/Sub for fan‑out
    

## 6.4 Batch Jobs

- **Use Case**: Nightly reports, data sync, ML model training
    
- **Protocol**: Kubernetes CronJob / Airflow DAG
    
- **Pattern**: Idempotent, checkpointing, retry on failure
    

---

## 7. Security & Compliance

## 7.1 Authentication & Authorization

- **User Auth**: OIDC + JWT (access token: 15min, refresh token: 7 days)
    
- **Service‑to‑Service**: mTLS (Istio) + short‑lived SPIFFE certificates
    
- **Authorization**: RBAC (roles: user, admin, partner) + ABAC (resource‑level)
    

## 7.2 Data Protection

- **Encryption at Rest**: AES‑256 (RDS, S3, EBS)
    
- **Encryption in Transit**: TLS 1.3 (external), mTLS (internal)
    
- **Secrets Management**: HashiCorp Vault, rotated every 30 days
    
- **PII Handling**: Tokenization/masking in logs, GDPR right‑to‑be‑forgotten
    

## 7.3 Compliance

|Regulation|Requirement|Implementation|
|---|---|---|
|GDPR|Data residency, audit trail|EU‑only region, pgAudit, immutable logs|
|SOC 2|Access controls, monitoring|RBAC, CloudTrail, Prometheus alerts|
|PCI DSS|Card data encryption|Stripe tokenization, no card data stored|

---

## 8. Non‑Functional Requirements (NFRs)

## 8.1 Performance & Scalability

|Metric|Target|Measurement|
|---|---|---|
|p95 Latency|< 200ms|Datadog APM|
|p99 Latency|< 500ms|Datadog APM|
|Throughput|10,000 RPS|Load test (k6)|
|Concurrent Users|100,000|Horizontal scaling (K8s HPA)|
|Database Queries|< 100ms|pg_stat_statements|

**Scaling Strategy**:

- **Horizontal**: K8s HPA based on CPU (60%) + custom metric (queue depth)
    
- **Vertical**: RDS read replicas for read‑heavy workloads
    
- **Cache**: Redis for session & hot data (hit rate > 95%)
    

## 8.2 Reliability & Availability

|Service Level Indicator (SLI)|Service Level Objective (SLO)|Rationale|
|---|---|---|
|API Gateway Success Rate|99.95%|Critical path|
|API Gateway p99 Latency|500ms|User experience|
|Order Service Availability|99.9%|Revenue impact|
|Order Data Integrity|100%|Zero tolerance|
|Background Job Success|99.5%|Retryable|

**Disaster Recovery**:

- **RPO**: < 1 min (Kafka, RDS PITR)
    
- **RTO**: < 30 min (automated failover, runbook tested)
    

**Resilience Patterns**:

- **Circuit Breaker**: Open after 5 failures in 10s, half‑open after 30s
    
- **Bulkhead**: K8s resource quotas per namespace
    
- **Retry**: Exponential backoff + jitter (1s, 2s, 4s)
    
- **Timeout**: API calls (500ms), DB queries (100ms), cache (50ms)
    

## 8.3 Observability

- **Metrics**: Prometheus (node, app, business metrics) → Grafana dashboards
    
- **Logs**: Structured JSON (logfmt), shipped to Loki, retention 30 days
    
- **Traces**: OpenTelemetry (OTLP) → Tempo/Jaeger, sampling 10%
    
- **Alerting**: PagerDuty, severity levels (P0–P3), runbook attached
    
- **SLO Monitoring**: Error budget burn‑rate alerts
    

---

## 9. Architecture Decision Records (ADRs)

## ADR‑001: Message Queue – RabbitMQ vs. Kafka

**Status**: Accepted  
**Context**: Need async communication between microservices for event notification and background jobs.  
**Decision**: RabbitMQ (AMQP) for RPC & complex routing; Kafka for high‑throughput event streaming.  
**Rationale**: RabbitMQ simpler for transactional events; Kafka overkill for current scale but keeps door open for streaming analytics111.

## ADR‑002: Database – PostgreSQL vs. MongoDB

**Status**: Accepted  
**Context**: Primary datastore for transactional data (orders, payments).  
**Decision**: PostgreSQL (ACID, JSONB, mature ecosystem).  
**Rationale**: Strong consistency required for financial data; MongoDB’s eventual consistency unacceptable for order integrity111.

## ADR‑003: API Protocol – REST vs. gRPC

**Status**: Accepted  
**Context**: External clients need simple HTTP; internal services need high performance.  
**Decision**: REST (OpenAPI) for public APIs; gRPC for internal service‑to‑service.  
**Rationale**: gRPC reduces latency 50% vs. REST for inter‑service, but REST is industry standard for external consumers111.

---

## 10. Appendices

## 10.1 Glossary

- **HLD**: High‑Level Design – macro architecture, components, and decisions
    
- **C4 Model**: Context, Container, Component, Code – hierarchical architecture visualization101010
    
- **SLI/SLO**: Service Level Indicator/Objective – quantitative reliability target888
    
- **RPO/RTO**: Recovery Point/Time Objective – DR metrics212121
    
- **ADRs**: Architecture Decision Records – documented trade‑offs111
    

## 10.2 References

- IEEE 1016‑2009 – Software Design Descriptions141414