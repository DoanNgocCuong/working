# Prompt for Production Quality 
```
ÄÃ¢y lÃ  tÃ i liá»‡u cÃ´ Ä‘á»ng vá» viá»‡c production quality cho 1 sáº£n pháº©m AI, 1 sáº£n pháº©m software Tuy nhiÃªn cÃ¡c Ä‘áº§u má»¥c hiá»‡n táº¡i Ä‘ang ráº¥t cÃ´ Ä‘á»ng, chÆ°a chi tiáº¿t, khÃ³ cho ngÆ°á»i má»›i nhÆ° tÃ´i hiá»ƒu. 

TÃ´i cáº§n báº¡n viáº¿t chi tiáº¿t tá»«ng pháº§n láº¥y vÃ­ dá»¥ cá»¥ thá»ƒ Ä‘á»ƒ 1 ngÆ°á»i má»›i level Intern AI Engineer cÃ³ thá»ƒ hiá»ƒu vÃ  dá»±a vÃ o tÃ i liá»‡u cÃ³ thá»ƒ tá»± triá»ƒn khai Ä‘Æ°á»£c toÃ n bá»™ 1 há»‡ thá»‘ng production quality. 
Báº¡n cáº§n hoÃ n thÃ nh checklist sau: 
1. BÃ¡m sÃ¡t tÃ i liá»‡u Ä‘á»c hiá»ƒu chi tiáº¿t tá»«ng pháº§n vÃ  chuáº©n bá»‹ ná»™i dung chi tiáº¿t cho tá»«ng pháº§n 
2. MECE Ä‘á»ƒ xem tÃ i liá»‡u cÃ²n thiáº¿u gÃ¬ khÃ´ng 
3. VIáº¿t chi tiáº¿t Ä‘á»ƒ ra tÃ i liá»‡u final => Output lÃ  1 tÃ i liá»‡u markdown chi tiáº¿t vÃ  siÃªu chi tiáº¿t lÃªn tá»›i 100 trang, Ä‘Æ°á»£c coi lÃ  cuá»‘n ALL IN ONE cho viá»‡c thiáº¿t káº¿ sáº£n pháº©m produciton quality vá» máº·t Engineer.
```


# P2 - TÃ i liá»‡u 100 trang - Production Quality: HÆ°á»›ng Dáº«n ToÃ n Diá»‡n Cho AI Engineer

### Giá»›i Thiá»‡u

TÃ i liá»‡u nÃ y lÃ  má»™t **hÆ°á»›ng dáº«n ALL-IN-ONE** vá» Production Quality dÃ nh cho **Intern AI Engineer** vÃ  cÃ¡c láº­p trÃ¬nh viÃªn muá»‘n xÃ¢y dá»±ng há»‡ thá»‘ng cháº¥t lÆ°á»£ng cao.

#### Má»¥c TiÃªu

Sau khi Ä‘á»c tÃ i liá»‡u nÃ y, báº¡n sáº½:
1. **Hiá»ƒu rÃµ** cÃ¡c nguyÃªn táº¯c cÆ¡ báº£n cá»§a production quality
2. **Biáº¿t cÃ¡ch thiáº¿t káº¿** há»‡ thá»‘ng scalable, reliable, secure
3. **CÃ³ kháº£ nÄƒng triá»ƒn khai** tá»«ng component cá»§a production system
4. **Náº¯m rÃµ** trade-offs vÃ  khi nÃ o dÃ¹ng cÃ¡i gÃ¬
5. **CÃ³ code examples** Ä‘á»ƒ reference khi implement
6. **Biáº¿t cÃ¡ch trÃ¡nh** cÃ¡c common mistakes
7. **CÃ³ checklists** Ä‘á»ƒ Ä‘áº£m báº£o khÃ´ng bá» sÃ³t gÃ¬

#### Pháº¡m Vi

TÃ i liá»‡u bao gá»“m **40 chÆ°Æ¡ng** Ä‘Æ°á»£c chia thÃ nh **15 pháº§n chÃ­nh**:

| Pháº§n                               | ChÆ°Æ¡ng | Trang    |
| ---------------------------------- | ------ | -------- |
| **I. Foundations**                 | 1-4    | 1-50     |
| **II. Architecture & Design**      | 5-8    | 51-120   |
| **III. Reliability & Resilience**  | 9-12   | 121-180  |
| **IV. Observability & Monitoring** | 13-16  | 181-240  |
| **V. Deployment & CI/CD**          | 17-20  | 241-300  |
| **VI. Security**                   | 21-26  | 301-380  |
| **VII. Testing**                   | 27-30  | 381-450  |
| **VIII. Code Quality**             | 31     | 451-480  |
| **IX. Infrastructure**             | 32-33  | 481-520  |
| **X. Database**                    | 34     | 521-550  |
| **XI. API Design**                 | 35     | 551-580  |
| **XII. Configuration**             | 36     | 581-610  |
| **XIII. Documentation**            | 37     | 611-640  |
| **XIV. Production Readiness**      | 38     | 641-680  |
| **XV. MLOps**                      | 39-40  | 681-750+ |

#### CÃ¡ch Sá»­ Dá»¥ng TÃ i Liá»‡u

**Náº¿u báº¡n lÃ  Intern:**
- Äá»c tá»« Ä‘áº§u Ä‘áº¿n cuá»‘i
- LÃ m táº¥t cáº£ cÃ¡c vÃ­ dá»¥ code
- LÃ m cÃ¡c checklist
- Há»i senior engineer náº¿u khÃ´ng hiá»ƒu

**Náº¿u báº¡n lÃ  Mid-level Engineer:**
- Skim qua pháº§n Foundations
- Táº­p trung vÃ o Architecture & Design, Reliability, Security
- LÃ m cÃ¡c vÃ­ dá»¥ advanced
- GiÃºp junior engineers

**Náº¿u báº¡n lÃ  Senior Engineer:**
- DÃ¹ng lÃ m reference
- DÃ¹ng checklist cho code review
- DÃ¹ng cho mentoring
- Adapt cho team cá»§a báº¡n

#### Kiáº¿n Thá»©c Cáº§n CÃ³ TrÆ°á»›c

- Kiáº¿n thá»©c cÆ¡ báº£n vá» láº­p trÃ¬nh (Python, JavaScript, hoáº·c Go)
- Hiá»ƒu cÆ¡ báº£n vá» HTTP, REST APIs
- Hiá»ƒu cÆ¡ báº£n vá» databases
- Sáºµn sÃ ng há»c vÃ  thá»±c hÃ nh

#### TÃ i NguyÃªn Bá»• Sung

Má»—i chÆ°Æ¡ng Ä‘á»u cÃ³:
- **VÃ­ dá»¥ code** (Python, Node.js, Go)
- **Diagrams** minh há»a
- **Checklists** thá»±c thi
- **Tools recommendations**
- **Common mistakes** cáº§n trÃ¡nh
- **Real-world case studies**

---

### TABLE OF CONTENTS

#### PHáº¦N I: FOUNDATIONS (Ná»n Táº£ng)

###### ChÆ°Æ¡ng 1: Giá»›i Thiá»‡u Production Quality
- 1.1 Production Quality LÃ  GÃ¬?
- 1.2 Táº¡i Sao Production Quality Quan Trá»ng?
- 1.3 Production Quality vs Development
- 1.4 CÃ¡c Pillars ChÃ­nh Cá»§a Production Quality

###### ChÆ°Æ¡ng 2: Core Principles
- 2.1 Principle 1: Fail-Safe Design
- 2.2 Principle 2: Defense in Depth
- 2.3 Principle 3: Observability First
- 2.4 Principle 4: Automate Everything
- 2.5 Principle 5: Embrace Failures
- 2.6 Principle 6: Measure What Matters
- 2.7 Principle 7: Continuous Improvement

###### ChÆ°Æ¡ng 3: Architecture Fundamentals
- 3.1 Layered Architecture
- 3.2 Scalability Patterns
- 3.3 Load Balancing Strategies
- 3.4 Microservices Architecture

###### ChÆ°Æ¡ng 4: Trade-offs & Decision Making
- 4.1 Consistency vs Availability
- 4.2 Latency vs Throughput
- 4.3 Cost vs Performance
- 4.4 Complexity vs Maintainability

---

#### PHáº¦N II: ARCHITECTURE & DESIGN (Kiáº¿n TrÃºc & Thiáº¿t Káº¿)

###### ChÆ°Æ¡ng 5: Scalability Patterns (Chi Tiáº¿t)
- 5.1 Horizontal Scaling - Scale Out
- 5.2 Vertical Scaling - Scale Up
- 5.3 Diagonal Scaling - Káº¿t Há»£p Cáº£ Hai

###### ChÆ°Æ¡ng 6: Load Balancing (Chi Tiáº¿t)
- 6.1 Load Balancing Algorithms
- 6.2 Health Checks
- 6.3 Load Balancer High Availability

###### ChÆ°Æ¡ng 7: Microservices Architecture (Chi Tiáº¿t)
- 7.1 Microservices Patterns
- 7.2 API Gateway Pattern
- 7.3 Service Discovery
- 7.4 Circuit Breaker Pattern
- 7.5 Database per Service
- 7.6 Saga Pattern

###### ChÆ°Æ¡ng 8: Data Consistency Patterns
- 8.1 Strong Consistency
- 8.2 Eventual Consistency
- 8.3 Causal Consistency

---

#### PHáº¦N III: RELIABILITY & RESILIENCE (Äá»™ Tin Cáº­y & Kháº£ NÄƒng Phá»¥c Há»“i)

###### ChÆ°Æ¡ng 9: Resilience Patterns (Chi Tiáº¿t)
- 9.1 Retry Pattern
- 9.2 Circuit Breaker Pattern
- 9.3 Timeout Pattern
- 9.4 Bulkhead Pattern
- 9.5 Fallback Pattern

###### ChÆ°Æ¡ng 10: Error Handling (Chi Tiáº¿t)
- 10.1 Error Classification
- 10.2 Structured Error Responses
- 10.3 Error Logging Best Practices
- 10.4 Error Recovery Strategies

###### ChÆ°Æ¡ng 11: Disaster Recovery & Backup
- 11.1 Backup Strategies
- 11.2 Disaster Recovery Strategies
- 11.3 Backup Implementation

###### ChÆ°Æ¡ng 12: Capacity Planning & Forecasting
- 12.1 Capacity Planning Process
- 12.2 Metrics to Track
- 12.3 Forecasting

---

#### PHáº¦N IV: OBSERVABILITY & MONITORING (Quan SÃ¡t & GiÃ¡m SÃ¡t)

###### ChÆ°Æ¡ng 13: Three Pillars of Observability
- 13.1 Metrics (Sá»‘ Liá»‡u)
- 13.2 Logging (Ghi ChÃ©p)
- 13.3 Tracing (Theo DÃµi)

###### ChÆ°Æ¡ng 14: Monitoring Strategy
- 14.1 Metrics to Monitor
- 14.2 Alerting Strategy
- 14.3 Monitoring Dashboard

###### ChÆ°Æ¡ng 15: Alerting & Incident Response
- 15.1 Alert Severity Levels
- 15.2 Incident Response Process
- 15.3 On-Call Management

###### ChÆ°Æ¡ng 16: Cost Optimization for Observability
- 16.1 Metrics Cardinality
- 16.2 Log Sampling
- 16.3 Retention Policies

---

#### PHáº¦N V: DEPLOYMENT & CI/CD (Triá»ƒn Khai & TÃ­ch Há»£p LiÃªn Tá»¥c)

###### ChÆ°Æ¡ng 17: CI/CD Pipeline Best Practices
- 17.1 Pipeline Architecture
- 17.2 CI/CD Tools
- 17.3 Pipeline Configuration Example
- 17.4 Build Optimization

###### ChÆ°Æ¡ng 18: Deployment Strategies
- 18.1 Blue-Green Deployment
- 18.2 Canary Deployment
- 18.3 Rolling Deployment
- 18.4 Deployment Strategy Selection

###### ChÆ°Æ¡ng 19: Environment Management
- 19.1 Environment Types
- 19.2 Configuration Management
- 19.3 Infrastructure as Code (IaC)

###### ChÆ°Æ¡ng 20: Rollback Strategies
- 20.1 Automated Rollback
- 20.2 Manual Rollback

---

#### PHáº¦N VI: SECURITY (Báº£o Máº­t)

###### ChÆ°Æ¡ng 21: Authentication & Authorization
- 21.1 Authentication Methods
- 21.2 Authorization (RBAC)

###### ChÆ°Æ¡ng 22: Data Protection
- 22.1 Encryption at Rest
- 22.2 Encryption in Transit
- 22.3 Input Validation
- 22.4 SQL Injection Prevention

###### ChÆ°Æ¡ng 23: Security Scanning & Compliance
- 23.1 SAST (Static Application Security Testing)
- 23.2 DAST (Dynamic Application Security Testing)
- 23.3 Dependency Scanning (SCA)
- 23.4 Secrets Detection
- 23.5 Compliance Standards

###### ChÆ°Æ¡ng 24: Secrets Management
- 24.1 Secrets Storage
- 24.2 Secrets Rotation
- 24.3 Vault Integration

###### ChÆ°Æ¡ng 25: Network Security
- 25.1 VPC (Virtual Private Cloud)
- 25.2 Security Groups
- 25.3 WAF (Web Application Firewall)

###### ChÆ°Æ¡ng 26: DDoS Protection
- 26.1 DDoS Mitigation
- 26.2 Rate Limiting

---

#### PHáº¦N VII: TESTING (Kiá»ƒm Thá»­)

###### ChÆ°Æ¡ng 27: Testing Pyramid
- 27.1 Testing Levels
- 27.2 Unit Testing
- 27.3 Integration Testing
- 27.4 End-to-End (E2E) Testing

###### ChÆ°Æ¡ng 28: Performance & Security Testing
- 28.1 Load Testing
- 28.2 Stress Testing
- 28.3 Spike Testing
- 28.4 Security Testing

###### ChÆ°Æ¡ng 29: Test Automation & CI/CD Integration
- 29.1 Test Configuration
- 29.2 Test Execution Strategy
- 29.3 CI/CD Integration
- 29.4 Test Coverage

###### ChÆ°Æ¡ng 30: Test Data Management
- 30.1 Test Data Strategies
- 30.2 Factory Pattern
- 30.3 Test Data Cleanup

---

#### PHáº¦N VIII: CODE QUALITY & MAINTAINABILITY (Cháº¥t LÆ°á»£ng Code)

###### ChÆ°Æ¡ng 31: Code Quality Metrics
- 31.1 Key Metrics
- 31.2 Code Quality Tools

---

#### PHáº¦N IX: INFRASTRUCTURE & CONTAINERIZATION (Háº¡ Táº§ng)

###### ChÆ°Æ¡ng 32: Docker Best Practices
- 32.1 Dockerfile Optimization
- 32.2 Docker Security

###### ChÆ°Æ¡ng 33: Kubernetes in Production
- 33.1 Kubernetes Deployment
- 33.2 Service & Ingress

---

#### PHáº¦N X: DATABASE & DATA MANAGEMENT (CÆ¡ Sá»Ÿ Dá»¯ Liá»‡u)

###### ChÆ°Æ¡ng 34: Database Design & Optimization
- 34.1 Database Indexing
- 34.2 Query Optimization
- 34.3 Connection Pooling

---

#### PHáº¦N XI: API DESIGN & INTEGRATION (Thiáº¿t Káº¿ API)

###### ChÆ°Æ¡ng 35: RESTful API Best Practices
- 35.1 API Design
- 35.2 API Versioning
- 35.3 Pagination & Filtering

---

#### PHáº¦N XII: CONFIGURATION & SECRETS (Cáº¥u HÃ¬nh)

###### ChÆ°Æ¡ng 36: Environment Management
- 36.1 Configuration Hierarchy
- 36.2 Configuration Management

---

#### PHáº¦N XIII: DOCUMENTATION (TÃ i Liá»‡u)

###### ChÆ°Æ¡ng 37: Code Documentation
- 37.1 Documentation Types
- 37.2 API Documentation

---

#### PHáº¦N XIV: PRODUCTION READINESS (Sáºµn SÃ ng Sáº£n Xuáº¥t)

###### ChÆ°Æ¡ng 38: Production Readiness Review (PRR)
- 38.1 PRR Checklist
- 38.2 SLO/SLI/SLA

---

#### PHáº¦N XV: MLOPS & AI SYSTEMS IN PRODUCTION (MLOps)

###### ChÆ°Æ¡ng 39: MLOps Fundamentals
- 39.1 ML Pipeline Architecture
- 39.2 Model Serving
- 39.3 Model Monitoring
- 39.4 Model Versioning

###### ChÆ°Æ¡ng 40: Implementation Roadmap
- 40.1 Phase 1: Foundation
- 40.2 Phase 2: Reliability
- 40.3 Phase 3: Security
- 40.4 Phase 4: Optimization
- 40.5 Phase 5: MLOps

---

### Lá»i KhuyÃªn Khi Äá»c

1. **Äá»«ng cá»‘ nhá»› táº¥t cáº£**: TÃ i liá»‡u nÃ y lÃ  reference, khÃ´ng pháº£i Ä‘á»ƒ memorize
2. **Thá»±c hÃ nh**: LÃ m táº¥t cáº£ cÃ¡c vÃ­ dá»¥ code, Ä‘á»«ng chá»‰ Ä‘á»c
3. **Há»i cÃ¢u há»i**: Náº¿u khÃ´ng hiá»ƒu, há»i senior engineers
4. **Adapt**: KhÃ´ng pháº£i táº¥t cáº£ practices phÃ¹ há»£p vá»›i má»i project
5. **Iterate**: Production quality lÃ  continuous process, khÃ´ng pháº£i one-time

---

### LiÃªn Há»‡ & Feedback

Náº¿u báº¡n cÃ³ feedback hoáº·c cÃ¢u há»i:
- Táº¡o issue trÃªn GitHub
- LiÃªn há»‡ vá»›i team lead
- ÄÃ³ng gÃ³p improvements

---

### License

TÃ i liá»‡u nÃ y Ä‘Æ°á»£c cáº¥p phÃ©p dÆ°á»›i Creative Commons Attribution 4.0 International License.

---

**ChÃºc báº¡n há»c táº­p vui váº» vÃ  xÃ¢y dá»±ng há»‡ thá»‘ng production-grade tuyá»‡t vá»i!** ğŸš€

## Production Quality: HÆ°á»›ng Dáº«n ToÃ n Diá»‡n Cho AI Engineer

### PHáº¦N I: FOUNDATIONS (Ná»n Táº£ng)

---

### ChÆ°Æ¡ng 1: Giá»›i Thiá»‡u Production Quality

#### 1.1 Production Quality LÃ  GÃ¬?

**Production quality** khÃ´ng pháº£i chá»‰ lÃ  code "cháº¡y Ä‘Æ°á»£c". ÄÃ³ lÃ  má»™t táº­p há»£p toÃ n diá»‡n cÃ¡c ká»¹ thuáº­t, practices, vÃ  mindset Ä‘á»ƒ Ä‘áº£m báº£o há»‡ thá»‘ng cá»§a báº¡n cÃ³ thá»ƒ:

- **Cháº¡y á»•n Ä‘á»‹nh 24/7** mÃ  khÃ´ng gÃ¢y downtime
- **Xá»­ lÃ½ lá»—i má»™t cÃ¡ch graceful** thay vÃ¬ crash
- **Má»Ÿ rá»™ng Ä‘Æ°á»£c** khi traffic tÄƒng
- **CÃ³ thá»ƒ debug vÃ  fix nhanh** khi cÃ³ váº¥n Ä‘á»
- **Báº£o vá»‡ dá»¯ liá»‡u ngÆ°á»i dÃ¹ng** má»™t cÃ¡ch an toÃ n
- **Cung cáº¥p tráº£i nghiá»‡m tá»‘t** cho end users
- **Dá»… báº£o trÃ¬ vÃ  phÃ¡t triá»ƒn** trong dÃ i háº¡n

KhÃ¡c vá»›i **proof-of-concept** (POC) chá»‰ cáº§n cháº¡y Ä‘Æ°á»£c trÃªn mÃ¡y tÃ­nh cá»§a báº¡n, production quality Ä‘Ã²i há»i xá»­ lÃ½ **toÃ n bá»™ cÃ¡c edge cases**, cÃ³ **kháº£ nÄƒng phá»¥c há»“i tá»« lá»—i**, **monitoring toÃ n diá»‡n**, vÃ  **tá»‘i Æ°u hÃ³a hiá»‡u suáº¥t**.

#### 1.2 Táº¡i Sao Production Quality Quan Trá»ng?

###### Business Impact
- **Tá»•n tháº¥t tÃ i chÃ­nh**: Má»—i giá» downtime cÃ³ thá»ƒ tá»‘n hÃ ng triá»‡u Ä‘Ã´ la (vÃ­ dá»¥: Amazon máº¥t ~$5,600/giÃ¢y khi bá»‹ downtime)
- **Máº¥t lÃ²ng tin khÃ¡ch hÃ ng**: Má»™t láº§n crash cÃ³ thá»ƒ khiáº¿n ngÆ°á»i dÃ¹ng chuyá»ƒn sang competitor
- **Rá»§i ro phÃ¡p lÃ½**: Náº¿u há»‡ thá»‘ng lá»™ dá»¯ liá»‡u, cÃ´ng ty pháº£i chá»‹u pháº¡t (GDPR: lÃªn Ä‘áº¿n 4% doanh thu)

###### Technical Impact
- **Giáº£m chi phÃ­ váº­n hÃ nh**: Há»‡ thá»‘ng á»•n Ä‘á»‹nh = Ã­t incident = Ã­t on-call = team háº¡nh phÃºc
- **TÄƒng tá»‘c Ä‘á»™ phÃ¡t triá»ƒn**: Code quality cao = debug nhanh = feature má»›i ra nhanh
- **Dá»… scale**: Khi thiáº¿t káº¿ tá»‘t tá»« Ä‘áº§u, má»Ÿ rá»™ng sáº½ dá»… dÃ ng hÆ¡n

#### 1.3 Production Quality vs Development

| KhÃ­a Cáº¡nh | Development | Production |
|-----------|-------------|-----------|
| **Má»¥c tiÃªu** | Cháº¡y Ä‘Æ°á»£c, test nhanh | á»”n Ä‘á»‹nh, báº£o máº­t, hiá»‡u suáº¥t |
| **Error handling** | CÃ³ thá»ƒ throw exception | Pháº£i graceful, log, retry |
| **Monitoring** | CÃ³ thá»ƒ debug local | Pháº£i cÃ³ monitoring 24/7 |
| **Scalability** | Cháº¡y trÃªn 1 mÃ¡y Ä‘Æ°á»£c | Pháº£i scale horizontally |
| **Security** | CÃ³ thá»ƒ hardcode secrets | Pháº£i dÃ¹ng secrets manager |
| **Testing** | Unit tests | Unit + Integration + E2E + Performance |
| **Deployment** | Commit â†’ Run | Commit â†’ Build â†’ Test â†’ Deploy â†’ Monitor |

#### 1.4 CÃ¡c Pillars ChÃ­nh Cá»§a Production Quality

Production quality Ä‘Æ°á»£c xÃ¢y dá»±ng trÃªn 7 trá»¥ cá»™t chÃ­nh:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 PRODUCTION QUALITY                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. RELIABILITY    â†’ Há»‡ thá»‘ng cháº¡y á»•n Ä‘á»‹nh              â”‚
â”‚  2. SCALABILITY    â†’ Xá»­ lÃ½ Ä‘Æ°á»£c tÄƒng trÆ°á»Ÿng             â”‚
â”‚  3. PERFORMANCE    â†’ Pháº£n á»©ng nhanh                      â”‚
â”‚  4. SECURITY       â†’ Báº£o vá»‡ dá»¯ liá»‡u                      â”‚
â”‚  5. OBSERVABILITY  â†’ Hiá»ƒu Ä‘Æ°á»£c há»‡ thá»‘ng                 â”‚
â”‚  6. MAINTAINABILITYâ†’ Dá»… phÃ¡t triá»ƒn & fix                â”‚
â”‚  7. COST EFFICIENCYâ†’ Tá»‘i Æ°u chi phÃ­ váº­n hÃ nh            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ChÆ°Æ¡ng 2: Core Principles

#### 2.1 Principle 1: Fail-Safe Design

**NguyÃªn táº¯c**: Há»‡ thá»‘ng pháº£i Ä‘Æ°á»£c thiáº¿t káº¿ Ä‘á»ƒ **fail gracefully**, khÃ´ng pháº£i fail catastrophically.

**Ã nghÄ©a**: Khi cÃ³ lá»—i, há»‡ thá»‘ng nÃªn:
- Tráº£ vá» lá»—i cÃ³ Ã½ nghÄ©a thay vÃ¬ crash
- Giá»¯ Ä‘Æ°á»£c tráº¡ng thÃ¡i nháº¥t quÃ¡n
- Cho phÃ©p ngÆ°á»i dÃ¹ng biáº¿t chuyá»‡n gÃ¬ xáº£y ra
- CÃ³ cÆ¡ há»™i phá»¥c há»“i

**VÃ­ dá»¥**:

```python
## âŒ BAD: Crash khi database khÃ´ng available
def get_user(user_id):
    user = db.query(f"SELECT * FROM users WHERE id = {user_id}")
    return user

## âœ… GOOD: Graceful error handling
def get_user(user_id):
    try:
        user = db.query(f"SELECT * FROM users WHERE id = {user_id}")
        if not user:
            return {"error": "User not found", "status": 404}
        return {"data": user, "status": 200}
    except DatabaseConnectionError as e:
        logger.error(f"Database error: {e}")
        return {"error": "Service temporarily unavailable", "status": 503}
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return {"error": "Internal server error", "status": 500}
```

#### 2.2 Principle 2: Defense in Depth

**NguyÃªn táº¯c**: KhÃ´ng dá»±a vÃ o má»™t lá»›p báº£o vá»‡ duy nháº¥t. Pháº£i cÃ³ nhiá»u lá»›p.

**Ã nghÄ©a**: Náº¿u má»™t lá»›p tháº¥t báº¡i, cÃ¡c lá»›p khÃ¡c váº«n báº£o vá»‡ há»‡ thá»‘ng.

**VÃ­ dá»¥ trong Security**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 1: Network Security (WAF, DDoS)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Layer 2: Authentication (OAuth, JWT)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Layer 3: Authorization (RBAC)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Layer 4: Input Validation               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Layer 5: Encryption (TLS, at-rest)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Layer 6: Audit Logging                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2.3 Principle 3: Observability First

**NguyÃªn táº¯c**: Náº¿u báº¡n khÃ´ng thá»ƒ Ä‘o Ä‘Æ°á»£c, báº¡n khÃ´ng thá»ƒ quáº£n lÃ½ Ä‘Æ°á»£c.

**Ã nghÄ©a**: Há»‡ thá»‘ng pháº£i cung cáº¥p Ä‘á»§ thÃ´ng tin Ä‘á»ƒ hiá»ƒu nÃ³ Ä‘ang lÃ m gÃ¬.

**Ba Pillars cá»§a Observability**:

1. **Metrics**: Sá»‘ liá»‡u Ä‘á»‹nh lÆ°á»£ng (latency, error rate, CPU)
2. **Logs**: Ghi chÃ©p chi tiáº¿t (khi nÃ o, cÃ¡i gÃ¬ xáº£y ra)
3. **Traces**: Theo dÃµi request qua cÃ¡c service

```python
## VÃ­ dá»¥: Instrumentation cÆ¡ báº£n
import logging
import time
from prometheus_client import Counter, Histogram

## Metrics
request_count = Counter('requests_total', 'Total requests')
request_duration = Histogram('request_duration_seconds', 'Request duration')

## Logging
logger = logging.getLogger(__name__)

def process_request(request):
    start_time = time.time()
    request_count.inc()
    
    try:
        logger.info(f"Processing request: {request.id}")
        result = do_work(request)
        logger.info(f"Request {request.id} completed successfully")
        return result
    except Exception as e:
        logger.error(f"Request {request.id} failed: {e}")
        raise
    finally:
        duration = time.time() - start_time
        request_duration.observe(duration)
```

#### 2.4 Principle 4: Automate Everything

**NguyÃªn táº¯c**: Nhá»¯ng gÃ¬ cÃ³ thá»ƒ tá»± Ä‘á»™ng hÃ³a thÃ¬ pháº£i tá»± Ä‘á»™ng hÃ³a.

**Táº¡i sao**: 
- Con ngÆ°á»i dá»… sai láº§m
- Tá»± Ä‘á»™ng hÃ³a nhanh hÆ¡n
- CÃ³ thá»ƒ láº·p láº¡i má»™t cÃ¡ch nháº¥t quÃ¡n

**VÃ­ dá»¥**:
- âœ… CI/CD pipeline tá»± Ä‘á»™ng test & deploy
- âœ… Monitoring tá»± Ä‘á»™ng alert
- âœ… Scaling tá»± Ä‘á»™ng dá»±a trÃªn metrics
- âœ… Backup tá»± Ä‘á»™ng hÃ ng ngÃ y
- âŒ Manual testing trÆ°á»›c má»—i release
- âŒ Manual deployment
- âŒ Manual scaling

#### 2.5 Principle 5: Embrace Failures

**NguyÃªn táº¯c**: Giáº£ Ä‘á»‹nh ráº±ng má»i thá»© sáº½ fail, vÃ  thiáº¿t káº¿ há»‡ thá»‘ng Ä‘á»ƒ xá»­ lÃ½ nÃ³.

**Ã nghÄ©a**:
- Database cÃ³ thá»ƒ down
- Network cÃ³ thá»ƒ bá»‹ timeout
- Third-party API cÃ³ thá»ƒ slow
- Server cÃ³ thá»ƒ crash

**CÃ¡ch xá»­ lÃ½**:
- Retry logic vá»›i exponential backoff
- Circuit breaker Ä‘á»ƒ ngÄƒn cascading failures
- Timeout Ä‘á»ƒ trÃ¡nh indefinite waits
- Fallback strategies

```python
## VÃ­ dá»¥: Resilient API call
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=2, max=10)
)
def call_external_api(endpoint):
    response = requests.get(endpoint, timeout=5)
    response.raise_for_status()
    return response.json()

## Hoáº·c vá»›i circuit breaker
from pybreaker import CircuitBreaker

breaker = CircuitBreaker(fail_max=5, reset_timeout=60)

@breaker
def call_external_api(endpoint):
    response = requests.get(endpoint, timeout=5)
    response.raise_for_status()
    return response.json()
```

#### 2.6 Principle 6: Measure What Matters

**NguyÃªn táº¯c**: KhÃ´ng pháº£i táº¥t cáº£ metrics Ä‘á»u quan trá»ng. Táº­p trung vÃ o nhá»¯ng metrics áº£nh hÆ°á»Ÿng Ä‘áº¿n business.

**VÃ­ dá»¥**:
- âœ… Error rate (áº£nh hÆ°á»Ÿng Ä‘áº¿n user experience)
- âœ… Latency P99 (áº£nh hÆ°á»Ÿng Ä‘áº¿n user satisfaction)
- âœ… Conversion rate (áº£nh hÆ°á»Ÿng Ä‘áº¿n revenue)
- âŒ CPU usage (chá»‰ quan trá»ng náº¿u nÃ³ áº£nh hÆ°á»Ÿng Ä‘áº¿n latency)
- âŒ Memory usage (chá»‰ quan trá»ng náº¿u nÃ³ gÃ¢y OOM)

#### 2.7 Principle 7: Continuous Improvement

**NguyÃªn táº¯c**: Production quality khÃ´ng pháº£i má»™t Ä‘iá»ƒm Ä‘áº¿n, mÃ  lÃ  má»™t hÃ nh trÃ¬nh liÃªn tá»¥c.

**CÃ¡ch thá»±c hiá»‡n**:
- Äá»‹nh ká»³ review metrics
- Há»c tá»« incidents
- Refactor technical debt
- Update dependencies
- Optimize performance

---

### ChÆ°Æ¡ng 3: Architecture Fundamentals

#### 3.1 Layered Architecture

Má»™t há»‡ thá»‘ng production-grade thÆ°á»ng Ä‘Æ°á»£c chia thÃ nh cÃ¡c lá»›p:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Presentation Layer              â”‚ (UI, API Gateway)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Business Logic Layer            â”‚ (Services, Controllers)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Data Access Layer               â”‚ (Repositories, ORM)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Infrastructure Layer            â”‚ (Database, Cache, Queue)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Lá»£i Ã­ch**:
- Separation of concerns
- Dá»… test tá»«ng lá»›p
- Dá»… thay Ä‘á»•i implementation
- Dá»… scale tá»«ng lá»›p Ä‘á»™c láº­p

#### 3.2 Scalability Patterns

###### Horizontal Scaling (Scale Out)
- ThÃªm nhiá»u server vÃ o cluster
- DÃ¹ng load balancer Ä‘á»ƒ phÃ¢n phá»‘i request
- PhÃ¹ há»£p vá»›i stateless services
- VÃ­ dá»¥: ThÃªm 3 servers thay vÃ¬ 1 server máº¡nh hÆ¡n

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Load     â”‚
â”‚ Balancer â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚
  â”Œâ”€â”€â”´â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
  â”‚     â”‚      â”‚      â”‚
â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â” â”Œâ”€â”´â”€â”
â”‚Appâ”‚ â”‚Appâ”‚ â”‚Appâ”‚ â”‚Appâ”‚
â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜
```

###### Vertical Scaling (Scale Up)
- NÃ¢ng cáº¥p tÃ i nguyÃªn cá»§a server hiá»‡n cÃ³
- ThÃªm CPU, RAM, Storage
- CÃ³ giá»›i háº¡n pháº§n cá»©ng
- VÃ­ dá»¥: Tá»« 4GB RAM â†’ 16GB RAM

**Khi nÃ o dÃ¹ng cÃ¡i nÃ o?**

| Scenario | Horizontal | Vertical |
|----------|-----------|----------|
| Traffic tÄƒng tá»« tá»« | âœ… | âœ… |
| Traffic spike Ä‘á»™t ngá»™t | âœ… | âŒ |
| Cáº§n high availability | âœ… | âŒ |
| Cost-sensitive | âœ… | âŒ |
| Stateful service | âŒ | âœ… |
| Legacy monolith | âŒ | âœ… |

#### 3.3 Load Balancing Strategies

**Round Robin**
```
Request 1 â†’ Server 1
Request 2 â†’ Server 2
Request 3 â†’ Server 3
Request 4 â†’ Server 1 (quay láº¡i)
```
- ÄÆ¡n giáº£n nhÆ°ng khÃ´ng xem xÃ©t capacity

**Weighted Round Robin**
```
Server 1 (weight=3) â†’ 60%
Server 2 (weight=2) â†’ 40%
```
- DÃ¹ng khi servers cÃ³ capacity khÃ¡c nhau

**Least Connections**
```
Chá»n server cÃ³ Ã­t connection nháº¥t
```
- Tá»‘t cho long-lived connections

**Resource-Based (Adaptive)**
```
Chá»n dá»±a trÃªn CPU, memory, response time thá»±c táº¿
```
- Tá»‘t nháº¥t nhÆ°ng phá»©c táº¡p hÆ¡n

#### 3.4 Microservices Architecture

**KhÃ¡i niá»‡m**: Chia á»©ng dá»¥ng thÃ nh nhiá»u service nhá», Ä‘á»™c láº­p, cÃ³ thá»ƒ deploy riÃªng.

**Æ¯u Ä‘iá»ƒm**:
- Dá»… scale tá»«ng service
- Dá»… deploy riÃªng láº»
- Dá»… thay Ä‘á»•i technology stack
- Team Ä‘á»™c láº­p cÃ³ thá»ƒ lÃ m viá»‡c trÃªn service khÃ¡c nhau

**NhÆ°á»£c Ä‘iá»ƒm**:
- Phá»©c táº¡p hÆ¡n (distributed systems)
- Network latency
- KhÃ³ debug
- Pháº£i quáº£n lÃ½ nhiá»u databases

**VÃ­ dá»¥ Architecture**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   API Gateway                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚              â”‚              â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚ User    â”‚    â”‚ Product â”‚   â”‚ Order   â”‚
    â”‚ Service â”‚    â”‚ Service â”‚   â”‚ Service â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚              â”‚              â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚ User DB â”‚    â”‚Product  â”‚   â”‚ Order   â”‚
    â”‚         â”‚    â”‚ DB      â”‚   â”‚ DB      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ChÆ°Æ¡ng 4: Trade-offs & Decision Making

#### 4.1 Consistency vs Availability

**CAP Theorem**: Trong distributed systems, báº¡n chá»‰ cÃ³ thá»ƒ chá»n 2 trong 3:
- **Consistency** (C): Táº¥t cáº£ nodes cÃ³ dá»¯ liá»‡u giá»‘ng nhau
- **Availability** (A): Há»‡ thá»‘ng luÃ´n sáºµn sÃ ng
- **Partition Tolerance** (P): Há»‡ thá»‘ng tiáº¿p tá»¥c hoáº¡t Ä‘á»™ng khi network bá»‹ chia cáº¯t

**Trong thá»±c táº¿**: Báº¡n pháº£i chá»n CP hoáº·c AP (P lÃ  báº¯t buá»™c trong distributed systems)

**CP (Consistency + Partition Tolerance)**
```
Æ¯u: Dá»¯ liá»‡u luÃ´n nháº¥t quÃ¡n
NhÆ°á»£c: CÃ³ thá»ƒ khÃ´ng available khi network bá»‹ partition
VÃ­ dá»¥: Database transactions, financial systems
```

**AP (Availability + Partition Tolerance)**
```
Æ¯u: Há»‡ thá»‘ng luÃ´n available
NhÆ°á»£c: Dá»¯ liá»‡u cÃ³ thá»ƒ táº¡m thá»i khÃ´ng nháº¥t quÃ¡n
VÃ­ dá»¥: Social media, NoSQL databases
```

#### 4.2 Latency vs Throughput

**Latency**: Thá»i gian Ä‘á»ƒ xá»­ lÃ½ 1 request
**Throughput**: Sá»‘ request xá»­ lÃ½ Ä‘Æ°á»£c trong 1 giÃ¢y

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Optimize for Latency                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Cache aggressively                â”‚
â”‚ â€¢ Use CDN                           â”‚
â”‚ â€¢ Reduce network hops               â”‚
â”‚ â€¢ Optimize database queries         â”‚
â”‚ VÃ­ dá»¥: Real-time trading systems    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Optimize for Throughput             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Batch processing                  â”‚
â”‚ â€¢ Async processing                  â”‚
â”‚ â€¢ Connection pooling                â”‚
â”‚ â€¢ Parallel processing               â”‚
â”‚ VÃ­ dá»¥: Batch data processing        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 4.3 Cost vs Performance

**High Performance** = **High Cost**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Cost vs Performance Trade-off             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Premium tier: 99.99% uptime, $$$$$     â”‚
â”‚ â€¢ Standard tier: 99.9% uptime, $$$$      â”‚
â”‚ â€¢ Basic tier: 99% uptime, $$$            â”‚
â”‚ â€¢ Budget tier: 95% uptime, $$            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**CÃ¡ch quyáº¿t Ä‘á»‹nh**:
- TÃ­nh toÃ¡n cost cá»§a downtime
- So sÃ¡nh vá»›i cost cá»§a infrastructure
- Chá»n Ä‘iá»ƒm cÃ¢n báº±ng tá»‘i Æ°u

#### 4.4 Complexity vs Maintainability

**ThÃªm features** â†’ **ThÃªm complexity** â†’ **KhÃ³ maintain**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Simplicity First Approach               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Build simple solution                â”‚
â”‚ 2. Measure actual problems              â”‚
â”‚ 3. Add complexity ONLY if needed        â”‚
â”‚ 4. Monitor impact                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**VÃ­ dá»¥**: KhÃ´ng cáº§n microservices tá»« Ä‘áº§u. Báº¯t Ä‘áº§u vá»›i monolith, sau Ä‘Ã³ tÃ¡ch khi cáº§n.

---

### Checklist: Foundations

- [ ] Hiá»ƒu rÃµ 7 pillars cá»§a production quality
- [ ] Ãp dá»¥ng 7 core principles vÃ o design
- [ ] Chá»n architecture phÃ¹ há»£p vá»›i use case
- [ ] Hiá»ƒu trade-offs cá»§a cÃ¡c quyáº¿t Ä‘á»‹nh
- [ ] CÃ³ monitoring tá»« Ä‘áº§u
- [ ] CÃ³ error handling strategy
- [ ] CÃ³ disaster recovery plan
- [ ] Team hiá»ƒu vá» production quality mindset

---

## Production Quality: HÆ°á»›ng Dáº«n ToÃ n Diá»‡n Cho AI Engineer

### PHáº¦N II: ARCHITECTURE & DESIGN

---

### ChÆ°Æ¡ng 5: Scalability Patterns (Chi Tiáº¿t)

#### 5.1 Horizontal Scaling - Scale Out

**Äá»‹nh nghÄ©a**: ThÃªm nhiá»u mÃ¡y chá»§ vÃ o há»‡ thá»‘ng thay vÃ¬ nÃ¢ng cáº¥p mÃ¡y hiá»‡n cÃ³.

###### Kiáº¿n TrÃºc Horizontal Scaling

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Internet / Client                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                         â”‚
    â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
    â”‚ Load       â”‚         â”‚ Load        â”‚
    â”‚ Balancer 1 â”‚         â”‚ Balancer 2  â”‚
    â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
        â”‚                         â”‚
    â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚         â”‚            â”‚
â”Œâ”€â”€â”€â”´â”€â”€â”      â”Œâ”€â”€â”€â”´â”€â”€â”  â”Œâ”€â”€â”´â”€â”€â”€â”€â”    â”Œâ”€â”€â”´â”€â”€â”€â”€â”
â”‚App 1 â”‚      â”‚App 2 â”‚  â”‚App 3  â”‚    â”‚App 4  â”‚
â”‚DB 1  â”‚      â”‚DB 2  â”‚  â”‚DB 3   â”‚    â”‚DB 4   â”‚
â””â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜
```

###### Æ¯u Äiá»ƒm
- **High Availability**: Náº¿u 1 server down, cÃ¡c server khÃ¡c váº«n cháº¡y
- **Dá»… scale**: ThÃªm server má»›i vÃ o cluster
- **Cost-effective**: DÃ¹ng commodity hardware
- **Fault tolerance**: CÃ³ redundancy

###### NhÆ°á»£c Äiá»ƒm
- **Phá»©c táº¡p hÆ¡n**: Cáº§n load balancer, session management
- **Network overhead**: Pháº£i communicate qua network
- **Data consistency**: KhÃ³ Ä‘áº£m báº£o consistency khi cÃ³ nhiá»u instances
- **Operational complexity**: Pháº£i quáº£n lÃ½ nhiá»u servers

###### Khi NÃ o DÃ¹ng
- âœ… Stateless services (API servers, web servers)
- âœ… High traffic applications
- âœ… Cáº§n high availability
- âœ… Cloud-native applications

###### Implementation Example

```python
## VÃ­ dá»¥: Stateless API server
from flask import Flask, request
import logging

app = Flask(__name__)
logger = logging.getLogger(__name__)

@app.route('/api/users/<user_id>', methods=['GET'])
def get_user(user_id):
    """
    Stateless endpoint - cÃ³ thá»ƒ cháº¡y trÃªn báº¥t ká»³ server nÃ o
    """
    logger.info(f"Getting user {user_id} on server {request.host}")
    
    ## Fetch tá»« shared database
    user = db.get_user(user_id)
    
    if not user:
        return {"error": "Not found"}, 404
    
    return {"data": user}, 200

## Load balancer sáº½ route requests Ä‘áº¿n:
## Server 1: 10.0.0.1:5000
## Server 2: 10.0.0.2:5000
## Server 3: 10.0.0.3:5000
```

###### Session Management trong Horizontal Scaling

**Problem**: Náº¿u user login vÃ o Server 1, rá»“i request tiáº¿p theo route Ä‘áº¿n Server 2, Server 2 khÃ´ng biáº¿t user Ä‘Ã£ login.

**Solutions**:

**1. Sticky Sessions (Session Affinity)**
```
Load Balancer â†’ LuÃ´n route user Ä‘áº¿n cÃ¹ng 1 server
Æ¯u: ÄÆ¡n giáº£n
NhÆ°á»£c: Náº¿u server down, user máº¥t session
```

**2. Shared Session Store (Redis)**
```
Server 1 â”€â”
Server 2 â”€â”¼â”€â†’ Redis (shared session store)
Server 3 â”€â”˜
```

```python
from flask_session import Session
from redis import Redis

app.config['SESSION_TYPE'] = 'redis'
app.config['SESSION_REDIS'] = Redis(host='redis-server', port=6379)
Session(app)

@app.route('/login', methods=['POST'])
def login():
    session['user_id'] = request.json['user_id']
    return {"status": "logged in"}

@app.route('/profile')
def profile():
    ## Láº¥y tá»« Redis, khÃ´ng quan trá»ng server nÃ o xá»­ lÃ½
    user_id = session.get('user_id')
    return {"user_id": user_id}
```

**3. JWT Tokens (Stateless)**
```
Client lÆ°u token, gá»­i láº¡i má»—i request
Server verify token mÃ  khÃ´ng cáº§n store session
```

```python
from flask_jwt_extended import JWTManager, create_access_token, jwt_required

jwt = JWTManager(app)

@app.route('/login', methods=['POST'])
def login():
    user_id = request.json['user_id']
    token = create_access_token(identity=user_id)
    return {"access_token": token}

@app.route('/profile')
@jwt_required()
def profile():
    from flask_jwt_extended import get_jwt_identity
    user_id = get_jwt_identity()
    return {"user_id": user_id}
```

#### 5.2 Vertical Scaling - Scale Up

**Äá»‹nh nghÄ©a**: NÃ¢ng cáº¥p tÃ i nguyÃªn cá»§a server hiá»‡n cÃ³ (CPU, RAM, Storage).

###### Æ¯u Äiá»ƒm
- **ÄÆ¡n giáº£n**: KhÃ´ng cáº§n thay Ä‘á»•i architecture
- **KhÃ´ng cÃ³ network overhead**: Má»i thá»© trÃªn 1 mÃ¡y
- **Dá»… quáº£n lÃ½**: Chá»‰ 1 server
- **Tá»‘t cho stateful services**: Database, cache

###### NhÆ°á»£c Äiá»ƒm
- **CÃ³ giá»›i háº¡n**: KhÃ´ng thá»ƒ nÃ¢ng cáº¥p vÃ´ háº¡n
- **Downtime**: Pháº£i restart server khi nÃ¢ng cáº¥p
- **Single point of failure**: Náº¿u server down, toÃ n bá»™ há»‡ thá»‘ng down
- **Äáº¯t**: Server máº¡nh hÆ¡n thÆ°á»ng Ä‘áº¯t hÆ¡n

###### Khi NÃ o DÃ¹ng
- âœ… Stateful services (Database, Cache)
- âœ… Legacy monolith
- âœ… Workload cÃ³ thá»ƒ dá»± Ä‘oÃ¡n
- âœ… Cáº§n low latency

#### 5.3 Diagonal Scaling - Káº¿t Há»£p Cáº£ Hai

**Ã tÆ°á»Ÿng**: DÃ¹ng vertical scaling cho critical services, horizontal scaling cho stateless services.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ API Servers (Horizontal)                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚ â”‚Server 1 â”‚ â”‚Server 2 â”‚ â”‚Server 3 â”‚    â”‚
â”‚ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚            â”‚            â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                    â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
    â”‚ Database    â”‚   â”‚ Cache       â”‚
    â”‚ (Vertical)  â”‚   â”‚ (Vertical)  â”‚
    â”‚ 64GB RAM    â”‚   â”‚ 32GB RAM    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Æ¯u Ä‘iá»ƒm**:
- Tá»‘i Æ°u hÃ³a cáº£ performance láº«n availability
- Stateless services scale horizontally
- Stateful services scale vertically
- Cost-effective

---

### ChÆ°Æ¡ng 6: Load Balancing (Chi Tiáº¿t)

#### 6.1 Load Balancing Algorithms

###### 1. Round Robin
```
Requests: 1, 2, 3, 4, 5, 6
Servers:  A, B, C, A, B, C
```

**Æ¯u**: ÄÆ¡n giáº£n, cÃ´ng báº±ng
**NhÆ°á»£c**: KhÃ´ng xem xÃ©t server capacity, khÃ´ng phÃ¹ há»£p vá»›i long-lived connections

```nginx
## Nginx configuration
upstream backend {
    server backend1.example.com;
    server backend2.example.com;
    server backend3.example.com;
}

server {
    listen 80;
    location / {
        proxy_pass http://backend;
    }
}
```

###### 2. Weighted Round Robin
```
Server A (weight=3): 60%
Server B (weight=2): 40%
```

**DÃ¹ng khi**: Servers cÃ³ capacity khÃ¡c nhau

```nginx
upstream backend {
    server backend1.example.com weight=3;
    server backend2.example.com weight=2;
}
```

###### 3. Least Connections
```
Chá»n server cÃ³ Ã­t active connections nháº¥t
```

**Æ¯u**: Tá»‘t cho long-lived connections
**NhÆ°á»£c**: KhÃ´ng xem xÃ©t server capacity

```nginx
upstream backend {
    least_conn;
    server backend1.example.com;
    server backend2.example.com;
}
```

###### 4. IP Hash
```
Hash(client_ip) % num_servers = server_index
```

**Æ¯u**: Sticky sessions (cÃ¹ng client luÃ´n Ä‘áº¿n cÃ¹ng server)
**NhÆ°á»£c**: Náº¿u thÃªm/xÃ³a server, hash bá»‹ thay Ä‘á»•i

```nginx
upstream backend {
    ip_hash;
    server backend1.example.com;
    server backend2.example.com;
}
```

###### 5. Resource-Based (Adaptive)
```
Chá»n server dá»±a trÃªn CPU, memory, response time thá»±c táº¿
```

**Æ¯u**: Tá»‘i Æ°u nháº¥t
**NhÆ°á»£c**: Phá»©c táº¡p, cáº§n monitoring

```python
## VÃ­ dá»¥: Custom load balancer
import requests
from statistics import mean

class AdaptiveLoadBalancer:
    def __init__(self, servers):
        self.servers = servers
        self.metrics = {s: {"cpu": 0, "memory": 0} for s in servers}
    
    def get_server_metrics(self, server):
        """Láº¥y metrics tá»« server"""
        try:
            response = requests.get(f"http://{server}/metrics", timeout=1)
            return response.json()
        except:
            return {"cpu": 100, "memory": 100}  ## Assume down
    
    def select_server(self):
        """Chá»n server cÃ³ resource Ã­t nháº¥t"""
        ## Update metrics
        for server in self.servers:
            metrics = self.get_server_metrics(server)
            self.metrics[server] = metrics
        
        ## Chá»n server vá»›i score tháº¥p nháº¥t
        scores = {
            server: (self.metrics[server]["cpu"] + self.metrics[server]["memory"]) / 2
            for server in self.servers
        }
        
        return min(scores, key=scores.get)
```

#### 6.2 Health Checks

**Táº¡i sao cáº§n**: Load balancer pháº£i biáº¿t server nÃ o healthy, server nÃ o down.

```python
## VÃ­ dá»¥: Health check endpoint
from flask import Flask

app = Flask(__name__)

@app.route('/health', methods=['GET'])
def health_check():
    """
    Health check endpoint
    Load balancer sáº½ gá»i Ä‘á»‹nh ká»³
    """
    try:
        ## Check database connection
        db.ping()
        
        ## Check cache connection
        cache.ping()
        
        return {
            "status": "healthy",
            "timestamp": datetime.now().isoformat()
        }, 200
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        return {
            "status": "unhealthy",
            "error": str(e)
        }, 503
```

**Nginx health check configuration**:
```nginx
upstream backend {
    server backend1.example.com;
    server backend2.example.com;
    
    ## Health check
    check interval=3000 rise=2 fall=5 timeout=1000 type=http;
    check_http_send "GET /health HTTP/1.0\r\n\r\n";
    check_http_expect_alive http_2xx;
}
```

#### 6.3 Load Balancer High Availability

**Problem**: Náº¿u load balancer down, toÃ n bá»™ há»‡ thá»‘ng down.

**Solution**: CÃ³ 2+ load balancers trong active-passive hoáº·c active-active mode.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Virtual IP (VIP)                   â”‚
â”‚ 10.0.0.100                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚               â”‚
  â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”
  â”‚ LB 1   â”‚      â”‚ LB 2   â”‚
  â”‚ Active â”‚      â”‚ Passiveâ”‚
  â”‚ 10.0.0.1      â”‚ 10.0.0.2
  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â””â”€â†’ Health check: LB 2 monitors LB 1
      â””â”€â†’ If LB 1 down, VIP moves to LB 2
```

**Tools**: HAProxy, Nginx, AWS ELB, Google Cloud Load Balancer

---

### ChÆ°Æ¡ng 7: Microservices Architecture (Chi Tiáº¿t)

#### 7.1 Microservices Patterns

###### Pattern 1: API Gateway

**Ã tÆ°á»Ÿng**: CÃ³ 1 entry point duy nháº¥t cho táº¥t cáº£ clients.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  API Gateway   â”‚
         â”‚ (Authenticationâ”‚
         â”‚  Rate Limiting â”‚
         â”‚  Routing)      â”‚
         â””â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”˜
             â”‚    â”‚    â”‚
        â”Œâ”€â”€â”€â”€â”˜    â”‚    â””â”€â”€â”€â”€â”
        â”‚         â”‚         â”‚
    â”Œâ”€â”€â”€â”´â”€â”€â”  â”Œâ”€â”€â”€â”´â”€â”€â”  â”Œâ”€â”€â”€â”´â”€â”€â”
    â”‚User  â”‚  â”‚Product  â”‚Order  â”‚
    â”‚Service   â”‚Service  â”‚Serviceâ”‚
    â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜
```

**Æ¯u Ä‘iá»ƒm**:
- Centralized authentication & authorization
- Rate limiting
- Request routing
- API versioning
- Monitoring

**Implementation**:
```python
## VÃ­ dá»¥: API Gateway vá»›i Flask
from flask import Flask, request, jsonify
import requests
from functools import wraps

app = Flask(__name__)

## Service registry
SERVICES = {
    'users': 'http://user-service:5001',
    'products': 'http://product-service:5002',
    'orders': 'http://order-service:5003'
}

def authenticate(f):
    """Authentication middleware"""
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            return {"error": "Missing token"}, 401
        
        ## Verify token
        if not verify_token(token):
            return {"error": "Invalid token"}, 401
        
        return f(*args, **kwargs)
    return decorated

@app.route('/api/<service>/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE'])
@authenticate
def gateway(service, path):
    """Route requests to appropriate service"""
    if service not in SERVICES:
        return {"error": "Service not found"}, 404
    
    service_url = f"{SERVICES[service]}/{path}"
    
    try:
        response = requests.request(
            method=request.method,
            url=service_url,
            headers=request.headers,
            json=request.json,
            timeout=5
        )
        return response.json(), response.status_code
    except requests.Timeout:
        return {"error": "Service timeout"}, 504
    except Exception as e:
        return {"error": str(e)}, 500
```

###### Pattern 2: Service Discovery

**Problem**: Khi cÃ³ nhiá»u service instances, lÃ m sao biáº¿t Ä‘á»‹a chá»‰ cá»§a chÃºng?

**Solution**: Service registry + discovery mechanism

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service Registry (Consul/Eureka)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ user-service: 10.0.0.1:5001         â”‚
â”‚ user-service: 10.0.0.2:5001         â”‚
â”‚ product-service: 10.0.0.3:5002      â”‚
â”‚ order-service: 10.0.0.4:5003        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation vá»›i Consul**:
```python
import consul

## Register service
c = consul.Consul(host='consul-server', port=8500)

c.agent.service.register(
    name='user-service',
    service_id='user-service-1',
    address='10.0.0.1',
    port=5001,
    check=consul.Check.http(
        'http://10.0.0.1:5001/health',
        interval='10s'
    )
)

## Discover service
index, data = c.health.service('user-service', passing=True)
for entry in data:
    print(f"Service at {entry['Service']['Address']}:{entry['Service']['Port']}")
```

###### Pattern 3: Circuit Breaker

**Problem**: Khi service A gá»i service B mÃ  B bá»‹ down, A sáº½ timeout. Náº¿u cÃ³ 100 requests, sáº½ cÃ³ 100 timeouts, tá»‘n resources.

**Solution**: Circuit breaker ngáº¯t máº¡ch khi detect failures.


```
States:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  (failures > threshold)  â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ CLOSED â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ OPEN â”‚
â”‚ (OK)   â”‚                           â”‚(FAIL)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â””â”€â”€â”€â”€â”€â”€â”˜
   â†‘      (timeout expires)            â”‚
   â”‚                                   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                                     â”‚ â”‚
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”´â”€â”€â”
                            â”‚ HALF-OPEN   â”‚
                            â”‚ (testing)   â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
from pybreaker import CircuitBreaker
import requests

## Create circuit breaker
breaker = CircuitBreaker(
    fail_max=5,           ## Fail 5 times
    reset_timeout=60      ## Then wait 60s
)

@breaker
def call_user_service(user_id):
    """Call user service with circuit breaker"""
    response = requests.get(
        f'http://user-service/users/{user_id}',
        timeout=5
    )
    response.raise_for_status()
    return response.json()

## Usage
try:
    user = call_user_service(123)
except CircuitBreakerListener:
    ## Circuit is open, return cached data or default
    user = get_cached_user(123) or {"error": "Service unavailable"}
```

###### Pattern 4: Database per Service

**Ã tÆ°á»Ÿng**: Má»—i microservice cÃ³ database riÃªng.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User Service      Product Service            â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚ â”‚ User DB      â”‚  â”‚ Product DB   â”‚          â”‚
â”‚ â”‚ (PostgreSQL) â”‚  â”‚ (MongoDB)    â”‚          â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Æ¯u Ä‘iá»ƒm**:
- Loose coupling
- Má»—i service chá»n DB phÃ¹ há»£p
- Dá»… scale tá»«ng service

**NhÆ°á»£c Ä‘iá»ƒm**:
- KhÃ³ join data tá»« 2 databases
- KhÃ³ maintain consistency

**Khi nÃ o dÃ¹ng**:
- âœ… Khi services thá»±c sá»± Ä‘á»™c láº­p
- âœ… Khi cÃ³ different data models
- âŒ Khi cáº§n join data thÆ°á»ng xuyÃªn

###### Pattern 5: Saga Pattern (Distributed Transactions)

**Problem**: LÃ m sao thá»±c hiá»‡n transaction qua nhiá»u services?

**Example**: Order â†’ Payment â†’ Inventory

```
Saga Pattern:
1. Order Service: Create order (PENDING)
2. Payment Service: Process payment
   - If success: Commit
   - If fail: Rollback order
3. Inventory Service: Reserve inventory
   - If success: Commit
   - If fail: Refund payment, rollback order
```

**Choreography-based Saga** (Event-driven):
```python
## Order Service
@app.route('/orders', methods=['POST'])
def create_order():
    order = Order.create(request.json)
    db.session.commit()
    
    ## Publish event
    publish_event('order.created', {'order_id': order.id})
    
    return {"order_id": order.id}, 201

## Payment Service (listens to order.created)
@event_listener('order.created')
def process_payment(event):
    order_id = event['order_id']
    
    try:
        payment = process_payment_for_order(order_id)
        publish_event('payment.completed', {'order_id': order_id})
    except Exception as e:
        publish_event('payment.failed', {'order_id': order_id})

## Inventory Service (listens to payment.completed)
@event_listener('payment.completed')
def reserve_inventory(event):
    order_id = event['order_id']
    
    try:
        reserve_items_for_order(order_id)
        publish_event('inventory.reserved', {'order_id': order_id})
    except Exception as e:
        publish_event('inventory.failed', {'order_id': order_id})
        ## Trigger compensation transaction
        publish_event('payment.refund', {'order_id': order_id})
```

---

### ChÆ°Æ¡ng 8: Data Consistency Patterns

#### 8.1 Strong Consistency

**Äá»‹nh nghÄ©a**: Táº¥t cáº£ nodes luÃ´n cÃ³ dá»¯ liá»‡u giá»‘ng nhau, khÃ´ng cÃ³ lag.

**Æ¯u Ä‘iá»ƒm**:
- Dá»¯ liá»‡u luÃ´n chÃ­nh xÃ¡c
- PhÃ¹ há»£p vá»›i financial transactions

**NhÆ°á»£c Ä‘iá»ƒm**:
- Cháº­m (pháº£i wait táº¥t cáº£ nodes confirm)
- KhÃ³ scale
- Náº¿u 1 node down, há»‡ thá»‘ng khÃ´ng available

**VÃ­ dá»¥**: ACID databases (PostgreSQL, MySQL)

```
Write request â†’ Master â†’ Replicate to all slaves â†’ Confirm
```

#### 8.2 Eventual Consistency

**Äá»‹nh nghÄ©a**: Replicas cÃ³ thá»ƒ táº¡m thá»i inconsistent, nhÆ°ng cuá»‘i cÃ¹ng sáº½ converge.

**Æ¯u Ä‘iá»ƒm**:
- Nhanh (khÃ´ng cáº§n wait táº¥t cáº£ nodes)
- Dá»… scale
- High availability

**NhÆ°á»£c Ä‘iá»ƒm**:
- Dá»¯ liá»‡u cÃ³ thá»ƒ táº¡m thá»i khÃ´ng chÃ­nh xÃ¡c
- Phá»©c táº¡p hÆ¡n (pháº£i handle conflicts)

**VÃ­ dá»¥**: NoSQL databases (DynamoDB, Cassandra)

```
Write request â†’ Master â†’ Return immediately
                      â†’ Replicate to slaves (async)
```

**Conflict Resolution**:
```python
## Last-write-wins
def merge_data(local, remote):
    if remote['timestamp'] > local['timestamp']:
        return remote
    return local

## Custom merge logic
def merge_user_data(local, remote):
    ## Merge fields intelligently
    merged = local.copy()
    
    ## Prefer non-null values
    for key in remote:
        if remote[key] is not None:
            merged[key] = remote[key]
    
    return merged
```

#### 8.3 Causal Consistency

**Ã tÆ°á»Ÿng**: Náº¿u operation A gÃ¢y ra operation B, thÃ¬ táº¥t cáº£ readers sáº½ tháº¥y A trÆ°á»›c B.

```
Timeline:
1. User writes: "Hello" (timestamp=1)
2. User reads: "Hello" (timestamp=1)
3. Other user reads: "Hello" (timestamp=1)

KhÃ´ng bao giá» xáº£y ra:
- User tháº¥y "Hello" rá»“i khÃ´ng tháº¥y ná»¯a
```

---

### Checklist: Architecture & Design

- [ ] Chá»n scaling strategy phÃ¹ há»£p (horizontal/vertical/diagonal)
- [ ] Implement load balancing
- [ ] CÃ³ health checks cho táº¥t cáº£ services
- [ ] Náº¿u dÃ¹ng microservices:
  - [ ] CÃ³ API Gateway
  - [ ] CÃ³ Service Discovery
  - [ ] Implement Circuit Breaker
  - [ ] CÃ³ strategy cho distributed transactions
- [ ] Quyáº¿t Ä‘á»‹nh consistency model (strong/eventual)
- [ ] Document architecture decisions
- [ ] CÃ³ monitoring cho architecture
- [ ] CÃ³ disaster recovery plan

---

## Production Quality: HÆ°á»›ng Dáº«n ToÃ n Diá»‡n Cho AI Engineer

### PHáº¦N III: RELIABILITY & RESILIENCE

---

### ChÆ°Æ¡ng 9: Resilience Patterns (Chi Tiáº¿t)

#### 9.1 Retry Pattern

**KhÃ¡i niá»‡m**: Khi gáº·p lá»—i transient (táº¡m thá»i), thá»­ láº¡i operation.

**Khi nÃ o dÃ¹ng**:
- âœ… Network timeout
- âœ… Temporary service unavailable (503)
- âœ… Rate limit exceeded (429)
- âŒ Permanent errors (404, 401)
- âŒ Invalid input (400)

###### Retry Strategies

**1. Simple Retry**
```python
def call_api(url, max_retries=3):
    for attempt in range(max_retries):
        try:
            response = requests.get(url, timeout=5)
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            if attempt == max_retries - 1:
                raise
            time.sleep(1)
```

**Problem**: Náº¿u táº¥t cáº£ clients retry cÃ¹ng lÃºc, server sáº½ bá»‹ overwhelm hÆ¡n.

**2. Exponential Backoff**
```python
import time

def call_api_with_backoff(url, max_retries=3):
    for attempt in range(max_retries):
        try:
            response = requests.get(url, timeout=5)
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            if attempt == max_retries - 1:
                raise
            
            ## Wait: 1s, 2s, 4s, 8s...
            wait_time = 2 ** attempt
            print(f"Retry {attempt + 1} after {wait_time}s")
            time.sleep(wait_time)
```

**3. Exponential Backoff with Jitter**
```python
import time
import random

def call_api_with_jitter(url, max_retries=3):
    for attempt in range(max_retries):
        try:
            response = requests.get(url, timeout=5)
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            if attempt == max_retries - 1:
                raise
            
            ## Wait: 1-2s, 2-4s, 4-8s...
            base_wait = 2 ** attempt
            jitter = random.uniform(0, base_wait)
            wait_time = base_wait + jitter
            print(f"Retry {attempt + 1} after {wait_time:.2f}s")
            time.sleep(wait_time)
```

**Táº¡i sao jitter?** Náº¿u táº¥t cáº£ clients retry cÃ¹ng lÃºc (thundering herd), jitter sáº½ phÃ¢n tÃ¡n retry times.

###### Retry Library

```python
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=2, max=10),
    retry=retry_if_exception_type(requests.RequestException)
)
def call_api(url):
    response = requests.get(url, timeout=5)
    response.raise_for_status()
    return response.json()
```

#### 9.2 Circuit Breaker Pattern (Circuit Breaker and Exponential Backoff)

**KhÃ¡i niá»‡m**: Ngáº¯t máº¡ch khi detect failures, trÃ¡nh gá»i service Ä‘ang down.

> Circuit Breaker lÃ  pattern báº£o vá»‡ há»‡ thá»‘ng khá»i viá»‡c gá»i Ä‘i gá»i láº¡i má»™t dependency Ä‘ang lá»—i, cÃ²nÂ **exponential**Â backoff lÃ  chiáº¿n lÆ°á»£c retry vá»›i thá»i gian chá» tÄƒng luá»¹ thá»«a sau má»—i láº§n tháº¥t báº¡i Ä‘á»ƒ giáº£m táº£i vÃ  trÃ¡nh â€œdá»“n cá»¥câ€ request.

Circuit Breaker lÃ  gÃ¬
- Circuit Breaker lÃ  má»™t design pattern dÃ¹ng Ä‘á»ƒ phÃ¡t hiá»‡n lá»—i vÃ  ngÄƒn há»‡ thá»‘ng tiáº¿p tá»¥c gá»i má»™t operation cÃ³ kháº£ nÄƒng cao sáº½ tháº¥t báº¡i.[](https://www.graphapp.ai/engineering-glossary/cloud-computing/circuit-breaker-pattern)â€‹
- NÃ³ hoáº¡t Ä‘á»™ng nhÆ° cáº§u dao Ä‘iá»‡n: khi sá»‘ lá»—i vÆ°á»£t má»™t ngÆ°á»¡ng, â€œmáº¡châ€ sáº½ má»Ÿ (open) Ä‘á»ƒ cháº·n cÃ¡c call tiáº¿p theo trong má»™t khoáº£ng thá»i gian, sau Ä‘Ã³ cho phÃ©p má»™t sá»‘ request â€œthá»­ láº¡iâ€ (half-open), náº¿u á»•n thÃ¬ Ä‘Ã³ng máº¡ch láº¡i (closed).[](https://2coffee.dev/en/articles/circuit-breaker-pattern-the-breaker-in-distributed-calls)

Exponential Backoff lÃ  gÃ¬
- Exponential backoff lÃ  thuáº­t toÃ¡n retry trong Ä‘Ã³ thá»i gian chá» giá»¯a cÃ¡c láº§n retry tÄƒng theo hÃ m luá»¹ thá»«a (thÆ°á»ng nhÃ¢n 2, 4, 8, â€¦) sau má»—i láº§n tháº¥t báº¡i.[](https://en.wikipedia.org/wiki/Exponential_backoff)â€‹
- Má»¥c tiÃªu lÃ  giáº£m táº§n suáº¥t request khi Ä‘ang cÃ³ lá»—i/táº¯c ngháº½n, trÃ¡nh nhiá»u client retry cÃ¹ng lÃºc gÃ¢y sáº­p thÃªm há»‡ thá»‘ng, Ä‘á»“ng thá»i váº«n cho phÃ©p há»‡ thá»‘ng phá»¥c há»“i dáº§n khi lá»—i táº¡m thá»i.[](https://www.twingate.com/blog/glossary/exponential-backoff-algorithm)â€‹
###### States

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CLOSED (Normal)                                     â”‚
â”‚ - Requests pass through                             â”‚
â”‚ - Track failures                                    â”‚
â”‚ - If failures > threshold â†’ OPEN                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPEN (Failing)                                      â”‚
â”‚ - Reject requests immediately                       â”‚
â”‚ - Save resources                                    â”‚
â”‚ - After timeout â†’ HALF_OPEN                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HALF_OPEN (Testing)                                 â”‚
â”‚ - Allow limited requests                            â”‚
â”‚ - If success â†’ CLOSED                               â”‚
â”‚ - If fail â†’ OPEN                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

###### Implementation

```python
from pybreaker import CircuitBreaker
import requests

## Create circuit breaker
breaker = CircuitBreaker(
    fail_max=5,              ## Open after 5 failures
    reset_timeout=60,        ## Try again after 60s
    listeners=[],            ## Event listeners
    exclude=[requests.HTTPError]  ## Don't count these errors
)

@breaker
def call_user_service(user_id):
    response = requests.get(f'http://user-service/users/{user_id}', timeout=5)
    response.raise_for_status()
    return response.json()

## Usage
try:
    user = call_user_service(123)
except CircuitBreakerListener:
    ## Circuit is open
    user = get_cached_user(123) or {"error": "Service unavailable"}
```

###### Configuration Best Practices

```python
## VÃ­ dá»¥: Cáº¥u hÃ¬nh tá»‘t cho production
from pybreaker import CircuitBreaker

breaker = CircuitBreaker(
    name='user-service',
    fail_max=5,                    ## Fail 5 times
    reset_timeout=60,              ## Wait 60s before retry
    exclude=[
        requests.exceptions.Timeout,  ## Don't count timeouts
        requests.exceptions.ConnectionError
    ],
    listeners=[
        CircuitBreakerListener()    ## Log events
    ]
)

## Metrics
@breaker.listener
def on_state_change(cb, old_state, new_state):
    logger.warning(f"Circuit breaker {cb.name}: {old_state} â†’ {new_state}")
    metrics.gauge('circuit_breaker.state', new_state)
```

#### 9.3 Timeout Pattern

**KhÃ¡i niá»‡m**: Set upper bound cho operation duration.

**Táº¡i sao cáº§n**: TrÃ¡nh indefinite waits, giá»¯ resources.

###### Timeout Levels

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Request Timeout (5s)            â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Connection Timeout (2s)     â”‚ â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚ â”‚ â”‚ Read Timeout (3s)       â”‚ â”‚ â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

###### Implementation

```python
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

## Create session with timeout
session = requests.Session()

## Set timeout for all requests
session.timeout = 5  ## 5 seconds

## Or per request
response = requests.get(url, timeout=5)

## Or with different timeouts for connect and read
response = requests.get(url, timeout=(2, 5))  ## (connect, read)

## With retry + timeout
adapter = HTTPAdapter(max_retries=Retry(
    total=3,
    backoff_factor=1,
    status_forcelist=[500, 502, 503, 504]
))
session.mount('http://', adapter)
session.mount('https://', adapter)

response = session.get(url, timeout=5)
```

###### Timeout Strategy

```python
## âŒ BAD: No timeout
response = requests.get(url)  ## Can hang forever

## âœ… GOOD: Always set timeout
response = requests.get(url, timeout=5)

## âœ… BETTER: Different timeouts for different scenarios
if is_critical_path:
    timeout = 1  ## Strict timeout
else:
    timeout = 10  ## More lenient

response = requests.get(url, timeout=timeout)
```

#### 9.4 Bulkhead Pattern

**KhÃ¡i niá»‡m**: Isolate failures Ä‘áº¿n má»™t pháº§n, khÃ´ng áº£nh hÆ°á»Ÿng toÃ n bá»™ há»‡ thá»‘ng.

**VÃ­ dá»¥**: Giá»‘ng ngÄƒn tÃ u thá»§y, náº¿u 1 ngÄƒn bá»‹ nÆ°á»›c, cÃ¡c ngÄƒn khÃ¡c váº«n an toÃ n.

###### Implementation

**1. Thread Pool Isolation**
```python
from concurrent.futures import ThreadPoolExecutor
import threading

## Separate thread pools for different services
user_service_pool = ThreadPoolExecutor(max_workers=10)
product_service_pool = ThreadPoolExecutor(max_workers=10)
order_service_pool = ThreadPoolExecutor(max_workers=10)

def get_user(user_id):
    return user_service_pool.submit(call_user_service, user_id)

def get_product(product_id):
    return product_service_pool.submit(call_product_service, product_id)

## Náº¿u user_service bá»‹ overwhelm, chá»‰ user_service_pool bá»‹ exhaust
## product_service váº«n hoáº¡t Ä‘á»™ng bÃ¬nh thÆ°á»ng
```

**2. Connection Pool Isolation**
```python
import requests
from requests.adapters import HTTPAdapter

## Separate connection pools
user_session = requests.Session()
user_session.mount('http://', HTTPAdapter(pool_connections=10, pool_maxsize=10))

product_session = requests.Session()
product_session.mount('http://', HTTPAdapter(pool_connections=10, pool_maxsize=10))

## Náº¿u user_service slow, khÃ´ng áº£nh hÆ°á»Ÿng product_service
user_response = user_session.get('http://user-service/users/1')
product_response = product_session.get('http://product-service/products/1')
```

**3. Semaphore (Rate Limiting)**
```python
import threading

## Limit concurrent requests to external service
semaphore = threading.Semaphore(10)  ## Max 10 concurrent

def call_external_service():
    with semaphore:
        ## Only 10 threads can execute this at a time
        return requests.get('http://external-service/api')
```

#### 9.5 Fallback Pattern

**KhÃ¡i niá»‡m**: Khi primary action fail, dÃ¹ng alternative.

```python
def get_user_data(user_id):
    try:
        ## Try primary source
        return call_user_service(user_id)
    except Exception as e:
        logger.warning(f"Primary failed: {e}, trying fallback")
        
        try:
            ## Try fallback 1: Cache
            return get_from_cache(user_id)
        except:
            try:
                ## Try fallback 2: Read replica
                return get_from_read_replica(user_id)
            except:
                ## Try fallback 3: Default value
                return get_default_user()
```

---

### ChÆ°Æ¡ng 10: Error Handling (Chi Tiáº¿t)

#### 10.1 Error Classification

**Transient Errors** (CÃ³ thá»ƒ retry)
- Network timeout
- Temporary service unavailable (503)
- Rate limit exceeded (429)
- Connection refused (server restarting)

**Permanent Errors** (KhÃ´ng nÃªn retry)
- Not found (404)
- Unauthorized (401)
- Forbidden (403)
- Bad request (400)
- Internal server error (500) - cÃ³ thá»ƒ retry nhÆ°ng cáº§n cáº©n tháº­n

```python
def is_retryable(exception):
    """Determine if exception is retryable"""
    if isinstance(exception, requests.Timeout):
        return True
    
    if isinstance(exception, requests.ConnectionError):
        return True
    
    if hasattr(exception, 'response'):
        status_code = exception.response.status_code
        ## Retry 5xx errors (except 501)
        if 500 <= status_code < 600 and status_code != 501:
            return True
        ## Retry 429 (rate limit)
        if status_code == 429:
            return True
    
    return False
```

#### 10.2 Structured Error Responses

```python
## âŒ BAD: Unstructured errors
@app.route('/users/<user_id>')
def get_user(user_id):
    try:
        user = db.get_user(user_id)
        return user
    except Exception as e:
        return str(e), 500

## âœ… GOOD: Structured errors
@app.route('/users/<user_id>')
def get_user(user_id):
    try:
        user = db.get_user(user_id)
        if not user:
            return {
                "error": {
                    "code": "USER_NOT_FOUND",
                    "message": f"User {user_id} not found",
                    "status": 404
                }
            }, 404
        return {"data": user}, 200
    
    except DatabaseError as e:
        logger.error(f"Database error: {e}")
        return {
            "error": {
                "code": "DATABASE_ERROR",
                "message": "Failed to fetch user",
                "status": 503
            }
        }, 503
    
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return {
            "error": {
                "code": "INTERNAL_ERROR",
                "message": "Internal server error",
                "status": 500
            }
        }, 500
```

#### 10.3 Error Logging Best Practices

```python
import logging
import traceback
from datetime import datetime

logger = logging.getLogger(__name__)

def log_error(error, context=None):
    """Log error with context"""
    logger.error(
        f"Error occurred",
        extra={
            "error_type": type(error).__name__,
            "error_message": str(error),
            "traceback": traceback.format_exc(),
            "timestamp": datetime.utcnow().isoformat(),
            "context": context or {}
        }
    )

## Usage
try:
    result = process_data(data)
except Exception as e:
    log_error(e, context={
        "user_id": user_id,
        "operation": "process_data",
        "input_size": len(data)
    })
```

#### 10.4 Error Recovery Strategies

**1. Graceful Degradation**
```python
def get_user_profile(user_id):
    """Get user profile with graceful degradation"""
    profile = {}
    
    ## Try to get basic info
    try:
        profile['basic'] = get_user_basic_info(user_id)
    except Exception as e:
        logger.warning(f"Failed to get basic info: {e}")
        profile['basic'] = None
    
    ## Try to get recommendations
    try:
        profile['recommendations'] = get_recommendations(user_id)
    except Exception as e:
        logger.warning(f"Failed to get recommendations: {e}")
        profile['recommendations'] = []
    
    ## Try to get social data
    try:
        profile['social'] = get_social_data(user_id)
    except Exception as e:
        logger.warning(f"Failed to get social data: {e}")
        profile['social'] = None
    
    return profile
```

**2. Compensation Transactions**
```python
def create_order(order_data):
    """Create order with compensation on failure"""
    try:
        ## Step 1: Create order
        order = Order.create(order_data)
        db.session.commit()
        
        ## Step 2: Reserve inventory
        reserve_inventory(order)
        
        ## Step 3: Process payment
        process_payment(order)
        
        return order
    
    except InventoryError:
        ## Compensation: Delete order
        Order.delete(order.id)
        db.session.commit()
        raise
    
    except PaymentError:
        ## Compensation: Release inventory + Delete order
        release_inventory(order)
        Order.delete(order.id)
        db.session.commit()
        raise
```

---

### ChÆ°Æ¡ng 11: Disaster Recovery & Backup

#### 11.1 Backup Strategies

###### 3-2-1 Rule
- **3** copies of data
- **2** different media types
- **1** offsite

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Production Database                     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚       â”‚              â”‚              â”‚
â”Œâ”€â”€â”´â”€â”€â” â”Œâ”€â”€â”´â”€â”€â”       â”Œâ”€â”€â”€â”´â”€â”€â”      â”Œâ”€â”€â”€â”´â”€â”€â”
â”‚Copy1â”‚ â”‚Copy2â”‚       â”‚Copy3 â”‚      â”‚Copy4 â”‚
â”‚Localâ”‚ â”‚Localâ”‚       â”‚Local â”‚      â”‚Cloud â”‚
â”‚SSD  â”‚ â”‚HDD  â”‚       â”‚Tape  â”‚      â”‚S3    â”‚
â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”˜

Táº¡i sao?
- Copy 1,2: Nhanh restore
- Copy 3: Backup lÃ¢u dÃ i
- Copy 4: Offsite (disaster recovery)
```

###### Backup Types

**Full Backup**
```
Day 1: Backup toÃ n bá»™ database (100GB) â†’ 100GB
Day 2: Backup toÃ n bá»™ database (100GB) â†’ 100GB
...
```
- Æ¯u: Nhanh restore
- NhÆ°á»£c: Tá»‘n storage

**Incremental Backup**
```
Day 1: Full backup (100GB) â†’ 100GB
Day 2: Backup changes only (5GB) â†’ 105GB total
Day 3: Backup changes only (3GB) â†’ 108GB total
...
```
- Æ¯u: Tiáº¿t kiá»‡m storage
- NhÆ°á»£c: Restore cháº­m (cáº§n full + táº¥t cáº£ incremental)

**Differential Backup**
```
Day 1: Full backup (100GB) â†’ 100GB
Day 2: Backup changes since Day 1 (5GB) â†’ 105GB total
Day 3: Backup changes since Day 1 (8GB) â†’ 108GB total
...
```
- Æ¯u: Restore nhanh hÆ¡n incremental
- NhÆ°á»£c: Tá»‘n storage hÆ¡n incremental

###### Backup Schedule

```python
## VÃ­ dá»¥: Backup strategy
BACKUP_SCHEDULE = {
    "daily_full": "0 2 * * *",           ## 2 AM every day
    "hourly_incremental": "0 * * * *",   ## Every hour
    "weekly_full": "0 3 * * 0",          ## 3 AM Sunday
    "monthly_full": "0 4 1 * *",         ## 4 AM 1st of month
}

RETENTION_POLICY = {
    "daily": 7,        ## Keep 7 days
    "weekly": 4,       ## Keep 4 weeks
    "monthly": 12,     ## Keep 12 months
    "yearly": 5,       ## Keep 5 years
}
```

#### 11.2 Disaster Recovery Strategies

###### 1. Backup and Restore
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Normal Operation                     â”‚
â”‚ Primary datacenter                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“ (disaster)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Restore from backup                  â”‚
â”‚ Secondary datacenter                 â”‚
â”‚ RTO: Hours to days                   â”‚
â”‚ RPO: Hours                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**RTO** (Recovery Time Objective): Thá»i gian Ä‘á»ƒ recover
**RPO** (Recovery Point Objective): Dá»¯ liá»‡u máº¥t bao lÃ¢u

###### 2. Pilot Light
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Primary (Active)                     â”‚
â”‚ Full production                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Secondary (Standby - Minimal)        â”‚
â”‚ Minimal resources, ready to scale     â”‚
â”‚ RTO: Minutes                         â”‚
â”‚ RPO: Seconds                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

###### 3. Warm Standby
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Primary (Active)                     â”‚
â”‚ Full production                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Secondary (Standby - Scaled Down)    â”‚
â”‚ 50% capacity, ready to takeover      â”‚
â”‚ RTO: Seconds                         â”‚
â”‚ RPO: Seconds                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

###### 4. Active-Active
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Datacenter 1 (Active)                â”‚
â”‚ 50% traffic                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Datacenter 2 (Active)                â”‚
â”‚ 50% traffic                          â”‚
â”‚ RTO: 0 (no downtime)                 â”‚
â”‚ RPO: 0 (no data loss)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 11.3 Backup Implementation

```python
import boto3
import subprocess
from datetime import datetime

class BackupManager:
    def __init__(self, db_host, s3_bucket):
        self.db_host = db_host
        self.s3_bucket = s3_bucket
        self.s3_client = boto3.client('s3')
    
    def backup_database(self):
        """Backup database to S3"""
        timestamp = datetime.utcnow().isoformat()
        backup_file = f"backup-{timestamp}.sql.gz"
        
        try:
            ## Dump database
            dump_cmd = f"mysqldump -h {self.db_host} --all-databases | gzip"
            result = subprocess.run(dump_cmd, shell=True, capture_output=True)
            
            if result.returncode != 0:
                logger.error(f"Backup failed: {result.stderr}")
                return False
            
            ## Upload to S3
            self.s3_client.put_object(
                Bucket=self.s3_bucket,
                Key=f"backups/{backup_file}",
                Body=result.stdout
            )
            
            logger.info(f"Backup successful: {backup_file}")
            return True
        
        except Exception as e:
            logger.error(f"Backup error: {e}")
            return False
    
    def restore_database(self, backup_file):
        """Restore database from S3"""
        try:
            ## Download from S3
            response = self.s3_client.get_object(
                Bucket=self.s3_bucket,
                Key=f"backups/{backup_file}"
            )
            
            ## Restore database
            restore_cmd = f"gunzip | mysql -h {self.db_host}"
            subprocess.run(
                restore_cmd,
                shell=True,
                input=response['Body'].read()
            )
            
            logger.info(f"Restore successful: {backup_file}")
            return True
        
        except Exception as e:
            logger.error(f"Restore error: {e}")
            return False
```

---

### ChÆ°Æ¡ng 12: Capacity Planning & Forecasting

#### 12.1 Capacity Planning Process

```
1. Collect Historical Data
   â†“
2. Analyze Trends
   â†“
3. Forecast Future Demand
   â†“
4. Plan Resources
   â†“
5. Monitor & Adjust
```

#### 12.2 Metrics to Track

```python
## Key metrics for capacity planning
metrics = {
    "cpu_usage": 45,           ## %
    "memory_usage": 60,        ## %
    "disk_usage": 75,          ## %
    "network_bandwidth": 50,   ## %
    "database_connections": 80,## %
    "request_latency_p99": 200,## ms
    "error_rate": 0.1,         ## %
}

## Thresholds for alerting
THRESHOLDS = {
    "cpu_usage": 80,           ## Alert if > 80%
    "memory_usage": 85,        ## Alert if > 85%
    "disk_usage": 90,          ## Alert if > 90%
    "request_latency_p99": 500,## Alert if > 500ms
}
```

#### 12.3 Forecasting

```python
import numpy as np
from sklearn.linear_model import LinearRegression

def forecast_capacity(historical_data, days_ahead=30):
    """Forecast capacity needs"""
    X = np.arange(len(historical_data)).reshape(-1, 1)
    y = np.array(historical_data)
    
    model = LinearRegression()
    model.fit(X, y)
    
    ## Predict future
    future_X = np.arange(len(historical_data), len(historical_data) + days_ahead).reshape(-1, 1)
    forecast = model.predict(future_X)
    
    return forecast

## Usage
cpu_history = [45, 47, 50, 52, 55, 58, 60, 62]
forecast = forecast_capacity(cpu_history, days_ahead=30)

## If forecast shows 90% in 30 days, plan to upgrade
if max(forecast) > 80:
    logger.warning("CPU usage will exceed 80% in 30 days. Plan upgrade.")
```

---

### Checklist: Reliability & Resilience

- [ ] Implement retry logic vá»›i exponential backoff
- [ ] Setup circuit breakers cho external service calls
- [ ] Set appropriate timeouts
- [ ] Implement bulkhead pattern
- [ ] Have fallback strategies
- [ ] Structured error handling
- [ ] Comprehensive error logging
- [ ] Backup strategy (3-2-1 rule)
- [ ] Disaster recovery plan tested
- [ ] Capacity planning process
- [ ] Monitoring for all critical metrics
- [ ] Runbooks for common incidents

---

## Production Quality: HÆ°á»›ng Dáº«n ToÃ n Diá»‡n Cho AI Engineer

### PHáº¦N IV: OBSERVABILITY & MONITORING

---

### ChÆ°Æ¡ng 13: Three Pillars of Observability

#### 13.1 Metrics (Sá»‘ Liá»‡u)

**Äá»‹nh nghÄ©a**: Dá»¯ liá»‡u Ä‘á»‹nh lÆ°á»£ng vá» há»‡ thá»‘ng (CPU, memory, latency, error rate).

###### Metric Types

**1. Gauge** - GiÃ¡ trá»‹ táº¡i má»™t thá»i Ä‘iá»ƒm
```
CPU usage: 45%
Memory usage: 60%
Active connections: 125
```

**2. Counter** - GiÃ¡ trá»‹ tÄƒng theo thá»i gian
```
Total requests: 1,000,000
Total errors: 500
Total bytes sent: 10GB
```

**3. Histogram** - PhÃ¢n bá»‘ giÃ¡ trá»‹
```
Request latency:
  < 100ms: 50%
  100-500ms: 40%
  > 500ms: 10%
```

**4. Summary** - Percentiles
```
Request latency:
  P50: 100ms
  P95: 250ms
  P99: 500ms
```

###### Key Metrics

**Application Metrics**
```
- Request rate (RPS)
- Error rate (%)
- Latency (P50, P95, P99)
- Throughput (requests/sec)
- Cache hit rate (%)
```

**Infrastructure Metrics**
```
- CPU usage (%)
- Memory usage (%)
- Disk usage (%)
- Network bandwidth (Mbps)
- Disk I/O (IOPS)
```

**Business Metrics**
```
- Conversion rate (%)
- Revenue per user
- User retention (%)
- Feature usage (%)
```

###### Metrics Implementation

```python
from prometheus_client import Counter, Gauge, Histogram, Summary

## Counter: Total requests
request_count = Counter(
    'http_requests_total',
    'Total HTTP requests',
    ['method', 'endpoint', 'status']
)

## Gauge: Current active connections
active_connections = Gauge(
    'active_connections',
    'Number of active connections'
)

## Histogram: Request latency
request_latency = Histogram(
    'http_request_duration_seconds',
    'HTTP request latency',
    ['method', 'endpoint'],
    buckets=[0.01, 0.05, 0.1, 0.5, 1.0, 5.0]
)

## Summary: Request latency percentiles
request_summary = Summary(
    'http_request_duration_summary',
    'HTTP request latency summary',
    ['method', 'endpoint']
)

## Usage
@app.route('/api/users/<user_id>')
def get_user(user_id):
    start_time = time.time()
    active_connections.inc()
    
    try:
        user = db.get_user(user_id)
        request_count.labels(method='GET', endpoint='/users', status=200).inc()
        return {"data": user}, 200
    except Exception as e:
        request_count.labels(method='GET', endpoint='/users', status=500).inc()
        return {"error": str(e)}, 500
    finally:
        duration = time.time() - start_time
        request_latency.labels(method='GET', endpoint='/users').observe(duration)
        request_summary.labels(method='GET', endpoint='/users').observe(duration)
        active_connections.dec()
```

#### 13.2 Logging (Ghi ChÃ©p)

**Äá»‹nh nghÄ©a**: Ghi chÃ©p chi tiáº¿t vá» sá»± kiá»‡n xáº£y ra trong há»‡ thá»‘ng.

###### Log Levels

```
DEBUG   - Chi tiáº¿t nháº¥t, dÃ¹ng cho development
INFO    - ThÃ´ng tin chung
WARNING - Cáº£nh bÃ¡o, cÃ³ thá»ƒ cÃ³ váº¥n Ä‘á»
ERROR   - Lá»—i, cáº§n chÃº Ã½
CRITICAL- Lá»—i nghiÃªm trá»ng, há»‡ thá»‘ng cÃ³ thá»ƒ down
```

###### Structured Logging

```python
import json
import logging
from datetime import datetime

## âŒ BAD: Unstructured logging
logger.error(f"Error: {error}")

## âœ… GOOD: Structured logging
logger.error("Database error", extra={
    "error_type": type(error).__name__,
    "error_message": str(error),
    "user_id": user_id,
    "operation": "get_user",
    "timestamp": datetime.utcnow().isoformat(),
    "trace_id": trace_id
})

## Output (JSON format)
{
    "timestamp": "2024-01-15T10:30:45.123Z",
    "level": "ERROR",
    "message": "Database error",
    "error_type": "ConnectionError",
    "error_message": "Connection refused",
    "user_id": 123,
    "operation": "get_user",
    "trace_id": "abc123"
}
```

###### Logging Best Practices

```python
import logging
import json

## Configure JSON logging
class JSONFormatter(logging.Formatter):
    def format(self, record):
        log_data = {
            "timestamp": self.formatTime(record),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno,
        }
        
        ## Add extra fields
        if hasattr(record, 'extra'):
            log_data.update(record.extra)
        
        ## Add exception info if present
        if record.exc_info:
            log_data["exception"] = self.formatException(record.exc_info)
        
        return json.dumps(log_data)

## Setup logger
handler = logging.StreamHandler()
handler.setFormatter(JSONFormatter())
logger = logging.getLogger(__name__)
logger.addHandler(handler)

## Usage
logger.info("User login", extra={
    "user_id": 123,
    "ip_address": "192.168.1.1",
    "timestamp": datetime.utcnow().isoformat()
})
```

###### Log Aggregation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Service 1   â”‚
â”‚ logs        â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â†’ Fluentd/Logstash â”€â”€â†’ Elasticsearch â”€â”€â†’ Kibana
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
â”‚ Service 2   â”‚
â”‚ logs        â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
â”‚ Service 3   â”‚
â”‚ logs        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Setup ELK Stack**:
```yaml
## docker-compose.yml
version: '3'
services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.14.0
    environment:
      - discovery.type=single-node
    ports:
      - "9200:9200"
  
  kibana:
    image: docker.elastic.co/kibana/kibana:7.14.0
    ports:
      - "5601:5601"
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
  
  logstash:
    image: docker.elastic.co/logstash/logstash:7.14.0
    volumes:
      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf
    ports:
      - "5000:5000"
```

#### 13.3 Tracing (Theo DÃµi)

**Äá»‹nh nghÄ©a**: Theo dÃµi request qua cÃ¡c services khÃ¡c nhau.

###### Distributed Tracing

```
Request tá»« client:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ API Gateway                                     â”‚
â”‚ trace_id: abc123                                â”‚
â”‚ span_id: 1                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
      â”‚             â”‚
â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
â”‚ User       â”‚ â”‚ Product  â”‚
â”‚ Service    â”‚ â”‚ Service  â”‚
â”‚ span_id: 2 â”‚ â”‚ span_id: 3
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

###### Tracing Implementation

```python
from jaeger_client import Config
from opentracing.propagation import Format

## Initialize Jaeger
config = Config(
    config={
        'sampler': {
            'type': 'const',
            'param': 1,
        },
        'logging': True,
    },
    service_name='my-service',
)
jaeger_tracer = config.initialize_tracer()

## Use in code
@app.route('/api/users/<user_id>')
def get_user(user_id):
    with jaeger_tracer.start_active_span('get_user') as scope:
        span = scope.span
        span.set_tag('user_id', user_id)
        
        try:
            ## Call user service
            with jaeger_tracer.start_active_span('call_user_service'):
                user = call_user_service(user_id)
            
            ## Call product service
            with jaeger_tracer.start_active_span('call_product_service'):
                products = call_product_service(user_id)
            
            span.set_tag('status', 'success')
            return {"user": user, "products": products}
        
        except Exception as e:
            span.set_tag('error', True)
            span.log_kv({'event': 'error', 'message': str(e)})
            raise
```

---

### ChÆ°Æ¡ng 14: Monitoring Strategy

#### 14.1 Metrics to Monitor

###### System Metrics
```
CPU Usage:
  - Alert if > 80% for 5 minutes
  - Critical if > 95% for 2 minutes

Memory Usage:
  - Alert if > 85% for 5 minutes
  - Critical if > 95% for 2 minutes

Disk Usage:
  - Alert if > 80% for 1 hour
  - Critical if > 90%

Network Bandwidth:
  - Alert if > 80% of capacity
  - Critical if > 95%
```

###### Application Metrics
```
Request Rate:
  - Track RPS (requests per second)
  - Alert if sudden drop (possible issue)

Error Rate:
  - Alert if > 1% (or based on SLO)
  - Critical if > 5%

Latency:
  - Alert if P95 > 500ms
  - Critical if P99 > 1000ms

Cache Hit Rate:
  - Alert if < 80% (possible cache issue)
```

###### Business Metrics
```
Conversion Rate:
  - Track daily
  - Alert if drop > 10%

Revenue:
  - Track hourly
  - Alert if drop > 20%

User Retention:
  - Track weekly
  - Alert if drop > 5%
```

#### 14.2 Alerting Strategy

###### Alert Fatigue Prevention

```python
## âŒ BAD: Too many alerts
alerts = [
    "CPU > 50%",
    "CPU > 60%",
    "CPU > 70%",
    "CPU > 80%",
    "CPU > 90%",
]
## Result: Team ignores alerts (alert fatigue)

## âœ… GOOD: Meaningful alerts
alerts = [
    "CPU > 80% for 5 minutes",
    "Error rate > 1%",
    "Latency P99 > 500ms",
]
## Result: Team responds to real issues
```

###### Alert Routing

```python
## VÃ­ dá»¥: Alert routing logic
def route_alert(alert):
    if alert.severity == "CRITICAL":
        ## Page on-call engineer
        notify_pagerduty(alert)
    
    elif alert.severity == "WARNING":
        ## Send to Slack
        notify_slack(alert)
    
    elif alert.severity == "INFO":
        ## Log only
        logger.info(alert)
```

###### Alert Configuration

```yaml
## Prometheus alerting rules
groups:
  - name: application_alerts
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.01
        for: 5m
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }} errors/sec"
      
      - alert: HighLatency
        expr: histogram_quantile(0.99, http_request_duration_seconds) > 1
        for: 5m
        annotations:
          summary: "High latency detected"
          description: "P99 latency is {{ $value }}s"
      
      - alert: LowCacheHitRate
        expr: cache_hit_rate < 0.8
        for: 10m
        annotations:
          summary: "Low cache hit rate"
          description: "Cache hit rate is {{ $value }}"
```

#### 14.3 Monitoring Dashboard

```python
## VÃ­ dá»¥: Grafana dashboard JSON
dashboard = {
    "title": "Application Monitoring",
    "panels": [
        {
            "title": "Request Rate",
            "targets": [
                {
                    "expr": "rate(http_requests_total[5m])"
                }
            ]
        },
        {
            "title": "Error Rate",
            "targets": [
                {
                    "expr": "rate(http_requests_total{status=~'5..'}[5m])"
                }
            ]
        },
        {
            "title": "Latency P99",
            "targets": [
                {
                    "expr": "histogram_quantile(0.99, http_request_duration_seconds)"
                }
            ]
        },
        {
            "title": "CPU Usage",
            "targets": [
                {
                    "expr": "node_cpu_usage_percent"
                }
            ]
        }
    ]
}
```

---

### ChÆ°Æ¡ng 15: Alerting & Incident Response

#### 15.1 Alert Severity Levels

```
CRITICAL (P1)
â”œâ”€ Immediate action required
â”œâ”€ Page on-call engineer
â”œâ”€ Example: Service down, data loss
â””â”€ Response time: < 5 minutes

HIGH (P2)
â”œâ”€ Urgent action needed
â”œâ”€ Notify team
â”œâ”€ Example: High error rate, performance degradation
â””â”€ Response time: < 15 minutes

MEDIUM (P3)
â”œâ”€ Should be addressed soon
â”œâ”€ Log and track
â”œâ”€ Example: Elevated latency, low cache hit rate
â””â”€ Response time: < 1 hour

LOW (P4)
â”œâ”€ Can be addressed later
â”œâ”€ Log only
â”œâ”€ Example: Informational metrics
â””â”€ Response time: < 1 day
```

#### 15.2 Incident Response Process

```
1. DETECT
   â””â”€ Alert fires
      â†“
2. ACKNOWLEDGE
   â””â”€ On-call engineer acknowledges
      â†“
3. INVESTIGATE
   â””â”€ Gather logs, metrics, traces
      â†“
4. MITIGATE
   â””â”€ Quick fix to reduce impact
      â†“
5. RESOLVE
   â””â”€ Permanent fix
      â†“
6. POST-MORTEM
   â””â”€ Learn from incident
```

###### Incident Response Runbook

```markdown
## Incident: High Error Rate

### Detection
- Alert: Error rate > 1% for 5 minutes
- Severity: P2 (High)

### Investigation
1. Check error logs:
   ```
   kubectl logs -f deployment/api-server
   ```

2. Check metrics:
   - Error rate trend
   - Affected endpoints
   - Error types

3. Check recent deployments:
   ```
   kubectl rollout history deployment/api-server
   ```

### Mitigation
1. If recent deployment caused issue:
   ```
   kubectl rollout undo deployment/api-server
   ```

2. If database issue:
   - Check database connections
   - Check slow queries
   - Restart database if needed

3. If external service issue:
   - Check circuit breaker status
   - Verify external service health

### Resolution
1. Identify root cause
2. Implement permanent fix
3. Deploy fix
4. Monitor metrics

### Post-Mortem
- What happened?
- Why did it happen?
- How to prevent in future?
- Action items
```

#### 15.3 On-Call Management

```python
## On-call rotation
ON_CALL_SCHEDULE = {
    "2024-01-15": {
        "primary": "alice@company.com",
        "secondary": "bob@company.com"
    },
    "2024-01-22": {
        "primary": "charlie@company.com",
        "secondary": "diana@company.com"
    }
}

## Escalation policy
ESCALATION_POLICY = {
    "critical": {
        "primary_timeout": 5,      ## minutes
        "secondary_timeout": 10,
        "manager_timeout": 15
    },
    "high": {
        "primary_timeout": 15,
        "secondary_timeout": 30
    }
}
```

---

### ChÆ°Æ¡ng 16: Cost Optimization for Observability

#### 16.1 Metrics Cardinality

**Problem**: Trop many unique metric combinations = high cost

```python
## âŒ BAD: High cardinality
request_duration = Histogram(
    'http_request_duration',
    ['method', 'endpoint', 'user_id', 'client_ip']
)
## If 1000 users Ã— 1000 IPs Ã— 100 endpoints = 100M combinations

## âœ… GOOD: Low cardinality
request_duration = Histogram(
    'http_request_duration',
    ['method', 'endpoint', 'status']
)
## Only 3 Ã— 100 Ã— 5 = 1500 combinations
```

#### 16.2 Log Sampling

```python
import random

def should_log_request(request):
    """Sample logs to reduce volume"""
    ## Always log errors
    if request.status >= 400:
        return True
    
    ## Always log slow requests
    if request.duration > 1000:  ## ms
        return True
    
    ## Sample 1% of normal requests
    if random.random() < 0.01:
        return True
    
    return False
```

#### 16.3 Retention Policies

```yaml
## Prometheus retention
global:
  retention: 15d  ## Keep 15 days of data

## Elasticsearch retention
index_patterns:
  - pattern: "logs-*"
    retention: 30d
  - pattern: "metrics-*"
    retention: 90d
```

---

### Checklist: Observability & Monitoring

- [ ] Metrics collection setup (Prometheus)
- [ ] Structured logging setup (ELK Stack)
- [ ] Distributed tracing setup (Jaeger)
- [ ] Key metrics identified and tracked
- [ ] Alerting rules configured
- [ ] Alert routing setup
- [ ] Monitoring dashboards created
- [ ] On-call schedule established
- [ ] Incident response runbooks written
- [ ] Log retention policies defined
- [ ] Metrics cardinality managed
- [ ] Cost optimization for observability

---

## Production Quality: HÆ°á»›ng Dáº«n ToÃ n Diá»‡n Cho AI Engineer

### PHáº¦N V: DEPLOYMENT & CI/CD

---

### ChÆ°Æ¡ng 17: CI/CD Pipeline Best Practices

#### 17.1 Pipeline Architecture

```
Commit to Git
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STAGE 1: BUILD                                â”‚
â”‚ - Checkout code                               â”‚
â”‚ - Build application                           â”‚
â”‚ - Create Docker image                         â”‚
â”‚ - Push to registry                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STAGE 2: TEST                                 â”‚
â”‚ - Unit tests                                  â”‚
â”‚ - Integration tests                           â”‚
â”‚ - Code coverage check                         â”‚
â”‚ - Linting & formatting                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STAGE 3: SECURITY SCAN                        â”‚
â”‚ - SAST (Static Analysis)                      â”‚
â”‚ - Dependency scanning                         â”‚
â”‚ - Container scanning                          â”‚
â”‚ - Secret scanning                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STAGE 4: DEPLOY TO STAGING                    â”‚
â”‚ - Deploy to staging environment               â”‚
â”‚ - Run smoke tests                             â”‚
â”‚ - Performance tests                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STAGE 5: DEPLOY TO PRODUCTION                 â”‚
â”‚ - Blue-green or canary deployment             â”‚
â”‚ - Health checks                               â”‚
â”‚ - Monitoring                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
Monitor & Rollback if needed
```

#### 17.2 CI/CD Tools

| Tool | Pros | Cons |
|------|------|------|
| GitHub Actions | Native to GitHub, free | Limited customization |
| GitLab CI/CD | Powerful, integrated | Steeper learning curve |
| Jenkins | Highly customizable | Complex setup |
| CircleCI | Easy to use, good docs | Pricing |
| AWS CodePipeline | AWS integration | AWS-specific |

#### 17.3 Pipeline Configuration Example

```yaml
## .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov flake8
      
      - name: Lint code
        run: flake8 src/ --count --select=E9,F63,F7,F82 --show-source --statistics
      
      - name: Run unit tests
        run: pytest tests/unit/ -v --cov=src
      
      - name: Run integration tests
        run: pytest tests/integration/ -v
      
      - name: Security scan (SAST)
        run: |
          pip install bandit
          bandit -r src/ -f json -o bandit-report.json
      
      - name: Dependency scan
        run: |
          pip install safety
          safety check --json > safety-report.json
      
      - name: Build Docker image
        run: docker build -t myapp:${{ github.sha }} .
      
      - name: Push to registry
        run: |
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          docker tag myapp:${{ github.sha }} myapp:latest
          docker push myapp:${{ github.sha }}
          docker push myapp:latest
      
      - name: Deploy to staging
        if: github.ref == 'refs/heads/develop'
        run: |
          kubectl set image deployment/app app=myapp:${{ github.sha }} -n staging
          kubectl rollout status deployment/app -n staging
      
      - name: Deploy to production
        if: github.ref == 'refs/heads/main'
        run: |
          ## Blue-green deployment
          kubectl set image deployment/app-green app=myapp:${{ github.sha }} -n production
          kubectl rollout status deployment/app-green -n production
          ## Switch traffic
          kubectl patch service app -p '{"spec":{"selector":{"version":"green"}}}' -n production
```

#### 17.4 Build Optimization

```yaml
## Dockerfile with multi-stage build
FROM python:3.11 as builder

WORKDIR /build
COPY requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

## Final stage
FROM python:3.11-slim

WORKDIR /app
COPY --from=builder /root/.local /root/.local
COPY src/ .

ENV PATH=/root/.local/bin:$PATH

EXPOSE 5000
CMD ["python", "app.py"]
```

**Benefits**:
- Smaller final image
- Faster builds
- Reduced attack surface

---

### ChÆ°Æ¡ng 18: Deployment Strategies

#### 18.1 Blue-Green Deployment

```
Before:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Load Balancer                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚          â”‚
â”Œâ”€â”€â”€â”´â”€â”€â”   â”Œâ”€â”€â”´â”€â”€â”€â”€â”
â”‚Blue  â”‚   â”‚Green  â”‚
â”‚(v1)  â”‚   â”‚(v1)   â”‚
â”‚Activeâ”‚   â”‚Standbyâ”‚
â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”˜

During:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Load Balancer                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚          â”‚
â”Œâ”€â”€â”€â”´â”€â”€â”   â”Œâ”€â”€â”´â”€â”€â”€â”€â”
â”‚Blue  â”‚   â”‚Green  â”‚
â”‚(v1)  â”‚   â”‚(v2)   â”‚
â”‚Activeâ”‚   â”‚Testingâ”‚
â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”˜

After:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Load Balancer                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚          â”‚
â”Œâ”€â”€â”€â”´â”€â”€â”   â”Œâ”€â”€â”´â”€â”€â”€â”€â”
â”‚Blue  â”‚   â”‚Green  â”‚
â”‚(v1)  â”‚   â”‚(v2)   â”‚
â”‚Standbyâ”‚  â”‚Active â”‚
â””â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Æ¯u Ä‘iá»ƒm**:
- Zero downtime
- Easy rollback
- Full environment testing

**NhÆ°á»£c Ä‘iá»ƒm**:
- Cáº§n 2x resources
- Database migration complexity

#### 18.2 Canary Deployment

```
Phase 1: 5% traffic to new version
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Load Balancer                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              â”‚
â”Œâ”€â”€â”€â”´â”€â”€â”       â”Œâ”€â”€â”€â”´â”€â”€â”
â”‚v1    â”‚       â”‚v2    â”‚
â”‚95%   â”‚       â”‚5%    â”‚
â””â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”˜

Phase 2: 50% traffic
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Load Balancer                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              â”‚
â”Œâ”€â”€â”€â”´â”€â”€â”       â”Œâ”€â”€â”€â”´â”€â”€â”
â”‚v1    â”‚       â”‚v2    â”‚
â”‚50%   â”‚       â”‚50%   â”‚
â””â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”˜

Phase 3: 100% traffic
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Load Balancer                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚
      â”Œâ”€â”€â”´â”€â”€â”
      â”‚v2   â”‚
      â”‚100% â”‚
      â””â”€â”€â”€â”€â”€â”˜
```

**Æ¯u Ä‘iá»ƒm**:
- Gradual rollout
- Monitor impact before full deployment
- Easy rollback

**NhÆ°á»£c Ä‘iá»ƒm**:
- Slower deployment
- Complex traffic routing

#### 18.3 Rolling Deployment

```
Initial:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Pod 1 (v1)â”‚Pod 2 (v1)â”‚Pod 3 (v1)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 1: Update Pod 1
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Pod 1 (v2)â”‚Pod 2 (v1)â”‚Pod 3 (v1)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: Update Pod 2
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Pod 1 (v2)â”‚Pod 2 (v2)â”‚Pod 3 (v1)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 3: Update Pod 3
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Pod 1 (v2)â”‚Pod 2 (v2)â”‚Pod 3 (v2)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Æ¯u Ä‘iá»ƒm**:
- No downtime
- Gradual update
- Easy rollback

**NhÆ°á»£c Ä‘iá»ƒm**:
- Complex orchestration
- Need to handle mixed versions

#### 18.4 Deployment Strategy Selection

| Strategy | Downtime | Speed | Rollback | Resources |
|----------|----------|-------|----------|-----------|
| Blue-Green | 0 | Fast | Easy | 2x |
| Canary | 0 | Slow | Easy | 1.1x |
| Rolling | 0 | Medium | Medium | 1x |
| Recreate | Yes | Fast | Hard | 1x |

---

### ChÆ°Æ¡ng 19: Environment Management

#### 19.1 Environment Types

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DEVELOPMENT                         â”‚
â”‚ - Local machine                     â”‚
â”‚ - Rapid iteration                   â”‚
â”‚ - No security constraints           â”‚
â”‚ - Can break anytime                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STAGING                             â”‚
â”‚ - Production-like environment       â”‚
â”‚ - For testing before release        â”‚
â”‚ - Same infrastructure as prod       â”‚
â”‚ - Real data (masked)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PRODUCTION                          â”‚
â”‚ - Live user traffic                 â”‚
â”‚ - Highest security                  â”‚
â”‚ - Strict change control             â”‚
â”‚ - Real data                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 19.2 Configuration Management

```python
## âŒ BAD: Hardcoded configuration
DATABASE_URL = "postgresql://user:pass@prod-db:5432/mydb"
API_KEY = "sk-1234567890abcdef"
DEBUG = False

## âœ… GOOD: Environment-based configuration
import os
from dotenv import load_dotenv

load_dotenv()

DATABASE_URL = os.getenv('DATABASE_URL')
API_KEY = os.getenv('API_KEY')
DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'

## Or using config management
from config import Config

class DevelopmentConfig(Config):
    DEBUG = True
    DATABASE_URL = "postgresql://user:pass@localhost:5432/mydb_dev"

class ProductionConfig(Config):
    DEBUG = False
    DATABASE_URL = os.getenv('DATABASE_URL')

config = DevelopmentConfig() if os.getenv('ENV') == 'dev' else ProductionConfig()
```

#### 19.3 Infrastructure as Code (IaC)

```hcl
## Terraform example
provider "aws" {
  region = "us-east-1"
}

resource "aws_ecs_cluster" "main" {
  name = "production-cluster"
}

resource "aws_ecs_service" "app" {
  name            = "app-service"
  cluster         = aws_ecs_cluster.main.id
  task_definition = aws_ecs_task_definition.app.arn
  desired_count   = 3
  
  load_balancer {
    target_group_arn = aws_lb_target_group.app.arn
    container_name   = "app"
    container_port   = 5000
  }
}

resource "aws_autoscaling_group" "app" {
  name                = "app-asg"
  vpc_zone_identifier = var.subnet_ids
  min_size            = 3
  max_size            = 10
  desired_capacity    = 3
  
  launch_template {
    id      = aws_launch_template.app.id
    version = "$Latest"
  }
}
```

**Benefits**:
- Version control for infrastructure
- Reproducible environments
- Easy scaling
- Disaster recovery

---

### ChÆ°Æ¡ng 20: Rollback Strategies

#### 20.1 Automated Rollback

```python
## VÃ­ dá»¥: Rollback on health check failure
def deploy_and_monitor(new_version):
    """Deploy and rollback if health checks fail"""
    try:
        ## Deploy new version
        deploy(new_version)
        
        ## Monitor for 5 minutes
        for i in range(30):  ## 30 checks Ã— 10s = 5 minutes
            time.sleep(10)
            
            health = check_health()
            if health['status'] != 'healthy':
                logger.error(f"Health check failed: {health}")
                rollback(previous_version)
                return False
            
            metrics = get_metrics()
            if metrics['error_rate'] > 0.05:  ## 5% error rate
                logger.error(f"Error rate too high: {metrics['error_rate']}")
                rollback(previous_version)
                return False
        
        logger.info("Deployment successful")
        return True
    
    except Exception as e:
        logger.error(f"Deployment failed: {e}")
        rollback(previous_version)
        return False
```

#### 20.2 Manual Rollback

```bash
## Kubernetes rollback
kubectl rollout history deployment/app
kubectl rollout undo deployment/app
kubectl rollout undo deployment/app --to-revision=2

## Docker rollback
docker service update --image myapp:previous-version app-service

## Database rollback
## For migrations, always have rollback scripts
./migrate.sh rollback
```

---

### Checklist: Deployment & CI/CD

- [ ] CI/CD pipeline setup
- [ ] Automated testing in pipeline
- [ ] Security scanning integrated
- [ ] Build optimization (caching, multi-stage)
- [ ] Deployment strategy chosen
- [ ] Blue-green or canary setup
- [ ] Health checks configured
- [ ] Automated rollback setup
- [ ] Environment management
- [ ] Configuration management
- [ ] Infrastructure as Code
- [ ] Deployment runbooks
- [ ] Team trained on deployment process

---

## Production Quality: HÆ°á»›ng Dáº«n ToÃ n Diá»‡n Cho AI Engineer

### PHáº¦N VI: SECURITY

---

### ChÆ°Æ¡ng 21: Authentication & Authorization

#### 21.1 Authentication Methods

###### 1. OAuth 2.0

```
User â†’ Application â†’ OAuth Provider (Google, GitHub, etc.)
                        â†“
                    User logs in
                        â†“
                    Returns token
                        â†“
                    Application can access user data
```

**Implementation**:
```python
from flask import Flask, redirect, url_for, session
from authlib.integrations.flask_client import OAuth

app = Flask(__name__)
oauth = OAuth(app)

google = oauth.register(
    name='google',
    client_id='YOUR_CLIENT_ID',
    client_secret='YOUR_CLIENT_SECRET',
    server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
    client_kwargs={'scope': 'openid email profile'}
)

@app.route('/login')
def login():
    redirect_uri = url_for('authorize', _external=True)
    return google.authorize_redirect(redirect_uri)

@app.route('/authorize')
def authorize():
    token = google.authorize_access_token()
    user = token.get('userinfo')
    session['user'] = user
    return redirect('/')
```

###### 2. JWT (JSON Web Tokens)

```
Header: {"alg": "HS256", "typ": "JWT"}
Payload: {"user_id": 123, "exp": 1234567890}
Signature: HMACSHA256(header + payload, secret)

Token: header.payload.signature
```

**Implementation**:
```python
from flask_jwt_extended import JWTManager, create_access_token, jwt_required

app.config['JWT_SECRET_KEY'] = 'your-secret-key'
jwt = JWTManager(app)

@app.route('/login', methods=['POST'])
def login():
    user_id = request.json['user_id']
    password = request.json['password']
    
    ## Verify credentials
    if verify_password(user_id, password):
        access_token = create_access_token(identity=user_id)
        return {"access_token": access_token}
    
    return {"error": "Invalid credentials"}, 401

@app.route('/protected')
@jwt_required()
def protected():
    from flask_jwt_extended import get_jwt_identity
    user_id = get_jwt_identity()
    return {"user_id": user_id}
```

###### 3. API Keys

```python
## âŒ BAD: Hardcoded API key
API_KEY = "sk-1234567890abcdef"

## âœ… GOOD: API key from environment
import os
API_KEY = os.getenv('API_KEY')

## Validate API key
@app.before_request
def validate_api_key():
    api_key = request.headers.get('X-API-Key')
    if not api_key or api_key != os.getenv('API_KEY'):
        return {"error": "Invalid API key"}, 401
```

#### 21.2 Authorization (RBAC)

```python
from functools import wraps

## Define roles
ROLES = {
    'admin': ['read', 'write', 'delete', 'manage_users'],
    'user': ['read', 'write'],
    'guest': ['read']
}

def require_role(required_role):
    """Decorator to check user role"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            from flask_jwt_extended import get_jwt_identity
            user_id = get_jwt_identity()
            user_role = get_user_role(user_id)
            
            if user_role not in ROLES or required_role not in ROLES[user_role]:
                return {"error": "Insufficient permissions"}, 403
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

## Usage
@app.route('/admin/users', methods=['DELETE'])
@require_role('admin')
def delete_user():
    user_id = request.json['user_id']
    delete_user_from_db(user_id)
    return {"status": "deleted"}
```

---

### ChÆ°Æ¡ng 22: Data Protection

#### 22.1 Encryption at Rest

```python
from cryptography.fernet import Fernet
import os

## Generate key (do this once and store securely)
key = Fernet.generate_key()

## Create cipher
cipher_suite = Fernet(key)

## Encrypt data
plaintext = b"sensitive data"
encrypted_data = cipher_suite.encrypt(plaintext)

## Decrypt data
decrypted_data = cipher_suite.decrypt(encrypted_data)
```

**Database Encryption**:
```sql
-- PostgreSQL with pgcrypto
CREATE EXTENSION pgcrypto;

-- Encrypt column
UPDATE users SET email = pgp_pub_encrypt(email, pgp_key_create()) WHERE id > 0;

-- Decrypt column
SELECT pgp_pub_decrypt(email, pgp_key_create()) FROM users;
```

#### 22.2 Encryption in Transit

```python
## âœ… GOOD: HTTPS/TLS
import ssl
from flask import Flask

app = Flask(__name__)

## Force HTTPS
@app.before_request
def enforce_https():
    if not request.is_secure and not app.debug:
        url = request.url.replace('http://', 'https://', 1)
        return redirect(url, code=301)

## SSL/TLS configuration
if __name__ == '__main__':
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain('cert.pem', 'key.pem')
    app.run(ssl_context=context)
```

#### 22.3 Input Validation

```python
## âŒ BAD: No validation
@app.route('/users/<user_id>')
def get_user(user_id):
    user = db.query(f"SELECT * FROM users WHERE id = {user_id}")
    return user

## âœ… GOOD: Validation
from flask import request
from marshmallow import Schema, fields, ValidationError

class UserSchema(Schema):
    user_id = fields.Int(required=True)
    email = fields.Email(required=True)
    age = fields.Int(validate=lambda x: 0 < x < 150)

@app.route('/users/<int:user_id>')
def get_user(user_id):
    ## Type validation
    if not isinstance(user_id, int):
        return {"error": "Invalid user_id"}, 400
    
    ## Range validation
    if user_id < 0:
        return {"error": "Invalid user_id"}, 400
    
    user = db.get_user(user_id)
    return user

## Or using ORM
from sqlalchemy import and_

user = db.session.query(User).filter(
    and_(
        User.id == user_id,
        User.id > 0
    )
).first()
```

#### 22.4 SQL Injection Prevention

```python
## âŒ BAD: SQL Injection vulnerability
user_id = request.args.get('user_id')
user = db.query(f"SELECT * FROM users WHERE id = {user_id}")

## âœ… GOOD: Parameterized queries
user = db.query("SELECT * FROM users WHERE id = ?", (user_id,))

## Or with ORM
user = User.query.filter_by(id=user_id).first()
```

---

### ChÆ°Æ¡ng 23: Security Scanning & Compliance

#### 23.1 SAST (Static Application Security Testing)

```bash
## Using Bandit for Python
pip install bandit
bandit -r src/ -f json -o bandit-report.json

## Using SonarQube
docker run -d --name sonarqube -p 9000:9000 sonarqube

## Using Snyk
npm install -g snyk
snyk test
```

#### 23.2 DAST (Dynamic Application Security Testing)

```bash
## Using OWASP ZAP
docker run -t owasp/zap2docker-stable zap-baseline.py -t http://target-app

## Using Burp Suite
## Manual or automated scanning
```

#### 23.3 Dependency Scanning (SCA)

```bash
## Using OWASP Dependency-Check
dependency-check --project "MyApp" --scan /path/to/app

## Using Snyk
snyk test

## Using Safety (Python)
pip install safety
safety check
```

#### 23.4 Secrets Detection

```bash
## Using git-secrets
git secrets --install
git secrets --register-aws

## Using TruffleHog
trufflehog filesystem /path/to/repo

## Using Gitleaks
gitleaks detect --source filesystem --path /path/to/repo
```

#### 23.5 Compliance Standards

###### GDPR (General Data Protection Regulation)
```
Requirements:
- Data privacy by design
- Data minimization
- User consent
- Right to be forgotten
- Data breach notification (72 hours)
```

###### HIPAA (Health Insurance Portability and Accountability Act)
```
Requirements:
- PHI (Protected Health Information) encryption
- Access controls
- Audit logging
- Disaster recovery
```

###### SOC 2 (Service Organization Control)
```
Requirements:
- Security
- Availability
- Processing integrity
- Confidentiality
- Privacy
```

---

### ChÆ°Æ¡ng 24: Secrets Management

#### 24.1 Secrets Storage

```python
## âŒ BAD: Hardcoded secrets
DATABASE_PASSWORD = "mypassword123"
API_KEY = "sk-1234567890"

## âœ… GOOD: Environment variables
import os
DATABASE_PASSWORD = os.getenv('DATABASE_PASSWORD')
API_KEY = os.getenv('API_KEY')

## âœ… BETTER: Secrets manager
import boto3

def get_secret(secret_name):
    client = boto3.client('secretsmanager')
    response = client.get_secret_value(SecretId=secret_name)
    return response['SecretString']

DATABASE_PASSWORD = get_secret('db-password')
API_KEY = get_secret('api-key')
```

#### 24.2 Secrets Rotation

```python
## Automatic secrets rotation
def rotate_secrets():
    """Rotate all secrets"""
    secrets = [
        'database-password',
        'api-key',
        'jwt-secret'
    ]
    
    for secret_name in secrets:
        ## Generate new secret
        new_secret = generate_secure_random()
        
        ## Update in secrets manager
        update_secret(secret_name, new_secret)
        
        ## Update in application
        update_application_config(secret_name, new_secret)
        
        ## Log rotation
        logger.info(f"Rotated secret: {secret_name}")

## Schedule rotation (e.g., every 90 days)
from apscheduler.schedulers.background import BackgroundScheduler

scheduler = BackgroundScheduler()
scheduler.add_job(rotate_secrets, 'interval', days=90)
scheduler.start()
```

#### 24.3 Vault Integration

```python
import hvac

## Connect to Vault
client = hvac.Client(url='http://vault:8200', token='mytoken')

## Read secret
secret = client.secrets.kv.read_secret_version(path='secret/database')
password = secret['data']['data']['password']

## Write secret
client.secrets.kv.create_or_update_secret_version(
    path='secret/api-key',
    secret_data={'key': 'sk-1234567890'}
)

## Rotate secret
client.auth.approle.generate_secret_id('my-role')
```

---

### ChÆ°Æ¡ng 25: Network Security

#### 25.1 VPC (Virtual Private Cloud)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Internet                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”‚ NAT     â”‚
        â”‚ Gateway â”‚
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
             â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ VPC             â”‚
    â”‚ 10.0.0.0/16     â”‚
    â”‚                 â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚ â”‚ Public      â”‚ â”‚
    â”‚ â”‚ Subnet      â”‚ â”‚
    â”‚ â”‚ 10.0.1.0/24 â”‚ â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â”‚                 â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚ â”‚ Private     â”‚ â”‚
    â”‚ â”‚ Subnet      â”‚ â”‚
    â”‚ â”‚ 10.0.2.0/24 â”‚ â”‚
    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 25.2 Security Groups

```python
## AWS Security Group
import boto3

ec2 = boto3.client('ec2')

## Create security group
sg = ec2.create_security_group(
    GroupName='app-sg',
    Description='Security group for app'
)

## Allow inbound HTTP
ec2.authorize_security_group_ingress(
    GroupId=sg['GroupId'],
    IpPermissions=[
        {
            'IpProtocol': 'tcp',
            'FromPort': 80,
            'ToPort': 80,
            'IpRanges': [{'CidrIp': '0.0.0.0/0'}]
        }
    ]
)

## Allow inbound HTTPS
ec2.authorize_security_group_ingress(
    GroupId=sg['GroupId'],
    IpPermissions=[
        {
            'IpProtocol': 'tcp',
            'FromPort': 443,
            'ToPort': 443,
            'IpRanges': [{'CidrIp': '0.0.0.0/0'}]
        }
    ]
)

## Deny all outbound except to specific IPs
ec2.revoke_security_group_egress(
    GroupId=sg['GroupId'],
    IpPermissions=[
        {
            'IpProtocol': '-1',
            'IpRanges': [{'CidrIp': '0.0.0.0/0'}]
        }
    ]
)
```

#### 25.3 WAF (Web Application Firewall)

```python
## AWS WAF
import boto3

waf = boto3.client('wafv2')

## Create IP set for rate limiting
ip_set = waf.create_ip_set(
    Name='rate-limit-ips',
    Scope='REGIONAL',
    IPAddressVersion='IPV4',
    Addresses=['192.168.1.1/32']
)

## Create rule
rule = {
    'Name': 'rate-limit-rule',
    'Priority': 0,
    'Statement': {
        'RateBasedStatement': {
            'Limit': 2000,
            'AggregateKeyType': 'IP'
        }
    },
    'Action': {'Block': {}},
    'VisibilityConfig': {
        'SampledRequestsEnabled': True,
        'CloudWatchMetricsEnabled': True,
        'MetricName': 'rate-limit-rule'
    }
}
```

---

### ChÆ°Æ¡ng 26: DDoS Protection

#### 26.1 DDoS Mitigation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Attacker (sending many requests)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”‚ CDN     â”‚
        â”‚ (Cache) â”‚
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
             â”‚
        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”‚ WAF     â”‚
        â”‚ (Filter)â”‚
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
             â”‚
        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”‚ Rate    â”‚
        â”‚ Limiter â”‚
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
             â”‚
        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”‚ App     â”‚
        â”‚ Server  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 26.2 Rate Limiting

```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

@app.route('/api/users')
@limiter.limit("10 per minute")
def get_users():
    return {"users": []}

## Or custom rate limiting
from collections import defaultdict
import time

class RateLimiter:
    def __init__(self, max_requests, window_seconds):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests = defaultdict(list)
    
    def is_allowed(self, client_id):
        now = time.time()
        ## Remove old requests outside window
        self.requests[client_id] = [
            req_time for req_time in self.requests[client_id]
            if now - req_time < self.window_seconds
        ]
        
        ## Check if under limit
        if len(self.requests[client_id]) < self.max_requests:
            self.requests[client_id].append(now)
            return True
        
        return False
```

---

### Checklist: Security

- [ ] Authentication method chosen (OAuth, JWT, API keys)
- [ ] Authorization (RBAC) implemented
- [ ] Encryption at rest configured
- [ ] HTTPS/TLS enforced
- [ ] Input validation implemented
- [ ] SQL injection prevention
- [ ] SAST scanning integrated
- [ ] Dependency scanning setup
- [ ] Secrets scanning setup
- [ ] Secrets management (Vault/Secrets Manager)
- [ ] Secrets rotation configured
- [ ] VPC and security groups configured
- [ ] WAF rules configured
- [ ] DDoS protection setup
- [ ] Compliance requirements identified
- [ ] Security audit scheduled
- [ ] Team trained on security best practices

---

## Production Quality: HÆ°á»›ng Dáº«n ToÃ n Diá»‡n Cho AI Engineer

### PHáº¦N VII: TESTING

---

### ChÆ°Æ¡ng 27: Testing Pyramid

#### 27.1 Testing Levels

```
        â–²
       /|\
      / | \
     /  |  \  E2E Tests (10%)
    /   |   \
   /    |    \
  /     |     \ Integration Tests (20%)
 /      |      \
/       |       \ Unit Tests (70%)
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
```

| Level | Scope | Speed | Cost | Coverage |
|-------|-------|-------|------|----------|
| Unit | Single function | Milliseconds | Low | High |
| Integration | Multiple components | Seconds | Medium | Medium |
| E2E | Full workflow | Minutes | High | Low |

#### 27.2 Unit Testing

```python
import pytest
from myapp.user_service import UserService

class TestUserService:
    @pytest.fixture
    def user_service(self):
        """Setup test fixture"""
        return UserService(db=MockDatabase())
    
    def test_create_user_success(self, user_service):
        """Test successful user creation"""
        ## Arrange
        user_data = {
            "name": "John Doe",
            "email": "john@example.com",
            "age": 30
        }
        
        ## Act
        result = user_service.create_user(user_data)
        
        ## Assert
        assert result['id'] is not None
        assert result['name'] == "John Doe"
        assert result['email'] == "john@example.com"
    
    def test_create_user_invalid_email(self, user_service):
        """Test user creation with invalid email"""
        user_data = {
            "name": "John Doe",
            "email": "invalid-email",
            "age": 30
        }
        
        with pytest.raises(ValueError):
            user_service.create_user(user_data)
    
    def test_create_user_invalid_age(self, user_service):
        """Test user creation with invalid age"""
        user_data = {
            "name": "John Doe",
            "email": "john@example.com",
            "age": -5
        }
        
        with pytest.raises(ValueError):
            user_service.create_user(user_data)
    
    @pytest.mark.parametrize("age", [0, -1, 150, 200])
    def test_create_user_boundary_ages(self, user_service, age):
        """Test user creation with boundary ages"""
        user_data = {
            "name": "John Doe",
            "email": "john@example.com",
            "age": age
        }
        
        with pytest.raises(ValueError):
            user_service.create_user(user_data)
```

**Mocking**:
```python
from unittest.mock import Mock, patch

def test_user_service_with_mock():
    ## Mock database
    mock_db = Mock()
    mock_db.insert.return_value = {"id": 1, "name": "John"}
    
    service = UserService(db=mock_db)
    result = service.create_user({"name": "John"})
    
    ## Verify mock was called
    mock_db.insert.assert_called_once()
    assert result['id'] == 1
```

#### 27.3 Integration Testing

```python
import pytest
from myapp import create_app
from myapp.db import db

@pytest.fixture
def app():
    """Create and configure test app"""
    app = create_app(config='testing')
    
    with app.app_context():
        db.create_all()
        yield app
        db.session.remove()
        db.drop_all()

@pytest.fixture
def client(app):
    """Test client"""
    return app.test_client()

class TestUserAPI:
    def test_create_user_integration(self, client):
        """Test user creation through API"""
        response = client.post('/api/users', json={
            "name": "John Doe",
            "email": "john@example.com"
        })
        
        assert response.status_code == 201
        assert response.json['id'] is not None
    
    def test_get_user_integration(self, client):
        """Test getting user through API"""
        ## Create user
        create_response = client.post('/api/users', json={
            "name": "John Doe",
            "email": "john@example.com"
        })
        user_id = create_response.json['id']
        
        ## Get user
        get_response = client.get(f'/api/users/{user_id}')
        
        assert get_response.status_code == 200
        assert get_response.json['name'] == "John Doe"
    
    def test_user_database_transaction(self, client):
        """Test database transaction"""
        ## Create user
        response = client.post('/api/users', json={
            "name": "John Doe",
            "email": "john@example.com"
        })
        
        ## Verify in database
        from myapp.models import User
        user = User.query.filter_by(email="john@example.com").first()
        assert user is not None
        assert user.name == "John Doe"
```

**Using TestContainers**:
```python
import pytest
from testcontainers.postgres import PostgresContainer

@pytest.fixture(scope="session")
def postgres_container():
    """Start PostgreSQL container for tests"""
    with PostgresContainer("postgres:13") as postgres:
        yield postgres

@pytest.fixture
def db_connection(postgres_container):
    """Create database connection"""
    conn = postgres_container.get_connection_client()
    yield conn
    conn.close()
```

#### 27.4 End-to-End (E2E) Testing

```python
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

@pytest.fixture
def driver():
    """Setup Selenium driver"""
    driver = webdriver.Chrome()
    yield driver
    driver.quit()

class TestUserJourney:
    def test_user_signup_and_login(self, driver):
        """Test complete user signup and login flow"""
        ## Navigate to signup page
        driver.get("http://localhost:5000/signup")
        
        ## Fill signup form
        name_input = driver.find_element(By.ID, "name")
        name_input.send_keys("John Doe")
        
        email_input = driver.find_element(By.ID, "email")
        email_input.send_keys("john@example.com")
        
        password_input = driver.find_element(By.ID, "password")
        password_input.send_keys("SecurePassword123!")
        
        ## Submit form
        submit_button = driver.find_element(By.ID, "signup-button")
        submit_button.click()
        
        ## Wait for redirect to login page
        WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "login-form"))
        )
        
        ## Fill login form
        email_input = driver.find_element(By.ID, "login-email")
        email_input.send_keys("john@example.com")
        
        password_input = driver.find_element(By.ID, "login-password")
        password_input.send_keys("SecurePassword123!")
        
        login_button = driver.find_element(By.ID, "login-button")
        login_button.click()
        
        ## Wait for dashboard
        WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "dashboard"))
        )
        
        ## Verify user is logged in
        assert "Dashboard" in driver.title
```

---

### ChÆ°Æ¡ng 28: Performance & Security Testing

#### 28.1 Load Testing

```python
from locust import HttpUser, task, between

class UserBehavior(HttpUser):
    wait_time = between(1, 5)
    
    @task(1)
    def get_users(self):
        self.client.get("/api/users")
    
    @task(2)
    def get_user(self):
        self.client.get("/api/users/1")
    
    @task(1)
    def create_user(self):
        self.client.post("/api/users", json={
            "name": "John Doe",
            "email": "john@example.com"
        })
```

**Run load test**:
```bash
locust -f locustfile.py --host=http://localhost:5000 -u 100 -r 10
```

#### 28.2 Stress Testing

```python
## Gradually increase load until system breaks
import time
from locust import HttpUser, task

class StressTest(HttpUser):
    @task
    def stress_endpoint(self):
        ## Send requests as fast as possible
        for i in range(1000):
            self.client.get("/api/users")
            time.sleep(0.001)  ## 1ms between requests
```

#### 28.3 Spike Testing

```python
## Sudden increase in traffic
import time

def spike_test():
    ## Normal traffic
    for i in range(100):
        make_request()
    
    time.sleep(5)
    
    ## Spike: 10x traffic
    for i in range(1000):
        make_request()
    
    time.sleep(5)
    
    ## Back to normal
    for i in range(100):
        make_request()
```

#### 28.4 Security Testing

```python
import requests

def test_sql_injection():
    """Test SQL injection vulnerability"""
    payload = "1' OR '1'='1"
    response = requests.get(f"http://localhost:5000/api/users/{payload}")
    
    ## Should not return all users
    assert len(response.json()) == 1

def test_xss_vulnerability():
    """Test XSS vulnerability"""
    payload = "<script>alert('XSS')</script>"
    response = requests.post("http://localhost:5000/api/users", json={
        "name": payload,
        "email": "test@example.com"
    })
    
    ## Should escape HTML
    assert "<script>" not in response.json()['name']

def test_authentication_bypass():
    """Test authentication bypass"""
    ## Try to access protected endpoint without token
    response = requests.get("http://localhost:5000/api/protected")
    
    ## Should return 401
    assert response.status_code == 401

def test_rate_limiting():
    """Test rate limiting"""
    ## Make many requests
    for i in range(100):
        response = requests.get("http://localhost:5000/api/users")
        
        if response.status_code == 429:  ## Too many requests
            print(f"Rate limit hit after {i} requests")
            return
    
    ## Should have hit rate limit
    assert False, "Rate limiting not working"
```

---

### ChÆ°Æ¡ng 29: Test Automation & CI/CD Integration

#### 29.1 Test Configuration

```yaml
## pytest.ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = -v --cov=src --cov-report=html --cov-report=term
markers =
    unit: Unit tests
    integration: Integration tests
    e2e: End-to-end tests
    slow: Slow tests
    security: Security tests
```

#### 29.2 Test Execution Strategy

```bash
## Run all tests
pytest

## Run only unit tests
pytest -m unit

## Run only integration tests
pytest -m integration

## Run with coverage
pytest --cov=src --cov-report=html

## Run in parallel
pytest -n auto

## Run with specific markers
pytest -m "not slow"
```

#### 29.3 CI/CD Integration

```yaml
## .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.9, '3.10', '3.11']
    
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-xdist
      
      - name: Run unit tests
        run: pytest tests/unit -m unit -v
      
      - name: Run integration tests
        run: pytest tests/integration -m integration -v
      
      - name: Run security tests
        run: pytest tests/security -m security -v
      
      - name: Upload coverage
        run: |
          pip install codecov
          codecov
```

#### 29.4 Test Coverage

```python
## Aim for high coverage but focus on critical paths
## âœ… GOOD: 80% coverage
## âŒ BAD: 100% coverage with meaningless tests

## Example: Critical paths to test
CRITICAL_PATHS = [
    "user_authentication",
    "payment_processing",
    "data_validation",
    "error_handling"
]

## Less critical (lower priority)
LESS_CRITICAL = [
    "logging",
    "formatting",
    "utility_functions"
]
```

---

### ChÆ°Æ¡ng 30: Test Data Management

#### 30.1 Test Data Strategies

```python
## âŒ BAD: Using production data
def test_user_creation():
    user = User.query.filter_by(email="real@example.com").first()
    assert user is not None

## âœ… GOOD: Using fixtures
@pytest.fixture
def test_user():
    user = User.create(
        name="Test User",
        email="test@example.com",
        age=30
    )
    yield user
    user.delete()

def test_user_creation(test_user):
    assert test_user.name == "Test User"
```

#### 30.2 Factory Pattern

```python
import factory
from myapp.models import User

class UserFactory(factory.Factory):
    class Meta:
        model = User
    
    name = factory.Faker('name')
    email = factory.Faker('email')
    age = factory.Faker('random_int', min=18, max=80)

## Usage
def test_user_creation():
    user = UserFactory.create()
    assert user.name is not None
    assert user.email is not None
```

#### 30.3 Test Data Cleanup

```python
@pytest.fixture(autouse=True)
def cleanup():
    """Auto cleanup after each test"""
    yield
    
    ## Cleanup
    User.query.delete()
    db.session.commit()
```

---

### Checklist: Testing

- [ ] Unit tests written (70% of tests)
- [ ] Integration tests written (20% of tests)
- [ ] E2E tests written (10% of tests)
- [ ] Test coverage > 80%
- [ ] Load testing done
- [ ] Security testing done
- [ ] Performance benchmarks established
- [ ] Test data management setup
- [ ] CI/CD integration for tests
- [ ] Test execution in parallel
- [ ] Test reporting setup
- [ ] Team trained on testing best practices

---

## Production Quality: HÆ°á»›ng Dáº«n ToÃ n Diá»‡n Cho AI Engineer

### PHáº¦N VIII: CODE QUALITY & MAINTAINABILITY

---

### ChÆ°Æ¡ng 31: Code Quality Metrics

#### 31.1 Key Metrics

**Cyclomatic Complexity**
```python
## âŒ BAD: High complexity (CC = 5)
def process_order(order):
    if order.status == 'pending':
        if order.total > 1000:
            if order.customer.is_vip:
                discount = 0.2
            else:
                discount = 0.1
        else:
            discount = 0.05
    else:
        discount = 0
    
    return order.total * (1 - discount)

## âœ… GOOD: Low complexity (CC = 1)
def get_discount(order):
    discount_rules = {
        ('pending', True, True): 0.2,    ## pending, >1000, vip
        ('pending', True, False): 0.1,   ## pending, >1000, not vip
        ('pending', False, False): 0.05, ## pending, <=1000
    }
    
    key = (order.status, order.total > 1000, order.customer.is_vip)
    return discount_rules.get(key, 0)

def process_order(order):
    discount = get_discount(order)
    return order.total * (1 - discount)
```

**Code Coverage**
```
Target: 80% coverage
- Critical paths: 100%
- Business logic: 90%
- Utilities: 70%
- UI/Formatting: 50%
```

**Code Duplication**
```python
## âŒ BAD: Duplicated code
def validate_user(user):
    if not user.name or len(user.name) < 2:
        raise ValueError("Invalid name")
    if not user.email or '@' not in user.email:
        raise ValueError("Invalid email")

def validate_product(product):
    if not product.name or len(product.name) < 2:
        raise ValueError("Invalid name")
    if not product.sku or len(product.sku) < 2:
        raise ValueError("Invalid sku")

## âœ… GOOD: Extracted common logic
def validate_field(value, field_name, min_length=2):
    if not value or len(str(value)) < min_length:
        raise ValueError(f"Invalid {field_name}")

def validate_user(user):
    validate_field(user.name, "name")
    validate_field(user.email, "email")

def validate_product(product):
    validate_field(product.name, "name")
    validate_field(product.sku, "sku")
```

#### 31.2 Code Quality Tools

```bash
## Python
pylint src/              ## Linting
flake8 src/              ## Style checking
black src/               ## Code formatting
mypy src/                ## Type checking
radon cc src/            ## Cyclomatic complexity

## JavaScript
eslint src/              ## Linting
prettier src/            ## Formatting
jest --coverage          ## Testing with coverage
```

---

### PHáº¦N IX: INFRASTRUCTURE & CONTAINERIZATION

---

### ChÆ°Æ¡ng 32: Docker Best Practices

#### 32.1 Dockerfile Optimization

```dockerfile
## âŒ BAD: Large image
FROM python:3.11
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
EXPOSE 5000
CMD ["python", "app.py"]
## Image size: ~900MB

## âœ… GOOD: Multi-stage build
FROM python:3.11 as builder
WORKDIR /build
COPY requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

FROM python:3.11-slim
WORKDIR /app
COPY --from=builder /root/.local /root/.local
COPY src/ .
ENV PATH=/root/.local/bin:$PATH
EXPOSE 5000
CMD ["python", "app.py"]
## Image size: ~200MB
```

#### 32.2 Docker Security

```dockerfile
## Run as non-root user
FROM python:3.11-slim
RUN useradd -m appuser
USER appuser
WORKDIR /app
COPY src/ .
CMD ["python", "app.py"]

## Scan for vulnerabilities
## docker scan myapp:latest
```

---

### ChÆ°Æ¡ng 33: Kubernetes in Production

#### 33.1 Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: app
  template:
    metadata:
      labels:
        app: app
    spec:
      containers:
      - name: app
        image: myapp:latest
        ports:
        - containerPort: 5000
        
        ## Resource limits
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        
        ## Health checks
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        
        readinessProbe:
          httpGet:
            path: /ready
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 5
        
        ## Environment variables
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-url
```

#### 33.2 Service & Ingress

```yaml
## Service
apiVersion: v1
kind: Service
metadata:
  name: app-service
spec:
  selector:
    app: app
  ports:
  - protocol: TCP
    port: 80
    targetPort: 5000
  type: LoadBalancer

---
## Ingress
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
spec:
  rules:
  - host: myapp.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app-service
            port:
              number: 80
```

---

### PHáº¦N X: DATABASE & DATA MANAGEMENT

---

### ChÆ°Æ¡ng 34: Database Design & Optimization

#### 34.1 Database Indexing

```sql
-- âŒ BAD: No indexes
SELECT * FROM users WHERE email = 'john@example.com';
-- Full table scan: O(n)

-- âœ… GOOD: With index
CREATE INDEX idx_users_email ON users(email);
SELECT * FROM users WHERE email = 'john@example.com';
-- Index scan: O(log n)

-- Composite index
CREATE INDEX idx_users_email_status ON users(email, status);
SELECT * FROM users WHERE email = 'john@example.com' AND status = 'active';
```

#### 34.2 Query Optimization

```sql
-- âŒ BAD: N+1 query problem
SELECT * FROM users;
-- Then for each user:
SELECT * FROM orders WHERE user_id = ?;

-- âœ… GOOD: Join
SELECT u.*, o.* FROM users u
LEFT JOIN orders o ON u.id = o.user_id;

-- Or batch query
SELECT * FROM orders WHERE user_id IN (?, ?, ?);
```

#### 34.3 Connection Pooling

```python
from sqlalchemy import create_engine

## Create engine with connection pooling
engine = create_engine(
    'postgresql://user:pass@localhost/db',
    pool_size=20,           ## Number of connections to keep
    max_overflow=10,        ## Additional connections when needed
    pool_recycle=3600,      ## Recycle connections after 1 hour
    pool_pre_ping=True      ## Test connection before using
)
```

---

### PHáº¦N XI: API DESIGN & INTEGRATION

---

### ChÆ°Æ¡ng 35: RESTful API Best Practices

#### 35.1 API Design

```python
## âœ… GOOD: RESTful API
GET    /api/v1/users              ## List users
GET    /api/v1/users/<id>         ## Get user
POST   /api/v1/users              ## Create user
PUT    /api/v1/users/<id>         ## Update user
DELETE /api/v1/users/<id>         ## Delete user

## Response format
{
    "status": 200,
    "data": {
        "id": 1,
        "name": "John Doe",
        "email": "john@example.com"
    },
    "timestamp": "2024-01-15T10:30:45Z"
}

## Error response
{
    "status": 400,
    "error": {
        "code": "INVALID_INPUT",
        "message": "Email is required"
    },
    "timestamp": "2024-01-15T10:30:45Z"
}
```

#### 35.2 API Versioning

```python
## URL-based versioning
GET /api/v1/users
GET /api/v2/users

## Header-based versioning
GET /api/users
Header: API-Version: 1

## Accept header
GET /api/users
Header: Accept: application/vnd.myapp.v1+json
```

#### 35.3 Pagination & Filtering

```python
## Pagination
GET /api/users?page=1&limit=10

## Filtering
GET /api/users?status=active&role=admin

## Sorting
GET /api/users?sort=created_at&order=desc

## Implementation
@app.route('/api/users')
def get_users():
    page = request.args.get('page', 1, type=int)
    limit = request.args.get('limit', 10, type=int)
    status = request.args.get('status')
    
    query = User.query
    
    if status:
        query = query.filter_by(status=status)
    
    users = query.paginate(page=page, per_page=limit)
    
    return {
        "data": [u.to_dict() for u in users.items],
        "total": users.total,
        "page": page,
        "pages": users.pages
    }
```

---

### PHáº¦N XII: CONFIGURATION & SECRETS

---

### ChÆ°Æ¡ng 36: Environment Management

#### 36.1 Configuration Hierarchy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Environment Variables (Highest)     â”‚
â”‚ (set in deployment)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ .env.production                     â”‚
â”‚ (production-specific)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ .env.staging                        â”‚
â”‚ (staging-specific)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ .env.development                    â”‚
â”‚ (development defaults)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ config.py (Lowest)                  â”‚
â”‚ (hardcoded defaults)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 36.2 Configuration Management

```python
import os
from dotenv import load_dotenv

## Load environment-specific config
env = os.getenv('ENV', 'development')
load_dotenv(f'.env.{env}')

class Config:
    DATABASE_URL = os.getenv('DATABASE_URL', 'postgresql://localhost/mydb')
    API_KEY = os.getenv('API_KEY')
    DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'
    LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')

## Validate required config
required_vars = ['DATABASE_URL', 'API_KEY']
for var in required_vars:
    if not os.getenv(var):
        raise ValueError(f"Missing required environment variable: {var}")
```

---

### PHáº¦N XIII: DOCUMENTATION

---

### ChÆ°Æ¡ng 37: Code Documentation

#### 37.1 Documentation Types

```python
## 1. Docstrings
def create_user(name, email):
    """
    Create a new user.
    
    Args:
        name (str): User's full name
        email (str): User's email address
    
    Returns:
        User: Created user object
    
    Raises:
        ValueError: If email is invalid
        DuplicateError: If email already exists
    
    Example:
        >>> user = create_user("John Doe", "john@example.com")
        >>> user.id
        1
    """
    pass

## 2. Type hints
def create_user(name: str, email: str) -> User:
    pass

## 3. Comments
## Explain WHY, not WHAT
## âŒ BAD: i = i + 1  ## Increment i
## âœ… GOOD: i = i + 1  ## Move to next item in batch
```

#### 37.2 API Documentation

```python
## Using Flask-RESTX
from flask_restx import Api, Resource, fields

api = Api(app, doc='/docs')

user_model = api.model('User', {
    'id': fields.Integer(required=True),
    'name': fields.String(required=True),
    'email': fields.String(required=True)
})

@api.route('/users/<int:id>')
class UserResource(Resource):
    @api.doc('get_user')
    @api.marshal_with(user_model)
    def get(self, id):
        """Get user by ID"""
        return User.query.get(id)
```

---

### PHáº¦N XIV: PRODUCTION READINESS

---

### ChÆ°Æ¡ng 38: Production Readiness Review (PRR)

#### 38.1 PRR Checklist

```markdown
## Production Readiness Review

### Architecture & Design
- [ ] Architecture documented
- [ ] Scalability plan defined
- [ ] Load balancing configured
- [ ] Disaster recovery plan exists

### Reliability
- [ ] Retry logic implemented
- [ ] Circuit breakers configured
- [ ] Timeouts set
- [ ] Fallback strategies defined

### Observability
- [ ] Metrics collection setup
- [ ] Logging configured
- [ ] Distributed tracing enabled
- [ ] Alerting rules configured

### Security
- [ ] Authentication implemented
- [ ] Authorization implemented
- [ ] Encryption at rest/transit
- [ ] Security scanning passed
- [ ] Secrets management setup

### Testing
- [ ] Unit tests: 70%+
- [ ] Integration tests: 20%+
- [ ] E2E tests: 10%+
- [ ] Load testing done
- [ ] Security testing done

### Deployment
- [ ] CI/CD pipeline setup
- [ ] Automated testing in pipeline
- [ ] Deployment strategy chosen
- [ ] Rollback strategy tested

### Operations
- [ ] Runbooks written
- [ ] On-call schedule established
- [ ] SLO/SLA defined
- [ ] Incident response plan

### Documentation
- [ ] Architecture documented
- [ ] API documented
- [ ] Runbooks written
- [ ] Team trained
```

#### 38.2 SLO/SLI/SLA

```
SLI (Service Level Indicator): Metric
- Availability: 99.9%
- Latency P99: 200ms
- Error rate: 0.1%

SLO (Service Level Objective): Target
- Availability: 99.95%
- Latency P99: 150ms
- Error rate: 0.05%

SLA (Service Level Agreement): Contract
- Availability: 99.9%
- Penalty: 10% refund if breached
```

---

### PHáº¦N XV: MLOPS & AI SYSTEMS IN PRODUCTION

---

### ChÆ°Æ¡ng 39: MLOps Fundamentals

#### 39.1 ML Pipeline Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Data Ingestion                      â”‚
â”‚ (Batch/Streaming)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Data Preprocessing                  â”‚
â”‚ (Cleaning, Validation)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Feature Engineering                 â”‚
â”‚ (Feature Store)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Model Training                      â”‚
â”‚ (Experiment Tracking)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Model Evaluation                    â”‚
â”‚ (Validation, Testing)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Model Registry                      â”‚
â”‚ (Versioning, Metadata)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Model Deployment                    â”‚
â”‚ (Serving, Monitoring)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Monitoring & Feedback               â”‚
â”‚ (Drift Detection, Retraining)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 39.2 Model Serving

```python
## Batch serving
def batch_predict(data_path):
    """Predict on batch of data"""
    data = load_data(data_path)
    predictions = model.predict(data)
    save_predictions(predictions)

## Online serving
from flask import Flask, request

app = Flask(__name__)
model = load_model('model.pkl')

@app.route('/predict', methods=['POST'])
def predict():
    """Real-time prediction"""
    data = request.json
    prediction = model.predict([data])
    return {"prediction": prediction[0]}

## Streaming serving
from kafka import KafkaConsumer, KafkaProducer

consumer = KafkaConsumer('input-topic')
producer = KafkaProducer('output-topic')

for message in consumer:
    data = json.loads(message.value)
    prediction = model.predict([data])
    producer.send('output-topic', json.dumps(prediction).encode())
```

#### 39.3 Model Monitoring

```python
from evidently.report import Report
from evidently.metrics import DataDriftMetric, ModelPerformanceMetric

## Detect data drift
report = Report(metrics=[
    DataDriftMetric(),
    ModelPerformanceMetric()
])

report.run(reference_data=train_data, current_data=prod_data)
report.show()

## Alert on drift
if report.as_dict()['metrics'][0]['result']['drift_detected']:
    logger.warning("Data drift detected! Trigger retraining.")
    trigger_retraining()
```

#### 39.4 Model Versioning

```python
import mlflow

## Log model
mlflow.set_experiment("my-experiment")

with mlflow.start_run():
    ## Train model
    model = train_model(data)
    
    ## Log metrics
    mlflow.log_metric("accuracy", 0.95)
    mlflow.log_metric("precision", 0.92)
    
    ## Log model
    mlflow.sklearn.log_model(model, "model")
    
    ## Log parameters
    mlflow.log_params({"learning_rate": 0.01, "epochs": 100})

## Load model
model = mlflow.sklearn.load_model("runs:/abc123/model")
```

---

### Checklist: Production Readiness

- [ ] PRR checklist completed
- [ ] All security checks passed
- [ ] Performance benchmarks met
- [ ] Monitoring and alerting setup
- [ ] Runbooks written
- [ ] Team trained
- [ ] Incident response plan
- [ ] SLO/SLA defined
- [ ] Backup and DR tested
- [ ] Documentation complete

---

### ChÆ°Æ¡ng 40: Implementation Roadmap

#### 40.1 Phase 1: Foundation (Weeks 1-4)
- Setup version control
- Setup CI/CD pipeline
- Implement basic monitoring
- Write unit tests
- Setup logging

#### 40.2 Phase 2: Reliability (Weeks 5-8)
- Implement retry logic
- Setup circuit breakers
- Implement health checks
- Setup alerting
- Write integration tests

#### 40.3 Phase 3: Security (Weeks 9-12)
- Implement authentication
- Setup secrets management
- Enable encryption
- Security scanning
- Penetration testing

#### 40.4 Phase 4: Optimization (Weeks 13-16)
- Performance testing
- Database optimization
- Caching strategy
- Cost optimization
- Load testing

#### 40.5 Phase 5: MLOps (Weeks 17-20)
- Setup experiment tracking
- Model registry
- Model monitoring
- Automated retraining
- A/B testing

---

### Final Checklist: Production Quality

- [ ] All 40 chapters reviewed
- [ ] Architecture decisions documented
- [ ] Team trained on all aspects
- [ ] Monitoring and alerting setup
- [ ] Incident response plan
- [ ] Disaster recovery tested
- [ ] Security audit passed
- [ ] Performance benchmarks met
- [ ] Cost optimization done
- [ ] Ready for production deployment

---

