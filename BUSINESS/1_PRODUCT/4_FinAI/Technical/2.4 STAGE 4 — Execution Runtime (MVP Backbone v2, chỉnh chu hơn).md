# STAGE 4 — Execution Runtime (MVP Backbone v2, chỉnh chu hơn)

## 1. Explain pipeline – Tổng quan Stage 4

> TL;DR: Stage 4 **không lên kế hoạch** nữa, mà chỉ là “máy chạy checklist”:
> nhận `PlanBundle` từ Stage 3 → chạy từng step theo mode A/B/C/D → canh budget
> + rate limit + retry → hỏi user khi step nguy hiểm → gom evidence → trả `RunBundle`.

### 1.1. Stage 4 nhận gì và trả gì?

**Đầu vào chính:**

- `PlanBundleV1`  
  - `plan_mode` (A/B/C/D), `execution_plan.steps[]`, `gates`, `budget`, `plan_id`, `trace_id`
- `RuntimeCtxV1`
  - adapters (tool/backend), permissions, rate_limits, `resume_checkpoint_ref?`, `confirmed_gates?`
- `ExecModeV1`
  - `RESEARCH_ONLY | ACTION_ONLY | HYBRID | CLARIFY_OR_FALLBACK`
  - thường được derive từ `plan_mode` nếu caller không override

**Đầu ra:**

- `RunBundleV1`
  - `run_status` = `SUCCESS | PARTIAL | NEEDS_CONFIRMATION | NEEDS_CLARIFICATION | FAILED`
  - final answer, actions_taken, evidence_count, final_url?, checkpoint_ref? (nếu pause để chờ confirm)

### 1.2. Bảng tóm tắt module → vai trò

| Module / Cụm | Vai trò chính | Xuất hiện ở bước pipeline |
|--------------|----------------|----------------------------|
| `run_stage4` + `S4RunConductor` | Khởi động Stage 4, dựng toàn bộ module, điều khiển vòng lặp chính | Bước 0, và bao quanh Bước 1–7 |
| `S4BudgetEnforcer` | Canh “ngân sách” runtime (thời gian, số tool calls, token…), có quyền cắt run khi vượt ngưỡng | Bước 1 (đầu mỗi vòng lặp) |
| `S4StepScheduler` | Chọn step READY (deps xong) và hợp với `exec_mode` (A/B/C/D) | Bước 2 |
| `S4Gatekeeper` | Quyết định ALLOW / DENY / NEED_CONFIRM cho từng step, dựa trên loại step (research/action), safe_mode, confirmed_gates | Bước 3 |
| `S4HumanConfirmBroker` | Tạo payload yêu cầu xác nhận từ người dùng (NEEDS_CONFIRMATION) | Bước 3 (nhánh NEED_CONFIRM) |
| `S4CheckpointStore` | Lưu / load trạng thái giữa các lần run (pause/resume) | Bước 3 (save) + khi entrypoint load checkpoint |
| `S4RunnerRegistry` | Map `step_type → tool_key` để biết “step này dùng tool nào” | Bước 4 |
| `S4StepDispatcher` | Nhận step + runtime, dùng Registry để gọi `ToolCallEngine` chạy tool tương ứng | Bước 4–5 |
| `S4ToolCallEngine` | Gọi tool thực, bọc bởi RateLimit + Retry, chuẩn hoá `StepRun` | Bước 5 |
| `S4RateLimitShield` | Kiểm soát tốc độ gọi tool, tránh vượt rate limit | Bước 5 (mỗi tool call) |
| `S4RetryBackoffManager` | Retry/backoff khi tool lỗi tạm thời (network/timeouts…) | Bước 5 (mỗi tool call cần retry) |
| `S4EvidenceLedger` | Gom evidence từ các step, đếm `evidence_count`, phục vụ assemble answer | Bước 6 (sau mỗi step) |
| `S4AnswerAssembler` | Ráp câu trả lời cuối từ actions + evidence | Bước 7 |
| `S4OutputFormatter` | Đóng gói `RunBundle` với `run_status` đúng: SUCCESS / PARTIAL / NEEDS_CONFIRMATION / NEEDS_CLARIFICATION / ABORT_BUDGET / BLOCKED | Bước 1–2–3–7 (tuỳ nhánh) |

---

### 1.3. Bảng mode thực thi A/B/C/D

| `ExecModeV1` | Ý nghĩa | Cho phép step nào chạy? | Use case điển hình |
|--------------|--------|-------------------------|--------------------|
| `RESEARCH_ONLY` (A) | Chỉ thu thập/thẩm định thông tin, **không làm hành động** | Chỉ các step thuộc nhóm RESEARCH (vd: `WEB_SEARCH`, `OPEN_URL`, `EXTRACT_DOM`, `READ_PDF`, `SUMMARIZE`, `COMPARE_SOURCES`, `COMPUTE`…) | User chỉ muốn “điều tra / phân tích” chứ không muốn hệ thống click/submit hộ |
| `ACTION_ONLY` (B) | Chỉ thực thi hành động, giả định phần research đã xong | Chỉ các step thuộc nhóm ACTION (vd: `FORM_FILL`, `CLICK_NAV`, `DOWNLOAD_FILE`, `WRITE_ARTIFACT`…) | Run lại 1 plan đã được kiểm chứng, chỉ cần replay action |
| `HYBRID` (C) | Vừa research vừa action, nhưng **action chỉ được chạy sau khi research đủ** | Cho phép cả RESEARCH và ACTION, nhưng Scheduler đảm bảo thứ tự hợp lý (vd: phải search + summarize xong rồi mới `FORM_FILL`) | Kịch bản “tìm hiểu → rồi làm giúp tôi, nhưng đi đúng trình tự” |
| `CLARIFY_OR_FALLBACK` (D) | Ưu tiên step hỏi lại / fallback khi có lỗi/mơ hồ | Chủ yếu chạy các step clarify/fallback (tuỳ Stage 3 define), 1 step fail có thể dừng sớm & yêu cầu clarifying | Khi Stage 3 nghi ngờ plan/risk cao, muốn Stage 4 “hỏi lại người dùng” thay vì cố gắng chạy hết |

---

### 1.4. Các kiểu kết thúc (RunBundle.run_status)

| `run_status` | Khi nào xảy ra? | Ý nghĩa / Dev nên hiểu thế nào |
|--------------|----------------|---------------------------------|
| `SUCCESS` | Tất cả step trong plan đã chạy xong (hoặc đủ điều kiện dừng), không vướng gate/budget/deadlock | Run trọn vẹn, có `final_answer`, `actions_taken`, `evidence_count`, có thể có `final_url` |
| `PARTIAL` | Không chạy hết plan vì deadlock / deps fail / lỗi tool, nhưng vẫn có một phần kết quả | Không phải bug, mà là “thành công một phần”; dùng khi Scheduler không còn step READY nhưng vẫn còn pending hoặc step fail quan trọng |
| `NEEDS_CONFIRMATION` | Gatekeeper trả `NEED_CONFIRM` cho 1 step ACTION trong safe_mode, checkpoint đã được save | Stage 4 **pause có chủ đích**, chờ user confirm; dev không được coi đây là lỗi, mà là luồng bình thường với action nhạy cảm |
| `NEEDS_CLARIFICATION` | Mode D (CLARIFY_OR_FALLBACK) gặp lỗi / thiếu input và policy yêu cầu hỏi lại user | Stage 4 dừng sớm và yêu cầu user cung cấp thêm thông tin để tiếp tục; thường đi kèm câu hỏi cụ thể trong answer |
| `ABORT_BUDGET` / `EXCEEDED_BUDGET` | `BudgetEnforcer` phát hiện vượt time/call/token limit | Run bị cắt theo thiết kế để bảo vệ hệ thống; dev có thể tăng budget hoặc tối ưu plan/tool nếu thấy run thường xuyên bị cắt |
| `BLOCKED` | Gatekeeper quyết định DENY (policy, permissions, rủi ro quá cao) | Stage 4 **cố tình không chạy** các step nguy hiểm; cần xem lại policy hoặc behavior của Stage 3 nếu bị BLOCKED quá nhiều |

---




> Mục tiêu: **xương sống runtime** chạy được, ít tranh cãi, enforce mode đúng, có confirm/resume, budget/rate/retry tối thiểu.  
> Stage 4 **không chọn mode**; Stage 3 đã chọn và đóng gói vào `PlanBundleV1.plan_mode`. Stage 4 nhận `exec_mode` (caller override) hoặc derive từ `plan_mode`.

---

## 1) Diagram 1 — Pipeline Stage 4 (ASCII)

```text
Inputs
  - PlanBundleV1(plan_status, plan_mode, execution_plan, gates, budget, capability, trace_id, plan_id)
  - RuntimeCtxV1(tab_handle, adapters, permissions, rate_limits, resume_checkpoint_ref?, confirmed_gates?)
  - ExecModeV1: A=RESEARCH_ONLY | B=ACTION_ONLY | C=HYBRID | D=CLARIFY_OR_FALLBACK
      |
      v
+-------------------+   +-------------------+   +-------------------+
| S4BudgetEnforcer   |   | S4RateLimitShield |   | S4RetryBackoffMgr |
| (per loop/call)    |   | (per tool call)   |   | (per tool call)   |
+---------+---------+   +---------+---------+   +---------+---------+
          |                       |                       |
          v                       v                       v
+-------------------+   +-------------------+   +-------------------+
| S4Gatekeeper       |-->| S4HumanConfirm    |-->| S4CheckpointStore |
| (pre-step)         |   | (pending+resume)  |   | (save/load)       |
+---------+---------+   +---------+---------+   +---------+---------+
          |                       |                       |
          v                       v                       v
+-------------------------------------------------------------------+
| S4RunConductor                                                    |
|  - S4StepScheduler (mode guard + deps)                             |
|  - S4StepDispatcher -> S4RunnerRegistry                            |
|  - S4ToolCallEngine (tool calls thật)                              |
|  - S4EvidenceLedger (evidence_count)                               |
|  - S4AnswerAssembler -> S4OutputFormatter                          |
+-------------------------------------------------------------------+
      |                         |                         |
      v                         v                         v
 Mode A: research chain     Mode B: action chain      Mode C: research -> action
 WEB_SEARCH/...             OPEN_URL/FORM_FILL/...    (A steps) then (B steps)
      |
      v
 Mode D: clarify/fallback -> PendingUserInput + CheckpointRef (resume)
```

---

## 2) Diagram 2 — Runtime state machine (ASCII)

```text
Step lifecycle
  PENDING -> RUNNING -> SUCCESS
                    -> FAILED -> (retryable?) -> RUNNING
                    -> FAILED -> (non-retryable) -> stop/partial
                    -> BLOCKED_GATE -> NEEDS_CONFIRMATION
                                      |
                                      v
                                   RESUME -> RUNNING
```

---

## 3) Backbone overview (Stage 4 làm gì / không làm gì)

- Stage 4 **execute thật**: chạy `execution_plan.steps[]` bằng tool calls (browser/search/pdf/llm/compute/artifact).
- Stage 4 **enforce mode** bằng: (1) Scheduler “mode guard” (2) Gatekeeper “confirm token”.
- Stage 4 **có checkpoint/resume**: gặp NEED_CONFIRM → save checkpoint → trả pending → resume chạy tiếp.
- Stage 4 **không** tự ý destructive actions khi `safe_mode=True` (mặc định).
- Stage 4 **không** “replan lớn”; chỉ fallback nhẹ: retry/skip/ask user.

---

## 4) 4 Mode spec (A/B/C/D) — mỗi mode đúng 6 mục

### A — RESEARCH_ONLY
- mục tiêu: bằng chứng + trả lời.
- allowed step types: WEB_SEARCH, OPEN_URL, EXTRACT_DOM, READ_PDF, SUMMARIZE, COMPARE_SOURCES, COMPUTE.
- gating rule: cấm action types (FORM_FILL/CLICK_NAV/DOWNLOAD_FILE/WRITE_ARTIFACT).
- budget rule: stop sớm khi đủ evidence_count; limit tool calls.
- failure handling: retry search 1 lần; nếu fail → PARTIAL.
- output run_status: SUCCESS | PARTIAL.

### B — ACTION_ONLY
- mục tiêu: thao tác UI theo plan.
- allowed step types: OPEN_URL, EXTRACT_DOM, FORM_FILL, CLICK_NAV, DOWNLOAD_FILE, WRITE_ARTIFACT, COMPUTE.
- gating rule: action step cần `confirmed_gates["gate_action"]=True` mới chạy.
- budget rule: ưu tiên nhanh; hết budget → ABORTED_BUDGET.
- failure handling: retry click/fill 1 lần; fail → FAILED + checkpoint.
- output run_status: SUCCESS | NEEDS_CONFIRMATION | FAILED | ABORTED_BUDGET.

### C — HYBRID (research → action)
- mục tiêu: research xong mới action.
- allowed step types: toàn bộ.
- gating rule: trước action step đầu tiên luôn NEED_CONFIRM (khi safe_mode=True).
- budget rule: nếu còn research pending thì cấm action; hết budget → PARTIAL hoặc CLARIFY.
- failure handling: research fail → PARTIAL; action bị gate → NEEDS_CONFIRMATION.
- output run_status: SUCCESS | PARTIAL | NEEDS_CONFIRMATION.

### D — CLARIFY_OR_FALLBACK
- mục tiêu: hỏi user / fallback an toàn khi bị chặn/thiếu info.
- allowed step types: tối thiểu OPEN_URL/EXTRACT_DOM và 1 WEB_SEARCH (nếu còn budget).
- gating rule: login/payment/submit → NEED_CONFIRM hoặc BLOCKED_POLICY.
- budget rule: nhỏ; ưu tiên tạo câu hỏi hơn chạy tool nhiều.
- failure handling: rate-limit/timeout → NEEDS_CLARIFICATION + checkpoint.
- output run_status: NEEDS_CLARIFICATION | NEEDS_CONFIRMATION | BLOCKED_POLICY.

---

## 5) Module list (xương sống) — đúng 14 module, mỗi module 3 dòng

- S4RunConductor — Goal: loop steps | I/O: plan+runtime→run | Failure: deadlock→PARTIAL  
- S4StepScheduler — Goal: pick READY step | I/O: steps+completed+mode→step? | Failure: none→deadlock  
- S4StepDispatcher — Goal: dispatch step→runner | I/O: step→StepRun | Failure: unknown type→FAILED  
- S4RunnerRegistry — Goal: map type→tool_key | I/O: type→key | Failure: missing→FAILED  
- S4ToolCallEngine — Goal: call tool thật | I/O: tool_key+args→output | Failure: timeout→retry  
- S4RetryBackoffManager — Goal: retry policy | I/O: err→retry? | Failure: exceeded→FAILED  
- S4RateLimitShield — Goal: throttle | I/O: tool_key→allow/wait | Failure: hard limit→CLARIFY  
- S4Gatekeeper — Goal: ALLOW/DENY/NEED_CONFIRM | I/O: step+confirmed→decision | Failure: deny→BLOCKED  
- S4HumanConfirmBroker — Goal: pending confirm msg | I/O: decision+chk→pending | Failure: user decline→BLOCKED  
- S4BudgetEnforcer — Goal: enforce budget | I/O: ticks→ok/abort | Failure: exceeded→ABORTED  
- S4CheckpointStore — Goal: save/load | I/O: state↔ref | Failure: store down→no-resume  
- S4EvidenceLedger — Goal: evidence_count | I/O: step_outputs→ledger | Failure: bad evidence→warn  
- S4AnswerAssembler — Goal: final answer | I/O: evidence+actions→text | Failure: no evidence→PARTIAL  
- S4OutputFormatter — Goal: RunBundle | I/O: state→bundle | Failure: format err→FAILED

---

## 6) Folder structure Stage 4 (bắt buộc, kèm file mapping tối thiểu)

```text
backend/stages/stage4/
  stage4_entrypoint.py              # run_stage4
  contracts/                        # ExecModeV1/RunBundleV1/... minimal + errors
  core/                             # conductor/scheduler/dispatcher/registry/gate/budget/output
  runners/                          # (optional) runner wrappers nếu tách tool args
  tooling/                          # tool engine + retry + rate limit
  stores/                           # checkpoint store
  observability/                    # log envelope (trace/run/step/tool ids)
  fixtures/                         # golden output JSON
  tests/                            # offline tests with fake adapters
  README.md                         # cách chạy/resume/test
```

**File mapping (pin):**
- `core/stage4_conductor.py` → `S4RunConductor`
- `core/stage4_scheduler.py` → `S4StepScheduler`
- `core/stage4_dispatcher.py` → `S4StepDispatcher`
- `core/stage4_registry.py` → `S4RunnerRegistry`
- `core/stage4_gatekeeper.py` → `S4Gatekeeper` + `S4HumanConfirmBroker`
- `core/stage4_budget.py` → `S4BudgetEnforcer`
- `tooling/stage4_tool_engine.py` → `S4ToolCallEngine` + `S4RetryBackoffManager` + `S4RateLimitShield`
- `stores/stage4_checkpoint_store.py` → `S4CheckpointStore`
- `core/stage4_evidence.py` → `S4EvidenceLedger`
- `core/stage4_answer.py` → `S4AnswerAssembler`
- `core/stage4_output.py` → `S4OutputFormatter`

---

## 7) Contracts minimal (pydantic pseudo-code) — thêm resume/confirm + receipt tối thiểu

```python
from typing import Any, Dict, List, Literal, Optional
from pydantic import BaseModel

ExecModeV1 = Literal["RESEARCH_ONLY","ACTION_ONLY","HYBRID","CLARIFY_OR_FALLBACK"]

class RuntimeCtxV1(BaseModel):
    schema_version: str = "RuntimeCtxV1@1"
    tab_handle: str
    safe_mode: bool = True
    permissions: List[str] = []
    rate_profile: Literal["low","med","high"] = "med"
    resume_checkpoint_ref: Optional[str] = None
    confirmed_gates: Dict[str, bool] = {}   # e.g., {"gate_action": True}

class ToolCallV1(BaseModel):
    schema_version: str = "ToolCallV1@1"
    tool_name: str
    args: Dict[str, Any] = {}
    timeout_s: int = 30

class GateDecisionV1(BaseModel):
    schema_version: str = "GateDecisionV1@1"
    gate_id: str
    decision: Literal["ALLOW","DENY","NEED_CONFIRM"]

class BudgetStateV1(BaseModel):
    schema_version: str = "BudgetStateV1@1"
    tool_calls_used: int = 0
    time_ms_used: int = 0
    token_est_used: int = 0

class StepRunV1(BaseModel):
    schema_version: str = "StepRunV1@1"
    step_id: str
    step_type: str
    status: Literal["PENDING","RUNNING","SUCCESS","FAILED","BLOCKED_GATE"]
    tool_calls: List[ToolCallV1] = []
    outputs: Dict[str, Any] = {}
    error: Optional[str] = None

class RunBundleV1(BaseModel):
    schema_version: str = "RunBundleV1@1"
    trace_id: str; run_id: str; plan_id: str
    exec_mode: ExecModeV1
    run_status: Literal["SUCCESS","PARTIAL","NEEDS_CONFIRMATION","NEEDS_CLARIFICATION","FAILED","ABORTED_BUDGET","BLOCKED_POLICY"]
    evidence_count: int = 0
    actions_taken: List[str] = []
    receipt: Optional[Dict[str, Any]] = None           # MVP: {actions, final_url?}
    final_answer: Optional[str] = None
    pending_user_input: Optional[Dict[str, Any]] = None
    checkpoint_ref: Optional[str] = None
```

---

## 8) Skeleton code (Python ngắn, implementable)

### 8.1 `run_stage4(...)` (<= 40 lines) — chốt logic mode + confirm/resume + deadlock

```python
# backend/stages/stage4/stage4_entrypoint.py
from uuid import uuid4
from time import time

def _derive_exec_mode(plan_mode: str) -> str:
    return {"RESEARCH":"RESEARCH_ONLY","ACTION":"ACTION_ONLY","HYBRID":"HYBRID","CLARIFY":"CLARIFY_OR_FALLBACK"}.get(plan_mode,"CLARIFY_OR_FALLBACK")

def run_stage4(plan_bundle, runtime, exec_mode=None):
    exec_mode = exec_mode or _derive_exec_mode(plan_bundle.plan_mode)  # caller override > plan_mode
    run_id = f"run_{uuid4().hex[:8]}"; t0 = time()
    bud = S4BudgetEnforcer(plan_bundle.budget); gate = S4Gatekeeper(plan_bundle.gates, runtime.safe_mode)
    chk = S4CheckpointStore(); conf = S4HumanConfirmBroker(); evl = S4EvidenceLedger()
    dsp = S4StepDispatcher(S4RunnerRegistry(), S4ToolCallEngine(), S4RateLimitShield(runtime.rate_profile), S4RetryBackoffManager())
    sch = S4StepScheduler(); asm = S4AnswerAssembler(); fmt = S4OutputFormatter()

    if plan_bundle.plan_status != "READY" or not plan_bundle.execution_plan: return fmt.clarify(plan_bundle, run_id, exec_mode, "plan_not_ready")
    completed = set()
    if runtime.resume_checkpoint_ref: completed |= set(chk.load(runtime.resume_checkpoint_ref).get("completed", []))

    steps = plan_bundle.execution_plan.steps; actions = []; last_url = None
    while True:
        bud.tick(int((time()-t0)*1000), dsp.calls_used, dsp.tokens_used)
        if bud.exceeded(): return fmt.abort_budget(plan_bundle, run_id, exec_mode, actions, evl.count())
        step = sch.pick_ready(steps, completed, exec_mode)
        if not step:
            pending = [s for s in steps if s["step_id"] not in completed]
            if pending: return fmt.partial(plan_bundle, run_id, exec_mode, "deadlock_or_failed_dep", actions, evl.count())
            break
        gd = gate.decide(step, runtime.confirmed_gates)
        if gd["decision"] == "DENY": return fmt.blocked(plan_bundle, run_id, exec_mode, gd, actions, evl.count())
        if gd["decision"] == "NEED_CONFIRM":
            ref = chk.save(run_id, plan_bundle.plan_id, list(completed), evl.count())
            return fmt.needs_confirm(plan_bundle, run_id, exec_mode, conf.pending(gd, ref), ref, actions, evl.count())
        sr = dsp.run_step(step, runtime); evl.ingest(sr); actions += sr.get("actions", [])
        last_url = sr.get("outputs", {}).get("final_url", last_url)
        if sr["status"] == "SUCCESS": completed.add(step["step_id"])
        elif exec_mode == "CLARIFY_OR_FALLBACK": return fmt.clarify(plan_bundle, run_id, exec_mode, sr.get("error","step_failed"))

    answer = asm.assemble(actions, evl.items); return fmt.success(plan_bundle, run_id, exec_mode, answer, actions, evl.count(), last_url)
```

### 8.2 Core modules (mỗi module 6–12 dòng)

```python
class S4StepScheduler:
    RESEARCH = {"WEB_SEARCH","OPEN_URL","EXTRACT_DOM","READ_PDF","SUMMARIZE","COMPARE_SOURCES","COMPUTE"}
    ACTION   = {"FORM_FILL","CLICK_NAV","DOWNLOAD_FILE","WRITE_ARTIFACT"}
    def pick_ready(self, steps, completed, exec_mode):
        pending_research = any(s["step_type"] in self.RESEARCH and s["step_id"] not in completed for s in steps)
        for s in steps:
            if s["step_id"] in completed: continue
            if any(d not in completed for d in s.get("depends_on", [])): continue
            t = s["step_type"]
            if exec_mode=="RESEARCH_ONLY" and t in self.ACTION: continue
            if exec_mode=="ACTION_ONLY" and t in {"WEB_SEARCH","READ_PDF","SUMMARIZE","COMPARE_SOURCES"}: continue
            if exec_mode=="HYBRID" and t in self.ACTION and pending_research: continue
            return s
        return None

class S4RunnerRegistry:
    def __init__(self):
        self.map = {"WEB_SEARCH":"web_search","OPEN_URL":"open_url","EXTRACT_DOM":"extract_dom","READ_PDF":"read_pdf",
                    "SUMMARIZE":"summarize","COMPARE_SOURCES":"compare","COMPUTE":"compute","FORM_FILL":"form_fill",
                    "CLICK_NAV":"click","DOWNLOAD_FILE":"download","WRITE_ARTIFACT":"write"}
    def get(self, step_type): return self.map.get(step_type)

class S4StepDispatcher:
    def __init__(self, reg, tool, rate, retry):
        self.reg, self.tool, self.rate, self.retry = reg, tool, rate, retry
        self.calls_used = 0; self.tokens_used = 0
    def run_step(self, step, runtime):
        key = self.reg.get(step["step_type"])
        if not key: return {"status":"FAILED","error":"unknown_step_type"}
        return self.tool.call(key, step.get("inputs", {}), runtime, self.rate, self.retry, self)

class S4ToolCallEngine:
    def call(self, tool_key, args, runtime, rate, retry, disp):
        try:
            rate.allow_or_wait(tool_key); disp.calls_used += 1
            return {"status":"SUCCESS","outputs":{"tool":tool_key,"args":args},"actions":[tool_key]}
        except Exception as e:
            return retry.handle(str(e), tool_key, args)

class S4RateLimitShield:
    def __init__(self, profile="med"): self.profile = profile
    def allow_or_wait(self, tool_key): return True

class S4RetryBackoffManager:
    def handle(self, err, tool_key, args): return {"status":"FAILED","error":f"{tool_key}:{err}"}

class S4Gatekeeper:
    ACTION = {"FORM_FILL","CLICK_NAV","DOWNLOAD_FILE","WRITE_ARTIFACT"}
    def __init__(self, gates, safe_mode=True): self.gates, self.safe = gates, safe_mode
    def decide(self, step, confirmed_gates=None):
        confirmed_gates = confirmed_gates or {}
        if step["step_type"] in self.ACTION and self.safe and not confirmed_gates.get("gate_action"):
            return {"gate_id":"gate_action","decision":"NEED_CONFIRM","reason":"action_requires_confirm"}
        return {"gate_id":"gate_default","decision":"ALLOW","reason":"ok"}

class S4HumanConfirmBroker:
    def pending(self, gd, checkpoint_ref):
        return {"kind":"CONFIRMATION","message":gd["reason"],"gate_id":gd["gate_id"],"checkpoint_ref":checkpoint_ref}

class S4BudgetEnforcer:
    def __init__(self, spec): self.spec = spec; self.used_ms=0; self.used_calls=0; self.used_tok=0
    def tick(self, used_ms, used_calls, used_tok): self.used_ms, self.used_calls, self.used_tok = used_ms, used_calls, used_tok
    def exceeded(self):
        return self.used_calls > self.spec.get("max_tool_calls", 20) or self.used_ms > self.spec.get("max_time_ms", 60000)

class S4CheckpointStore:
    def save(self, run_id, plan_id, completed, evidence_count): return f"chk://{run_id}/{len(completed)}_{evidence_count}"
    def load(self, ref): return {"completed": []}

class S4EvidenceLedger:
    def __init__(self): self.items=[]
    def ingest(self, step_run): self.items += step_run.get("outputs", {}).get("evidence", [])
    def count(self): return len(self.items)

class S4AnswerAssembler:
    def assemble(self, actions, evidence_items): return f"Đã chạy {len(actions)} bước; evidence={len(evidence_items)}."

class S4OutputFormatter:
    def success(self, pb, run_id, mode, ans, acts, evc, last_url=None):
        return {"trace_id":pb.trace_id,"run_id":run_id,"plan_id":pb.plan_id,"exec_mode":mode,"run_status":"SUCCESS",
                "final_answer":ans,"actions_taken":acts,"evidence_count":evc,"receipt":{"actions":acts,"final_url":last_url}}
    def needs_confirm(self, pb, run_id, mode, pending, ref, acts, evc):
        return {"trace_id":pb.trace_id,"run_id":run_id,"plan_id":pb.plan_id,"exec_mode":mode,"run_status":"NEEDS_CONFIRMATION",
                "pending_user_input":pending,"checkpoint_ref":ref,"actions_taken":acts,"evidence_count":evc}
    def clarify(self, pb, run_id, mode, msg):
        return {"trace_id":pb.trace_id,"run_id":run_id,"plan_id":pb.plan_id,"exec_mode":mode,"run_status":"NEEDS_CLARIFICATION",
                "pending_user_input":{"kind":"CLARIFICATION","message":msg},"actions_taken":[],"evidence_count":0}
    def abort_budget(self, pb, run_id, mode, acts, evc):
        return {"trace_id":pb.trace_id,"run_id":run_id,"plan_id":pb.plan_id,"exec_mode":mode,"run_status":"ABORTED_BUDGET",
                "actions_taken":acts,"evidence_count":evc}
    def blocked(self, pb, run_id, mode, gd, acts, evc):
        return {"trace_id":pb.trace_id,"run_id":run_id,"plan_id":pb.plan_id,"exec_mode":mode,"run_status":"BLOCKED_POLICY",
                "pending_user_input":{"gate":gd},"actions_taken":acts,"evidence_count":evc}
    def partial(self, pb, run_id, mode, err, acts, evc):
        return {"trace_id":pb.trace_id,"run_id":run_id,"plan_id":pb.plan_id,"exec_mode":mode,"run_status":"PARTIAL",
                "pending_user_input":{"kind":"CLARIFICATION","message":err},"actions_taken":acts,"evidence_count":evc}
```

---

## 9) Mapping step_type → runner (8–12 dòng)

| step_type | runner key | mode |
|---|---|---|
| WEB_SEARCH | web_search | A/C/D |
| OPEN_URL | open_url | A/B/C/D |
| EXTRACT_DOM | extract_dom | A/B/C/D |
| READ_PDF | read_pdf | A/C |
| SUMMARIZE | summarize | A/C |
| COMPARE_SOURCES | compare | A/C |
| COMPUTE | compute | A/B/C |
| FORM_FILL | form_fill | B/C |
| CLICK_NAV | click | B/C |
| DOWNLOAD_FILE | download | B/C |
| WRITE_ARTIFACT | write | B/C |

---

## 10) 4 ví dụ output JSON mini (<= 15 dòng/mode)

### A) RESEARCH_ONLY
```json
{"run_status":"SUCCESS","actions_taken":["web_search","summarize"],"evidence_count":6,"receipt":{"actions":["web_search"],"final_url":null}}
```

### B) ACTION_ONLY
```json
{"run_status":"NEEDS_CONFIRMATION","actions_taken":["open_url"],"evidence_count":0,"pending_user_input":{"kind":"CONFIRMATION","gate_id":"gate_action"},"checkpoint_ref":"chk://run_x/0_0"}
```

### C) HYBRID
```json
{"run_status":"PARTIAL","actions_taken":["web_search","compute","form_fill"],"evidence_count":4,"receipt":{"actions":["form_fill"],"final_url":"https://example/form"}}
```

### D) CLARIFY_OR_FALLBACK
```json
{"run_status":"NEEDS_CLARIFICATION","actions_taken":[],"evidence_count":0,"pending_user_input":{"kind":"CLARIFICATION","message":"need_more_info"}}
```

---

## 11) Acceptance criteria P0 (ngắn)

- Mode C: **không action khi còn research pending** (HYBRID barrier đúng).
- Action step khi `safe_mode=True`: luôn `NEEDS_CONFIRMATION` + `checkpoint_ref`.
- Resume: `confirmed_gates["gate_action"]=True` thì action step chạy tiếp (không bị chặn lại).
- Budget vượt giới hạn: `ABORTED_BUDGET` (stop ngay).
- Unknown step_type: trả FAILED/partial (không crash).
- RunBundle luôn có `trace_id/run_id/plan_id/run_status`.

### 1.5. Pipeline Stage 4 (theo từng bước + module)

Stage 4 chạy trong 1 vòng lặp do `S4RunConductor` điều khiển. Mỗi vòng:

**Bước 0 – Khởi động ca làm**

- Module: `run_stage4` (entrypoint)
- Dựng toàn bộ module: `BudgetEnforcer`, `Gatekeeper`, `CheckpointStore`,
  `EvidenceLedger`, `Scheduler`, `RunnerRegistry`, `StepDispatcher`,
  `ToolCallEngine + RateLimitShield + RetryBackoffManager`,
  `AnswerAssembler`, `OutputFormatter`.
- Nếu plan chưa READY hoặc thiếu execution_plan → trả RunBundle lỗi/clarify.

---

**Bước 1 – Kiểm tra ngân sách**

- Module: `S4BudgetEnforcer`
- Mỗi vòng gọi `bud.tick(...)`; nếu `exceeded()` → `OutputFormatter.abort_budget(...)` → dừng run.

---

**Bước 2 – Chọn step tiếp theo (theo deps + mode A/B/C/D)**

- Module: `S4StepScheduler`
- Dựa trên:
  - deps: chỉ chọn step READY (deps đã completed)
  - mode:
    - A `RESEARCH_ONLY`: chỉ cho step thuộc nhóm “research”
    - B `ACTION_ONLY`: chỉ cho step thuộc nhóm “action”
    - C `HYBRID`: ưu tiên làm research trước, action chỉ chạy khi phần research đủ
    - D `CLARIFY_OR_FALLBACK`: ưu tiên step hỏi lại / fallback
- Nếu không còn step READY:
  - còn pending chưa xong → `OutputFormatter.partial(..., "deadlock_or_failed_dep")`
  - không còn pending → ra bước assemble answer.

---

**Bước 3 – Gate & Confirm (an toàn trước khi làm ACTION)**

- Module: `S4Gatekeeper`, `S4HumanConfirmBroker`, `S4CheckpointStore`
- Nếu step là ACTION và safe_mode bật:
  - Nếu gate chưa được user confirm → `GateDecision = NEED_CONFIRM`
  - Lúc đó:
    - `CheckpointStore.save(...)` → tạo `checkpoint_ref`
    - `HumanConfirmBroker.pending(...)` → payload xin confirm
    - `OutputFormatter.needs_confirm(...)` → trả `RunBundle` với `run_status=NEEDS_CONFIRMATION`
- Nếu `GateDecision = DENY` → `OutputFormatter.blocked(...)` → dừng run.
- Nếu `GateDecision = ALLOW` → sang bước 4.

---

**Bước 4 – Dispatch step sang đúng tool**

- Module: `S4RunnerRegistry`, `S4StepDispatcher`
- `RunnerRegistry` giữ map: `step_type → tool_key` (vd: `WEB_SEARCH → web_search`,
  `FORM_FILL → form_fill`, sau này có thể thêm `FIN_PRICE_FETCH → fin_price_fetch`…)
- `StepDispatcher` dùng tool_key này gọi `S4ToolCallEngine` để thực thi.

---

**Bước 5 – Gọi tool (kèm rate limit + retry)**

- Module: `S4ToolCallEngine`, `S4RateLimitShield`, `S4RetryBackoffManager`
- ToolCallEngine:
  - check rate limit cho từng tool call
  - gọi adapter thực
  - nếu lỗi tạm thời → RetryBackoffManager quyết định retry/backoff
- Kết quả 1 step được chuẩn hóa thành `StepRunV1` (status, outputs, actions, error…).

---

**Bước 6 – Ghi nhận evidence & cập nhật tiến độ**

- Module: `S4EvidenceLedger`
- Mỗi step xong:
  - `EvidenceLedger.ingest(step_run)` → tăng `evidence_count`
  - nếu `step_run.status == SUCCESS` → thêm `step_id` vào `completed`
  - cộng dồn `actions_taken`, `last_url`, v.v…

---

**Bước 7 – Assemble final answer và trả RunBundle**

- Module: `S4AnswerAssembler`, `S4OutputFormatter`
- Khi không còn step pending:
  - `AnswerAssembler.assemble(actions, evidence)` → tạo `final_answer`
  - `OutputFormatter.success(...)` → `RunBundle` với:
    - `run_status="SUCCESS"`
    - `final_answer`
    - `actions_taken`
    - `evidence_count`
    - `final_url?`
- Các trường hợp khác:
  - hết budget → `abort_budget`
  - deadlock/thiếu deps → `partial`
  - cần confirm → `needs_confirm`
  - cần hỏi lại → `clarify`
  - bị chặn bởi policy → `blocked`

### 1.6. Ví dụ ngắn (mode HYBRID)

User: “Tìm tin xấu về công ty ABC, nếu có thì điền giúp tôi form báo cáo rủi ro (nhớ hỏi tôi trước khi gửi).”

Plan (rút gọn):

1. `WEB_SEARCH` tin ABC
2. `SUMMARIZE` kết quả
3. `FORM_FILL` form báo cáo (deps: 2)

Luồng:

1. Vòng 1–2:
   - Scheduler chọn `WEB_SEARCH` rồi `SUMMARIZE` (đều là research)  
   - Gatekeeper cho ALLOW  
   - ToolCallEngine chạy search + summarize  
   - EvidenceLedger ghi lại → 2 evidence, 2 step completed
2. Vòng 3:
   - Scheduler chọn `FORM_FILL` (action, deps ok, mode HYBRID cho phép action sau research)  
   - Gatekeeper thấy safe_mode + action, chưa được confirm → `NEEDS_CONFIRM`  
   - CheckpointStore.save(...) → tạo `checkpoint_ref`  
   - OutputFormatter.needs_confirm(...) → Stage 4 dừng, chờ user
3. Sau khi user bấm “OK, cho gửi”:
   - Caller gọi lại Stage 4 với `resume_checkpoint_ref` + `confirmed_gates["gate_action"]=true`
   - Scheduler chọn lại `FORM_FILL`
   - Gatekeeper ALLOW, Dispatcher + ToolEngine gửi form
   - EvidenceLedger ghi thêm 1 step, tất cả hoàn thành
   - AnswerAssembler + OutputFormatter.success(...) → trả answer:  
     “Đã tìm X tin xấu…, form báo cáo đã được gửi tại URL …”

> Phần còn lại của tài liệu bên dưới đi sâu vào: contracts chi tiết, data model,
> folder structure, và behaviour cụ thể của từng module.

### 1.7. Sequence diagram (dạng ASCII/markdown)

```text
+--------+----------------------+--------+--------+--------+--------+--------+--------+
| Caller |         S4           |  Bud   |  Sch   |  Gate  |  Exec  |   Ev   |  Out   |
+--------+----------------------+--------+--------+--------+--------+--------+--------+
    |              |              |        |        |        |        |        |
    | 1) User req  |              |        |        |        |        |        |
    |------------->|              |        |        |        |        |        |
    |              | 2) run_stage4(plan,runtime) init modules
    |              |------------------------------------------>        |        |
    |              |              |        |        |        |        |        |
    |              |=== VÒNG LẶP STAGE 4 (RUN LOOP) =============================|
    |              |              |        |        |        |        |        |
    |              | 3) Tick budget                                    |        |
    |              |------------->|        |        |        |        |        |
    |              |              | check time/calls/tokens            |        |
    |              |<-------------|        |        |        |        |        |
    |              |              |        |        |        |        |        |
    |              |   [Nếu exceeded()]                                |        |
    |              |   ------------------> Out.abort_budget(...)       |        |
    |              |                                |                  |        |
    |              |                                |  RunBundle(ABORT)|        |
    |              |<-------------------------------|                  |        |
    |              |-------------- RunBundle ------>|                  |        |
    |              |              |        |        |        |        |        |
    |              |   [Ngược lại: còn budget]                               |
    |              |              |        |        |        |        |        |
    |              | 4) pick_ready(steps,completed,mode)              |        |
    |              |----------------------->|        |        |        |        |
    |              |              |  chọn step READY + mode guard A/B/C/D      |
    |              |<-----------------------|        |        |        |        |
    |              |              |        |        |        |        |        |
    |              |   [Không có step READY]                                   |
    |              |   + nếu còn pending: Out.partial(deadlock/failed_dep)     |
    |              |   + nếu không còn pending: assemble + success             |
    |              |              |        |        |        |        |        |
    |              |   [Có step READY -> tiếp tục]                             |
    |              |              |        |        |        |        |        |
    |              | 5) Gatekeeper.decide(step, confirmed_gates, safe_mode)    |
    |              |------------------------------->|        |        |        |
    |              |              |   ALLOW / DENY / NEED_CONFIRM              |
    |              |<-------------------------------|        |        |        |
    |              |              |        |        |        |        |        |
    |              |   [DENY] => Out.blocked(...) -> trả RunBundle(BLOCKED)    |
    |              |   [NEED_CONFIRM] => save checkpoint + pending confirm     |
    |              |              |        |        |        |        |        |
    |              |   CASE NEED_CONFIRM:                                       |
    |              |   - Gate tạo GateDecision = NEED_CONFIRM                   |
    |              |   - Gate -> Chk.save(run_state, completed, evidence_count) |
    |              |   - Gate -> HumanConfirmBroker.pending(...)                |
    |              |   - S4 -> Out.needs_confirm(pending, checkpoint_ref)       |
    |              |   - Caller nhận RunBundle(NEEDS_CONFIRM)                   |
    |              |              |        |        |        |        |        |
    |              |   [ALLOW] -> tiếp tục thực thi step                        |
    |              |              |        |        |        |        |        |
    |              | 6) Exec.run_step(step, runtime)                            |
    |              |----------------------------------->|        |        |     |
    |              |              |        |        |        |        |        |
    |              |              | 6.1) RunnerRegistry.get(step_type)         |
    |              |              |----------------->|        |        |        |
    |              |              |  tool_key        |        |        |        |
    |              |              |<-----------------|        |        |        |
    |              |              |        |        |        |        |        |
    |              |              |   [tool_key NULL] -> StepRun(FAILED, UNKNOWN_STEP_TYPE)
    |              |              |        |        |        |        |        |
    |              |              |   [tool_key hợp lệ]                          |
    |              |              |        |        |        |        |        |
    |              |              | 6.2) ToolCallEngine.call(tool_key, inputs) |
    |              |              |----------------------->|        |        |  |
    |              |              |        |   6.2.1) RateLimitShield.check    |
    |              |              |        |-------------->|        |        |  |
    |              |              |        |      ok/throttle        |        |  |
    |              |              |        |<-------------|        |        |  |
    |              |              |        |        |        |        |        |
    |              |              |        |   [ok] 6.2.2) RetryBackoffMgr      |
    |              |              |        |-------------->|        |        |  |
    |              |              |        |   gọi tool thực, retry nếu lỗi    |
    |              |              |        |<-------------| StepRun(...)       |
    |              |              |<-----------------------|        |        |  |
    |              |<--------------------------------------|        |        |  |
    |              |              |        |        |        |        |        |
    |              | 7) EvidenceLedger.ingest(StepRun)                |        |
    |              |------------------------------------------------------->|  |
    |              |              |        |        |        |        |        |
    |              |   - tăng evidence_count                               |
    |              |   - update completed nếu StepRun.SUCCESS              |
    |              |<-------------------------------------------------------|  |
    |              |              |        |        |        |        |        |
    |              |   [Quay lại đầu vòng lặp: tick budget, pick step mới...] |
    |              |              |        |        |        |        |        |
    |              |=== KHI KHÔNG CÒN STEP PENDING ==========================|
    |              |              |        |        |        |        |        |
    |              | 8) assemble(actions, evidence)                          |
    |              |------------------------------------------------->|      |
    |              |              |        |        |        |        |        |
    |              |<-------------------------------------------------|      |
    |              | 9) Out.success(final_answer, actions, evidence_count...) |
    |              |-------------------------------------------------------->|
    |              |                                                        |
    |<-------------|              RunBundle(SUCCESS)                        |
    |              |                                                        |
+--------+----------------------+--------+--------+--------+--------+--------+--------+
```

