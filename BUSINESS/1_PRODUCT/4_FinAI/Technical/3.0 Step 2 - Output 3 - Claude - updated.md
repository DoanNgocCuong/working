# FinAI Browser Agent SDD - Update Guide

## Tổng quan

Document này mô tả các thay đổi cần thiết để SDD "finAI Finance Agent Web Browser" mapping chính xác với codebase hiện có của project FinAI.

---

## 1. Cấu trúc thư mục (File Structure)

### ❌ SDD hiện tại
```
app/module/finai_agent/
├── agent.py
├── models.py
└── ...
```

### ✅ Cần update thành
```
app/module/agent/finai_browser_agent/
├── agent.py                    # REQUIRED - Entry point với @agent decorator
├── __init__.py
├── models.py                   # Input/State models extending BaseState
├── message_bus/
│   ├── __init__.py
│   ├── bus.py                  # MessageBus tích hợp với Redis PubSub
│   └── models.py
├── layer_0_governance/
│   ├── __init__.py
│   ├── input_gate.py
│   ├── in_flight_guards.py
│   └── output_gate.py
├── layer_1_perception/
│   ├── __init__.py
│   ├── input_processor.py
│   ├── context_builder.py
│   └── dom_snapshotter.py
├── layer_2_cognition/
│   ├── __init__.py
│   ├── graph.py                # LangGraph StateGraph definition
│   ├── nodes/
│   │   ├── __init__.py
│   │   ├── perceive_node.py
│   │   ├── planner_node.py
│   │   ├── executor_node.py
│   │   ├── verifier_node.py
│   │   └── synthesize_node.py
│   ├── memory/
│   │   ├── __init__.py
│   │   ├── short_term.py       # Redis-based
│   │   └── long_term.py        # Pinecone RAG
│   └── llm/
│       ├── __init__.py
│       ├── router.py
│       └── providers.py
├── layer_3_action/
│   ├── __init__.py
│   ├── browser/
│   │   ├── __init__.py
│   │   ├── controller.py       # Playwright
│   │   └── pool.py
│   └── tools/
│       ├── __init__.py
│       ├── navigation.py
│       ├── extraction.py
│       └── financial_tools.py
└── tests/
    ├── __init__.py
    ├── unit/
    ├── integration/
    └── e2e/
```

### Lý do
- AgentFactory auto-discover từ package `app.module.agent`
- File `agent.py` là **REQUIRED** để factory nhận diện agent
- Đặt tại `app/module/agent/finai_browser_agent/` thay vì `app/module/finai_agent/`

---

## 2. Base Agent Pattern

### ❌ SDD hiện tại
```python
from abc import ABC, abstractmethod

class P2PAgent(ABC):
    """Custom base class"""
    
    @abstractmethod
    def process(self, state: AgentState) -> AgentState:
        pass
```

### ✅ Cần update thành
```python
from app.common.agent.base import BaseAgent
from app.common.agent.decorators import agent
from app.common.agent.models import BaseState
from typing import Generic, TypeVar

T = TypeVar("T", bound=BaseState)

class P2PMixin:
    """
    Mixin cung cấp P2P communication capabilities.
    Sử dụng kết hợp với BaseAgent.
    """
    
    async def broadcast_to_peers(self, message: dict):
        """Broadcast message to all peer agents"""
        if hasattr(self, 'message_bus'):
            await self.message_bus.publish(message)
    
    async def request_peer(self, peer_id: str, request: dict):
        """Send request to specific peer"""
        if hasattr(self, 'message_bus'):
            return await self.message_bus.request(peer_id, request)


@agent(
    agent_id="finai_browser",
    name="FinAI Finance Browser Agent",
    description="4-layer agent for financial research automation",
    input_model=BrowserInput,
    state_model=BrowserState,
    input_to_state=convert_input_to_state,
    kafka_topic="finai_browser_events",
    dependency_specs={
        "kafka": "kafka_producer",
        "redis": "redis_client",
        "db": "database_manager"
    }
)
class FinAIBrowserAgent(P2PMixin, BaseAgent[BrowserState]):
    """
    Main browser agent inheriting from BaseAgent.
    P2PMixin provides peer-to-peer communication.
    """
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.graph = create_browser_graph()
```

### Lý do
- BaseAgent đã có sẵn: LangGraph integration, Kafka, LangFuse tracing, error handling
- Tạo Mixin để thêm P2P capabilities thay vì replace hoàn toàn
- Kế thừa `BaseAgent[T]` với Generic state type

---

## 3. Agent Registration (Decorator Pattern)

### ❌ SDD hiện tại
Không có cơ chế registration

### ✅ Cần thêm
```python
# app/module/agent/finai_browser_agent/agent.py

from app.common.agent.decorators import agent
from app.common.agent.base import BaseAgent
from .models import BrowserInput, BrowserState
from .layer_2_cognition.graph import create_browser_graph

def convert_input_to_state(input_data: BrowserInput) -> BrowserState:
    """Convert API input to internal state"""
    return BrowserState(
        goal=input_data.goal,
        context=input_data.context or {},
        current_phase="init",
        status="pending"
    )

@agent(
    agent_id="finai_browser",
    name="FinAI Finance Browser Agent",
    description="4-layer architecture agent for automated financial research using web browser",
    input_model=BrowserInput,
    state_model=BrowserState,
    input_to_state=convert_input_to_state,
    kafka_topic="finai_browser_events",
    dependency_specs={
        "kafka": "kafka_producer",
        "redis": "redis_client",
        "db": "database_manager",
        "message_bus": "message_bus"
    }
)
class FinAIBrowserAgent(BaseAgent[BrowserState]):
    """
    FinAI Browser Agent - 4-layer architecture for financial research.
    
    Layers:
    - Layer 0: Governance (input/output gates, in-flight guards)
    - Layer 1: Perception (DOM processing, context building)
    - Layer 2: Cognition (planning, execution, verification)
    - Layer 3: Action (browser control, tool execution)
    """
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.graph = create_browser_graph()
        self.name = "finai_browser"
```

### Lý do
- `@agent` decorator đăng ký agent vào AgentRegistry
- AgentFactory sử dụng registry để khởi tạo agents
- Mandatory fields: `agent_id`, `name`, `description`, `input_model`, `state_model`, `input_to_state`

---

## 4. State Models

### ❌ SDD hiện tại
```python
from pydantic import BaseModel

class AgentState(BaseModel):
    goal: str
    context: dict
    # ... custom fields
```

### ✅ Cần update thành
```python
# app/module/agent/finai_browser_agent/models.py

from pydantic import BaseModel, Field
from typing import Optional, Dict, List, Any
from app.common.agent.models import BaseState
from enum import Enum

# ─────────────────── Enums ───────────────────
class AgentPhase(str, Enum):
    INIT = "init"
    PERCEIVE = "perceive"
    PLAN = "plan"
    EXECUTE = "execute"
    VERIFY = "verify"
    SYNTHESIZE = "synthesize"
    COMPLETE = "complete"
    ERROR = "error"

# ─────────────────── Input Model (API) ───────────────────
class BrowserInput(BaseModel):
    """Input model for API validation"""
    goal: str = Field(..., min_length=5, description="Research goal")
    context: Optional[Dict[str, Any]] = Field(default=None, description="Additional context")
    max_steps: int = Field(default=50, ge=1, le=200, description="Max browser actions")
    timeout_seconds: int = Field(default=300, ge=30, le=1800, description="Timeout")

# ─────────────────── Internal State Model ───────────────────
class Evidence(BaseModel):
    """Evidence collected during research"""
    source_url: str
    content: str
    confidence: float = Field(ge=0.0, le=1.0)
    timestamp: str
    metadata: Dict[str, Any] = Field(default_factory=dict)

class BrowserContext(BaseModel):
    """Current browser state"""
    current_url: Optional[str] = None
    page_title: Optional[str] = None
    dom_snapshot: Optional[str] = None
    screenshot_path: Optional[str] = None

class BrowserState(BaseState):
    """
    Internal agent state - extends BaseState for compatibility.
    
    BaseState provides:
    - status: str (required by infrastructure)
    """
    # Core fields
    goal: str = ""
    current_phase: AgentPhase = AgentPhase.INIT
    
    # Browser context
    browser_context: Optional[BrowserContext] = None
    
    # Planning
    plan: List[str] = Field(default_factory=list)
    current_step: int = 0
    
    # Execution tracking
    actions_taken: List[Dict[str, Any]] = Field(default_factory=list)
    steps_remaining: int = 50
    
    # Evidence & Results
    evidence_pack: List[Evidence] = Field(default_factory=list)
    intermediate_results: List[Dict[str, Any]] = Field(default_factory=list)
    
    # Final output
    final_report: Optional[str] = None
    confidence_score: float = 0.0
    
    # Error handling
    error_message: Optional[str] = None
    retry_count: int = 0
    
    # Metadata
    request_id: Optional[str] = None
    start_time: Optional[str] = None
```

### Lý do
- `BaseState` có field `status` required bởi infrastructure
- Sử dụng `Field()` với validation
- Tách biệt Input model (API) và State model (internal)

---

## 5. Dependency Injection

### ❌ SDD hiện tại
```python
class BrowserAgent:
    def __init__(self):
        self.redis = Redis()  # Manual init
        self.db = Database()  # Manual init
```

### ✅ Cần update thành
```python
# Trong @agent decorator
@agent(
    # ... other params
    dependency_specs={
        "kafka": "kafka_producer",        # Inject Kafka producer
        "redis": "redis_client",          # Inject Redis client
        "db": "database_manager",         # Inject DB manager
        "message_bus": "message_bus",     # Inject MessageBus
        "llm_router": "llm_router"        # Inject LLM router
    }
)
class FinAIBrowserAgent(BaseAgent[BrowserState]):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # Dependencies được inject tự động qua kwargs
        # self.kafka, self.redis, self.db, self.message_bus, self.llm_router
        # đều available sau khi gọi super().__init__()
```

```python
# Đăng ký dependencies trong app/common/lifespans.py hoặc container.py

from app.common.dependency_resolver import DependencyResolver

def setup_dependencies() -> DependencyResolver:
    resolver = DependencyResolver()
    
    # Singleton instances
    resolver.register("kafka_producer", singleton=kafka_producer_instance)
    resolver.register("redis_client", singleton=redis_client_instance)
    
    # Factory functions (lazy initialization)
    resolver.register("database_manager", factory=lambda: create_db_manager())
    resolver.register("message_bus", factory=lambda: create_message_bus())
    resolver.register("llm_router", factory=lambda: create_llm_router())
    
    return resolver
```

### Lý do
- `DependencyResolver` quản lý dependencies với factory/singleton pattern
- BaseAgent.__init__() tự động set attributes từ kwargs
- Tách biệt dependency registration và agent implementation

---

## 6. Message Bus Integration

### ❌ SDD hiện tại
```python
class MessageBus:
    """Custom implementation from scratch"""
    def __init__(self):
        self.local_queue = asyncio.Queue()
        self.redis = Redis()
```

### ✅ Cần update thành
```python
# app/module/agent/finai_browser_agent/message_bus/bus.py

import asyncio
import json
from typing import Dict, Callable, Any, Optional
from dataclasses import dataclass
import redis.asyncio as redis

# Reuse constants từ existing infrastructure
CONTROL_CHANNEL = "finai-browser-control"

@dataclass
class Message:
    """Message structure for inter-agent communication"""
    sender_id: str
    target_id: Optional[str]  # None = broadcast
    action: str
    payload: Dict[str, Any]
    correlation_id: Optional[str] = None

class BrowserMessageBus:
    """
    MessageBus tích hợp với Redis PubSub pattern hiện có.
    
    Tương thích với graph_pub_sub.py infrastructure:
    - Sử dụng Redis Pub/Sub cho cross-worker communication
    - Hỗ trợ TERMINATE signals
    - Local queue cho same-worker optimization
    """
    
    def __init__(self, redis_client: redis.Redis, agent_id: str):
        self.redis = redis_client
        self.agent_id = agent_id
        self.channel = f"{CONTROL_CHANNEL}:{agent_id}"
        self.local_queue: asyncio.Queue[Message] = asyncio.Queue()
        self.handlers: Dict[str, Callable] = {}
        self.pubsub = None
        self._listener_task = None
        
    async def start(self):
        """Start listening to Redis channel"""
        self.pubsub = self.redis.pubsub()
        await self.pubsub.subscribe(self.channel, CONTROL_CHANNEL)
        self._listener_task = asyncio.create_task(self._listen())
    
    async def stop(self):
        """Stop listener and cleanup"""
        if self._listener_task:
            self._listener_task.cancel()
        if self.pubsub:
            await self.pubsub.close()
    
    async def _listen(self):
        """Background listener for Redis messages"""
        try:
            async for msg in self.pubsub.listen():
                if msg["type"] != "message":
                    continue
                try:
                    payload = json.loads(msg["data"])
                    message = Message(**payload)
                    
                    # Handle TERMINATE signal (compatible with graph_pub_sub)
                    if message.action == "TERMINATE":
                        await self._handle_terminate(message)
                        continue
                    
                    # Route to registered handler
                    if message.action in self.handlers:
                        await self.handlers[message.action](message)
                        
                except (json.JSONDecodeError, TypeError):
                    continue
        except asyncio.CancelledError:
            pass
    
    async def _handle_terminate(self, message: Message):
        """Handle TERMINATE signal"""
        # Implement graceful shutdown logic
        pass
    
    def register_handler(self, action: str, handler: Callable):
        """Register handler for specific action type"""
        self.handlers[action] = handler
    
    async def publish(self, message: Message):
        """Publish message to Redis channel"""
        target_channel = (
            f"{CONTROL_CHANNEL}:{message.target_id}" 
            if message.target_id 
            else CONTROL_CHANNEL
        )
        await self.redis.publish(
            target_channel, 
            json.dumps(message.__dict__)
        )
    
    async def request(
        self, 
        target_id: str, 
        action: str, 
        payload: dict,
        timeout: float = 30.0
    ) -> Optional[dict]:
        """Send request and wait for response"""
        import uuid
        correlation_id = str(uuid.uuid4())
        
        response_future = asyncio.get_event_loop().create_future()
        
        async def response_handler(msg: Message):
            if msg.correlation_id == correlation_id:
                response_future.set_result(msg.payload)
        
        self.register_handler(f"response:{correlation_id}", response_handler)
        
        await self.publish(Message(
            sender_id=self.agent_id,
            target_id=target_id,
            action=action,
            payload=payload,
            correlation_id=correlation_id
        ))
        
        try:
            return await asyncio.wait_for(response_future, timeout)
        except asyncio.TimeoutError:
            return None
        finally:
            self.handlers.pop(f"response:{correlation_id}", None)
```

### Lý do
- Tận dụng Redis Pub/Sub pattern đã có trong `graph_pub_sub.py`
- Tương thích với TERMINATE signal cho graceful shutdown
- Hỗ trợ multi-worker deployment (Kubernetes pods)

---

## 7. LangGraph Integration

### ❌ SDD hiện tại
```python
# Graph definition riêng biệt, không align với BaseAgent

graph = StateGraph(AgentState)
graph.add_node("perceive", perceive_node)
# ...
compiled = graph.compile()
```

### ✅ Cần update thành
```python
# app/module/agent/finai_browser_agent/layer_2_cognition/graph.py

from langgraph.graph import StateGraph, END
from langgraph.graph.state import CompiledStateGraph
from ..models import BrowserState, AgentPhase
from .nodes import (
    perceive_node,
    planner_node,
    executor_node,
    verifier_node,
    synthesize_node
)

def should_continue(state: BrowserState) -> str:
    """Determine next node based on state"""
    if state.error_message:
        return "error_handler"
    if state.current_phase == AgentPhase.COMPLETE:
        return END
    if state.steps_remaining <= 0:
        return "synthesize"
    
    phase_transitions = {
        AgentPhase.INIT: "perceive",
        AgentPhase.PERCEIVE: "planner",
        AgentPhase.PLAN: "executor",
        AgentPhase.EXECUTE: "verifier",
        AgentPhase.VERIFY: "perceive",  # Loop back if not done
        AgentPhase.SYNTHESIZE: END
    }
    return phase_transitions.get(state.current_phase, END)

def create_browser_graph() -> CompiledStateGraph:
    """
    Create and compile the browser agent graph.
    
    Returns:
        CompiledStateGraph: Graph compatible with BaseAgent.run_async()
    
    Flow:
        perceive -> planner -> executor -> verifier -> (loop or synthesize)
    """
    workflow = StateGraph(BrowserState)
    
    # Add nodes
    workflow.add_node("perceive", perceive_node)
    workflow.add_node("planner", planner_node)
    workflow.add_node("executor", executor_node)
    workflow.add_node("verifier", verifier_node)
    workflow.add_node("synthesize", synthesize_node)
    workflow.add_node("error_handler", error_handler_node)
    
    # Set entry point
    workflow.set_entry_point("perceive")
    
    # Add conditional edges
    workflow.add_conditional_edges(
        "perceive",
        should_continue,
        {
            "planner": "planner",
            "error_handler": "error_handler",
            END: END
        }
    )
    
    workflow.add_conditional_edges(
        "planner",
        should_continue,
        {
            "executor": "executor",
            "error_handler": "error_handler",
            END: END
        }
    )
    
    workflow.add_conditional_edges(
        "executor",
        should_continue,
        {
            "verifier": "verifier",
            "error_handler": "error_handler",
            END: END
        }
    )
    
    workflow.add_conditional_edges(
        "verifier",
        should_continue,
        {
            "perceive": "perceive",  # Continue loop
            "synthesize": "synthesize",
            "error_handler": "error_handler",
            END: END
        }
    )
    
    workflow.add_edge("synthesize", END)
    workflow.add_edge("error_handler", END)
    
    return workflow.compile()

# Example node implementation
async def perceive_node(state: BrowserState) -> BrowserState:
    """
    Perception node - analyze current browser state.
    
    Responsibilities:
    - Take DOM snapshot
    - Extract relevant information
    - Update browser context
    """
    # Implementation here
    state.current_phase = AgentPhase.PERCEIVE
    # ... perception logic
    return state

async def error_handler_node(state: BrowserState) -> BrowserState:
    """Handle errors gracefully"""
    state.current_phase = AgentPhase.ERROR
    state.status = "error"
    return state
```

### Lý do
- BaseAgent.run_async() sử dụng `astream_events()` trên `self.graph`
- Graph phải là `CompiledStateGraph`
- Nodes phải return state (không raise exception trừ critical errors)

---

## 8. Kafka Integration

### ❌ SDD hiện tại
Không đề cập Kafka

### ✅ Đã có sẵn trong BaseAgent
```python
# BaseAgent đã có method send_kafka_one()

# Trong agent nodes, có thể gửi events:
async def executor_node(state: BrowserState) -> BrowserState:
    # ... execution logic
    
    # Gửi progress event (nếu agent có kafka dependency)
    # Note: Cần access agent instance hoặc inject kafka vào state
    
    return state

# Hoặc trong agent class:
class FinAIBrowserAgent(BaseAgent[BrowserState]):
    async def send_progress(self, state: BrowserState, message: str):
        await self.send_kafka_one(
            KafkaMessage(
                requestId=state.request_id,
                status="in_progress",
                message=message,
                data={"phase": state.current_phase}
            )
        )
```

### Lý do
- BaseAgent.send_kafka_one() đã được implement
- Automatic error reporting khi graph execution fails
- Chỉ cần đăng ký `kafka_topic` trong dependency_specs

---

## 9. LangFuse Tracing

### ❌ SDD hiện tại
```python
# Custom tracing setup
from langfuse import Langfuse

client = Langfuse()
trace = client.trace(name="browser_agent")
```

### ✅ Đã có sẵn trong BaseAgent
```python
# BaseAgent.run_async() đã được decorate với @observe

@observe(capture_input=False, capture_output=False)
async def run_async(self, input_state: T, ...):
    # Tự động trace execution
    pass

# Để trace thêm trong nodes, sử dụng @observe decorator:
from langfuse import observe

@observe(name="perceive_node")
async def perceive_node(state: BrowserState) -> BrowserState:
    # Execution được trace tự động
    return state
```

### Lý do
- LangFuse đã được tích hợp trong BaseAgent
- Không cần custom setup
- Thêm `@observe` vào nodes nếu cần chi tiết hơn

---

## 10. API Integration Pattern

### ❌ SDD hiện tại
```python
# Direct agent instantiation
agent = BrowserAgent()
result = await agent.process(input_data)
```

### ✅ Cần update thành
```python
# app/api/routes/browser_agent.py

from fastapi import APIRouter, Depends, HTTPException
from app.common.agent.factory import AgentFactory
from app.module.agent.finai_browser_agent.models import BrowserInput

router = APIRouter(prefix="/browser", tags=["Browser Agent"])

async def get_agent_factory() -> AgentFactory:
    """Dependency to get AgentFactory instance"""
    # Factory được khởi tạo trong app lifespan
    from app.main import agent_factory
    return agent_factory

@router.post("/analyze")
async def analyze_financial_document(
    input_data: BrowserInput,
    factory: AgentFactory = Depends(get_agent_factory)
):
    """
    Initiate financial research with browser agent.
    
    Returns:
        Research results with evidence pack and final report
    """
    try:
        # Get agent instance from factory
        agent = factory.get_agent("finai_browser")
        config = factory.get_agent_config("finai_browser")
        
        # Convert input to state
        state = config.input_to_state(input_data)
        
        # Execute agent
        result = await agent.run_async(state)
        
        if result["status"] == "error":
            raise HTTPException(status_code=500, detail=result["error"])
        
        return {
            "status": "success",
            "data": result["output"]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/stop/{thread_id}")
async def stop_research(
    thread_id: str,
    factory: AgentFactory = Depends(get_agent_factory)
):
    """Stop ongoing research task"""
    # Sử dụng Redis PubSub để gửi TERMINATE signal
    # (Tích hợp với graph_pub_sub.py pattern)
    pass
```

### Lý do
- Sử dụng AgentFactory.get_agent() để lấy instance
- Input validation qua Pydantic model
- Consistent error handling

---

## 11. Testing Pattern

### ❌ SDD hiện tại
Testing không align với infrastructure

### ✅ Cần update thành
```python
# tests/module/agent/finai_browser_agent/conftest.py

import pytest
from unittest.mock import MagicMock, AsyncMock
from app.common.agent.registry import AgentRegistry
from app.common.dependency_resolver import DependencyResolver

@pytest.fixture(autouse=True)
def clear_registry():
    """Clear registry before/after each test"""
    AgentRegistry.clear_registry()
    yield
    AgentRegistry.clear_registry()

@pytest.fixture
def mock_dependencies():
    """Mock all external dependencies"""
    return {
        "kafka": AsyncMock(),
        "redis": AsyncMock(),
        "db": AsyncMock(),
        "message_bus": AsyncMock(),
        "llm_router": AsyncMock()
    }

@pytest.fixture
def dependency_resolver(mock_dependencies):
    """Create resolver with mocked dependencies"""
    resolver = DependencyResolver()
    for key, mock in mock_dependencies.items():
        resolver.register(key, singleton=mock)
    return resolver

@pytest.fixture
def browser_agent(dependency_resolver):
    """Create browser agent with mocked dependencies"""
    from app.module.agent.finai_browser_agent.agent import FinAIBrowserAgent
    
    deps = dependency_resolver.resolve({
        "kafka": "kafka",
        "redis": "redis",
        "db": "db",
        "message_bus": "message_bus"
    })
    
    return FinAIBrowserAgent(**deps)

# tests/module/agent/finai_browser_agent/test_agent.py

import pytest
from app.module.agent.finai_browser_agent.models import BrowserInput, BrowserState

class TestFinAIBrowserAgent:
    
    @pytest.mark.asyncio
    async def test_agent_execution_success(self, browser_agent):
        """Test successful agent execution"""
        state = BrowserState(
            goal="Research AAPL stock",
            status="pending"
        )
        
        result = await browser_agent.run_async(state)
        
        assert result["status"] == "success"
    
    @pytest.mark.asyncio
    async def test_agent_handles_error(self, browser_agent):
        """Test error handling"""
        state = BrowserState(
            goal="",  # Invalid goal
            status="pending"
        )
        
        result = await browser_agent.run_async(state)
        
        assert result["status"] == "error"
```

---

## 12. Tóm tắt các thay đổi

| Component | SDD Hiện tại | Cần Update | Lý do |
|-----------|--------------|------------|-------|
| File Path | `app/module/finai_agent/` | `app/module/agent/finai_browser_agent/` | Auto-discovery |
| Base Class | `P2PAgent(ABC)` | `BaseAgent[T]` + Mixin | Reuse infrastructure |
| Registration | Không có | `@agent` decorator | Factory pattern |
| Dependencies | Manual init | `dependency_specs` | DI pattern |
| State Models | Custom classes | Extend `BaseState` | Infrastructure compat |
| Message Bus | Custom từ đầu | Integrate Redis PubSub | Reuse existing |
| LangGraph | Standalone | Return `CompiledStateGraph` | BaseAgent compat |
| Kafka | Không có | Inherit từ BaseAgent | Already available |
| Tracing | Custom setup | Use `@observe` | Already integrated |
| API Pattern | Direct call | `AgentFactory.get_agent()` | Consistency |
| Testing | Custom | Use fixtures + clear registry | Isolation |

---

## 13. Migration Checklist

### Phase 1: Setup
- [ ] Tạo folder structure đúng tại `app/module/agent/finai_browser_agent/`
- [ ] Tạo `__init__.py` cho tất cả packages
- [ ] Tạo `models.py` với `BrowserInput` và `BrowserState` extending `BaseState`

### Phase 2: Agent Core
- [ ] Tạo `agent.py` với `@agent` decorator
- [ ] Implement `convert_input_to_state()` function
- [ ] Extend `BaseAgent[BrowserState]`
- [ ] Setup `dependency_specs` trong decorator

### Phase 3: Graph Implementation
- [ ] Tạo `layer_2_cognition/graph.py`
- [ ] Implement nodes trong `layer_2_cognition/nodes/`
- [ ] Return `CompiledStateGraph` từ `create_browser_graph()`

### Phase 4: Layers
- [ ] Implement Layer 0 (Governance)
- [ ] Implement Layer 1 (Perception)
- [ ] Implement Layer 3 (Action)

### Phase 5: Integration
- [ ] Đăng ký dependencies trong DependencyResolver
- [ ] Tạo API routes trong `app/api/routes/`
- [ ] Tích hợp MessageBus với Redis PubSub

### Phase 6: Testing
- [ ] Setup test fixtures
- [ ] Unit tests cho mỗi layer
- [ ] Integration tests
- [ ] E2E tests

---

## 14. References

- Base Agent: `/home/claude/finai_project/app/common/agent/base.py`
- Registry: `/home/claude/finai_project/app/common/agent/registry.py`
- Factory: `/home/claude/finai_project/app/common/agent/factory.py`
- Decorators: `/home/claude/finai_project/app/common/agent/decorators.py`
- DI: `/home/claude/finai_project/app/common/dependency_resolver.py`
- Redis PubSub: `/home/claude/finai_project/app/common/redis/graph_pub_sub.py`
- Talk Agent (reference): `/home/claude/finai_project/app/module/agent/talk_agent/agent.py`
