# Spec MVP: Trích xuất A11y/AX Tree → SnapshotV1 (Context cho Agent)

## 0) Mục tiêu
Tài liệu này mô tả cách Stage 1 (browser runtime) **trích xuất A11y/AX tree** từ một tab web và **đóng gói thành SnapshotV1 (JSON)** để làm *context chuẩn hoá* cho các bước sau.

### 0.1 Mục tiêu kỹ thuật (đo được)
- Tạo `SnapshotV1` (versioned) gồm:
  - **AX/A11y tree** đã được *flatten + prune + redact* (thin context mặc định)
  - **Tab metadata**: URL, title, viewport, scroll, timestamp
  - **Stabilization report** để debug (vì sao snapshot có thể thiếu node)
- Snapshot đủ nhẹ để:
  - gửi qua pipeline (Stage 1 → Stage 2/3/4)
  - log/trace an toàn (redaction mặc định)
  - dễ debug (trace_id + stabilization + quality flags)

### 0.2 Non-goals (phạm vi không làm trong tài liệu này)
- Không “dump full DOM” (quá nặng, nhiễu) cho model.
- Không làm “Action enrich” (anchor/geometry) cho click chắc trong Stage 4.
  - Phần đó nên là **spec riêng** theo triết lý *thin → zoom-in*.

---

## 1) Ý nghĩa (vì sao cần doc này)
Trong agentic browser (comet-like), vấn đề lớn nhất là: **model phải hiểu UI đúng ngữ cảnh, còn executor phải thao tác chắc tay**.

- **A11y tree** là “bản đồ ngữ nghĩa UI” do browser tạo ra: button/textbox/link/menu… + label/state.
- **Snapshot** là “ảnh chụp dữ liệu có cấu trúc” (JSON), giúp các stage downstream nhìn cùng một “thế giới” tại một thời điểm.

Lợi ích chính:
- **Giảm nhiễu** so với full DOM: tập trung vào thứ có ý nghĩa để thao tác.
- **Giảm hallucination**: model dựa trên context thật từ browser.
- **Tách bạch trách nhiệm**:
  - Stage 1: thu thập + chuẩn hoá (dữ liệu)
  - Stage 2/3: hiểu + lập plan (suy luận)
  - Stage 4: thực thi (hành động), có thể gọi enrich theo nhu cầu

---

## 2) Giải thích chi tiết (để team cùng “nhìn một hình”)

### 2.1 DOM tree vs A11y tree vs Snapshot
- **DOM tree**: cấu trúc kỹ thuật đầy đủ của trang (nhiều node vô nghĩa với agent).
- **A11y/AX tree**: cây ngữ nghĩa UI (thường gọn, sát thao tác người dùng).
- **Snapshot**: JSON do hệ thống bạn tự đóng gói, hợp nhất:
  - AX tree (nguồn chính cho “hiểu UI”)
  - metadata (đang ở trang nào, viewport/scroll ra sao)
  - báo cáo ổn định trang (stabilization)
  - cờ chất lượng (đã prune/redact hay chưa)

> Snapshot **không phải OCR**. OCR là đọc chữ từ ảnh; Snapshot là dữ liệu có cấu trúc trích trực tiếp từ browser.

### 2.2 Vì sao “thin snapshot” là mặc định tốt
- Model cần “ít nhưng đúng” để hiểu UI: nút/ô nhập/link + label/state.
- Full DOM/Full AX tree thường tốn token và thêm nhiễu.
- Khi cần click chắc (Stage 4), mới làm **zoom-in enrich** cho 1–3 candidate targets.

### 2.3 Vai trò Snapshot trong pipeline Stage 1–4
- **Stage 1** tạo SnapshotV1.
- **Stage 2/3** dùng Snapshot để:
  - resolve tham chiếu mơ hồ (“nút đăng ký”, “ô tìm kiếm”)
  - tìm candidates (top-k elements)
- **Stage 4** dùng Snapshot thin để chọn mục tiêu, và (tuỳ) gọi spec enrich riêng để click chắc.

---

## 3) Tóm tắt non-tech
A11y/AX tree là “bản đồ ngữ nghĩa UI” (nút bấm/ô nhập/link…) do browser tự sinh. Stage 1 dùng browser API để trích xuất cây này + metadata rồi đóng gói thành **Snapshot JSON**. Snapshot là context chuẩn cho Stage 2/3 hiểu trang và Stage 4 hành động (khi cần thì enrich thêm anchor/geometry).

---

## 4) Folder structure (khuyến nghị)
```
ax_snapshot/
  __init__.py
  models.py          # Data models: SnapshotV1 / AxNodeV1 / Viewport...
  meta.py            # Tab metadata: url/title/viewport/scroll
  stabilizer.py      # Page stabilize: wait domcontentloaded/networkidle/settle
  extractor.py       # AX tree extraction: Playwright snapshot (+optional CDP full AX)
  prune.py           # Pruning: giữ node hữu dụng (thin context)
  redact.py          # Privacy redaction: mask password/OTP/token...
  assembler.py       # Assemble SnapshotV1 + serialize JSON
  main.py            # Entry/demo: wire modules together (build_snapshot)
```

> Quy ước: Stage 1 gọi `build_snapshot()` trong `main.py` để tạo SnapshotV1. Các stage sau chỉ nhìn Snapshot (JSON) chứ không phụ thuộc Playwright.

---

## 5) Bảng module → chức năng (ngắn gọn, dễ đọc)
| Module | Vai trò | Input | Output | Vì sao cần |
|---|---|---|---|---|
| `models.py` | Định nghĩa schema (versioned) | — | dataclasses | Chuẩn hoá dữ liệu, dễ versioning/log/debug |
| `meta.py` | Lấy metadata tab | `page` | `Viewport + scroll` | Model cần biết đang ở trang nào, viewport/scroll |
| `stabilizer.py` | “Làm trang đứng yên” trước khi chụp | `page` | `stabilization report` | Tránh snapshot rung/thiếu node do SPA render |
| `extractor.py` | Trích xuất AX tree | `page` | `(root_id, nodes[])` | Nguồn ngữ nghĩa UI cho agent |
| `prune.py` | Rút gọn cây (thin context) | `nodes[]` | `nodes[]` | Giảm token + tăng signal/noise |
| `redact.py` | Mask dữ liệu nhạy cảm | `nodes[]` | `nodes[]` (in-place) | An toàn mặc định cho logs/trace |
| `assembler.py` | Đóng gói SnapshotV1 + serialize | metadata + nodes | `SnapshotV1` + JSON | Chuẩn output cho Stage 2/3/4 |
| `main.py` | Orchestrator | URL + flags | Snapshot JSON | Nơi “kết dây” pipeline, dễ bật/tắt flags |

---

## 6) Pipeline tổng quát (từ Stage 1)
```
page/tab handle
    |
    v
[meta] -> url/title/viewport/scroll
    |
[stabilizer] -> domcontentloaded/networkidle (best-effort)
    |
[extractor] -> AX tree (Playwright snapshot)
    |
[prune] -> thin nodes
    |
[redact] -> mask secrets
    |
[assembler] -> SnapshotV1 JSON
```

*(Optional cho Stage 4 action: enrich anchor/geometry theo candidate nodes — sẽ là spec/module riêng, không nhét vào thin snapshot mặc định.)*

---

## 7) SnapshotV1 schema (MVP)
```json
{
  "snapshot_version": 1,
  "snapshot_id": "ax_<uuid>",
  "trace_id": "trace_<...>",
  "ts": "ISO-8601",
  "url": "string",
  "title": "string",
  "viewport": {"width":0,"height":0,"scrollX":0,"scrollY":0},
  "stabilization": {"stabilized": true, "reasons": []},
  "quality": {"pruned": true, "redacted": true},
  "ax_tree": {
    "root_id": "root",
    "nodes": [
      {"id":"n1","role":"textbox","name":"Email","value":"","children":[]}
    ]
  }
}
```

---

# 8) Code reference (tách module, có chú thích)

## 8.1 `models.py`
```python
from __future__ import annotations
from dataclasses import dataclass
from typing import Any, Dict, List, Optional


@dataclass
class Viewport:
    width: int
    height: int
    scrollX: int
    scrollY: int


@dataclass
class DomRef:
    backendNodeId: Optional[int] = None
    css: Optional[str] = None
    xpath: Optional[str] = None


@dataclass
class BBox:
    x: float
    y: float
    w: float
    h: float


@dataclass
class AxNodeV1:
    id: str
    role: str
    name: str = ""
    value: Optional[str] = None
    state: Optional[Dict[str, Any]] = None
    children: Optional[List[str]] = None

    # Optional (chỉ bật khi action-enrich)
    domRef: Optional[DomRef] = None
    bbox: Optional[BBox] = None
    isVisible: Optional[bool] = None
    isClickable: Optional[bool] = None


@dataclass
class AxTreeV1:
    root_id: str
    nodes: List[AxNodeV1]


@dataclass
class SnapshotV1:
    snapshot_version: int
    snapshot_id: str
    trace_id: str
    ts: str
    url: str
    title: str
    viewport: Viewport
    stabilization: dict
    quality: dict
    ax_tree: AxTreeV1
```

## 8.2 `meta.py`
```python
from playwright.sync_api import Page
from .models import Viewport


def get_viewport(page: Page) -> Viewport:
    """Thu viewport + scroll để downstream hiểu ‘mắt đang nhìn đâu’."""
    vp = page.viewport_size or {"width": 0, "height": 0}
    scroll = page.evaluate("() => ({x: window.scrollX, y: window.scrollY})")
    return Viewport(
        width=int(vp["width"]),
        height=int(vp["height"]),
        scrollX=int(scroll["x"]),
        scrollY=int(scroll["y"]),
    )
```

## 8.3 `stabilizer.py`
```python
import time
from playwright.sync_api import Page


def stabilize_page(page: Page, timeout_ms: int = 10_000) -> dict:
    """
    Best-effort stabilization (SPA-friendly).
    Nếu trang không “đứng yên”, a11y snapshot có thể thiếu node hoặc sai trạng thái.
    """
    reasons = []

    try:
        page.wait_for_load_state("domcontentloaded", timeout=timeout_ms)
    except Exception:
        reasons.append("domcontentloaded_timeout")

    try:
        page.wait_for_load_state("networkidle", timeout=timeout_ms)
    except Exception:
        reasons.append("networkidle_timeout")

    time.sleep(0.15)
    return {"stabilized": True, "reasons": reasons}
```

## 8.4 `extractor.py`
```python
from typing import Any, Dict, List, Tuple
from playwright.sync_api import Page
from .models import AxNodeV1


def _flatten(ax: Dict[str, Any]) -> Tuple[str, List[AxNodeV1]]:
    """
    Playwright accessibility.snapshot() trả về nested dict.
    Flatten -> list để prune/log/debug dễ.
    """
    nodes: List[AxNodeV1] = []

    def walk(node: Dict[str, Any]) -> str:
        node_id = f"n{len(nodes)}"
        role = node.get("role") or "unknown"
        name = node.get("name") or ""
        value = node.get("value")

        state = {}
        for k in ["disabled", "checked", "expanded", "pressed", "selected", "focused"]:
            if k in node:
                state[k] = node[k]

        ax_node = AxNodeV1(
            id=node_id,
            role=role,
            name=name,
            value=value,
            state=(state or None),
            children=[],
        )
        nodes.append(ax_node)

        for child in node.get("children") or []:
            ax_node.children.append(walk(child))

        return node_id

    root_id = walk(ax)
    return root_id, nodes


def extract_ax_playwright(page: Page) -> Tuple[str, List[AxNodeV1]]:
    """MVP extractor: nhanh, đủ ngữ nghĩa cho Stage 2/3."""
    ax = page.accessibility.snapshot()
    if not ax:
        return "root", []
    return _flatten(ax)


def extract_ax_cdp_full(page: Page) -> List[Dict[str, Any]]:
    """
    Advanced: Chromium-only CDP full AX tree.
    Dùng khi debug sâu hoặc cần mapping low-level.
    """
    cdp = page.context.new_cdp_session(page)
    res = cdp.send("Accessibility.getFullAXTree", {})
    return res.get("nodes", [])
```

## 8.5 `prune.py`
```python
from typing import List
from .models import AxNodeV1

KEEP_ROLES = {
    "button", "link", "textbox", "checkbox", "radio", "combobox",
    "menuitem", "tab", "switch", "searchbox", "option", "heading"
}

def prune_nodes(nodes: List[AxNodeV1]) -> List[AxNodeV1]:
    """Thin context: giữ thứ agent cần để hiểu và chọn mục tiêu."""
    out: List[AxNodeV1] = []
    for n in nodes:
        role = (n.role or "").lower()
        name = (n.name or "").strip()
        if role in KEEP_ROLES and (name or role == "textbox"):
            out.append(n)
    return out
```

## 8.6 `redact.py`
```python
import re
from typing import List
from .models import AxNodeV1

def redact(nodes: List[AxNodeV1]) -> None:
    """Mask password/OTP/token… để snapshot an toàn mặc định."""
    for n in nodes:
        if n.value is None:
            continue
        name = (n.name or "").lower()
        if "mật khẩu" in name or "password" in name:
            n.value = "***"
        elif re.search(r"\b(otp|token|mfa|2fa)\b", name):
            n.value = "***"
```

## 8.7 `assembler.py`
```python
import json, uuid
from dataclasses import asdict
from datetime import datetime, timezone
from typing import List
from playwright.sync_api import Page

from .models import AxTreeV1, AxNodeV1, SnapshotV1
from .meta import get_viewport

def now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()

def assemble(
    page: Page,
    trace_id: str,
    stabilization: dict,
    pruned: bool,
    redacted: bool,
    root_id: str,
    nodes: List[AxNodeV1],
) -> SnapshotV1:
    """Đóng gói thành SnapshotV1 chuẩn để Stage 2/3/4 dùng chung."""
    return SnapshotV1(
        snapshot_version=1,
        snapshot_id=f"ax_{uuid.uuid4().hex}",
        trace_id=trace_id,
        ts=now_iso(),
        url=page.url,
        title=page.title(),
        viewport=get_viewport(page),
        stabilization=stabilization,
        quality={"pruned": pruned, "redacted": redacted},
        ax_tree=AxTreeV1(root_id=root_id, nodes=nodes),
    )

def to_json(snapshot: SnapshotV1) -> str:
    return json.dumps(asdict(snapshot), ensure_ascii=False, indent=2)
```

## 8.8 `main.py`
```python
from playwright.sync_api import sync_playwright
from .stabilizer import stabilize_page
from .extractor import extract_ax_playwright
from .prune import prune_nodes
from .redact import redact
from .models import AxNodeV1
from .assembler import assemble, to_json

def build_snapshot(page, trace_id: str, stabilize=True, prune=True, do_redact=True):
    # 1) stabilize (best-effort)
    stab = stabilize_page(page) if stabilize else {"stabilized": True, "reasons": []}

    # 2) extract AX
    root_id, nodes = extract_ax_playwright(page)

    # 3) prune -> thin context
    pruned = False
    if prune:
        nodes = prune_nodes(nodes)
        # synthetic root giúp downstream luôn có 1 root ổn định
        root = AxNodeV1(id="root", role="document", name="", children=[n.id for n in nodes])
        nodes = [root] + nodes
        root_id = "root"
        pruned = True

    # 4) redact secrets
    redacted = False
    if do_redact:
        redact(nodes)
        redacted = True

    # 5) assemble snapshot
    return assemble(page, trace_id, stab, pruned, redacted, root_id, nodes)

def demo():
    url = "https://example.com"
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        page = browser.new_page(viewport={"width": 1200, "height": 800})
        page.goto(url, wait_until="domcontentloaded")

        snap = build_snapshot(page, trace_id="trace_001", stabilize=True, prune=True, do_redact=True)
        print(to_json(snap))

        browser.close()

if __name__ == "__main__":
    demo()
```
