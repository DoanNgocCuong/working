

# Stage 1 – Input & Ingestion (CORE, MVP)

## 0. Mục tiêu & Scope

**Mục tiêu:**

- Nhận mọi input từ client (browser/app):
    
    - `raw_input` user gõ vào chat.
        
    - `page_context` thông tin tab đang mở (URL, title, đoạn text đang bôi đen).
        
- Tiền xử lý & gom lại thành **`UnifiedInputCore`** – JSON chuẩn cho Stage 2 (Query Understanding).
    
- Không fetch HTML, không gọi LLM, không hiểu intent.
    
- Ghi `telemetry` cơ bản để debug.
    

**Không làm:**

- ❌ Không fetch URL, không parse HTML.
    
- ❌ Không gắn nhãn `intent`, `scope`, `artifact`, `risk`, `action_level`.
    
- ❌ Không xử lý audio/video ngoài chỗ trống để sau này nhét metadata.
    

---

## 1. Interface Service

### 1.1. Endpoint

- **Method:** `POST`
    
- **Path:** `/v1/input/ingest`
    
- **Input body:** `RawRequest` (JSON)
    
- **Output body:** `UnifiedInputCore` (JSON)
    

---

## 2. Data Model

### 2.1. RawRequest (input từ client)

```python
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field


# --- Sub-models ---

class ClientLocation(BaseModel):
    """Vị trí địa lý của client để phục vụ search 'gần đây'."""
    latitude: Optional[float] = Field(default=None, description="Latitude coordinate")
    longitude: Optional[float] = Field(default=None, description="Longitude coordinate")
    city: Optional[str] = Field(default=None, description="City name")
    country: Optional[str] = Field(default=None, description="Country name")

class ClientMeta(BaseModel):
    """Metadata về thiết bị và ngữ cảnh client."""
    device: Optional[str] = Field(default=None, description="Device type (desktop, mobile, tablet)")
    browser: Optional[str] = Field(default=None, description="Browser name (Chrome, Firefox, etc.)")
    os: Optional[str] = Field(default=None, description="Operating system (Windows, macOS, Linux, iOS, Android)")
    
    # [V3] Context fields injection
    location: Optional[ClientLocation] = Field(default=None, description="Geographic location of client")
    local_time: Optional[str] = Field(default=None, description="ISO 8601 timestamp of client local time")
    
    class Config:
        extra = "ignore"

class EnvMeta(BaseModel):
    """Metadata về môi trường request (user, session, locale)."""
    user_id: Optional[str] = Field(default=None, description="Unique user identifier")
    session_id: Optional[str] = Field(default=None, description="Session identifier for tracking")
    timezone: Optional[str] = Field(default="Asia/Bangkok", description="Timezone string (IANA format)")
    locale: Optional[str] = Field(default="vi-VN", description="Locale string (language-country format)")
    client: Optional[ClientMeta] = Field(default=None, description="Client device and browser metadata")

    class Config:
        extra = "ignore"

class PageContext(BaseModel):
    """Context về trang web hiện tại mà user đang xem."""
    active_url: Optional[str] = Field(default=None, description="URL of the active browser tab")
    active_title: Optional[str] = Field(default=None, description="Title of the active browser tab")
    selection_text: Optional[str] = Field(default=None, description="Text currently selected/highlighted by user")

    class Config:
        extra = "ignore"

class Query(BaseModel):
    """Chứa thông tin truy vấn đã được xử lý và chuẩn hóa."""
    text_raw: str = Field(
        description="Original raw text input from user (unchanged, exactly as received)"
    )
    text_normalized: str = Field(
        description="Normalized text after Unicode normalization (NFKC + unidecode), URL tokenization ({{URL_i}}), and PII masking (<EMAIL>, <PHONE>)"
    )
    detected_lang: str = Field(
        description="Detected language: 'vi', 'en', or 'unknown'. Note: V3 architecture always sets to 'unknown' (language detection removed)"
    )
    
    # URLs extraction
    urls_in_text: List[str] = Field(
        default_factory=list, 
        description="List of URLs extracted from text_raw (for backward compatibility)"
    )
    
    # [V3] URL tokenization mapping
    urls_map: Dict[str, str] = Field(
        default_factory=dict,
        description="Map token {{URL_i}} -> original URL. Example: {'{{URL_1}}': 'https://example.com'}"
    )
    
    # [V3] PII tokenization mapping
    pii_map: Dict[str, str] = Field(
        default_factory=dict,
        description="Map token <EMAIL_i>/<PHONE_i> -> original value. Example: {'<EMAIL_1>': 'admin@company.com', '<PHONE_1>': '0987654321'}"
    )

class Telemetry(BaseModel):
    """Performance metrics và thống kê về quá trình xử lý."""
    stage1_total_latency_ms: float = Field(description="Total latency of Stage 1 pipeline in milliseconds")
    modules: Dict[str, float] = Field(
        description="Latency breakdown per module in milliseconds. Example: {'buildEnv': 1.5, 'textNormalizer': 2.3}"
    )
    raw_input_length: int = Field(description="Character length of raw_input")

class SafetyFlags(BaseModel):
    """Các cờ an toàn và validation flags."""
    raw_input_too_long: Optional[bool] = Field(
        default=False, 
        description="True if raw_input exceeds MAX_RAW_INPUT_LENGTH threshold"
    )
    too_many_urls: Optional[bool] = Field(
        default=False,
        description="True if number of URLs exceeds MAX_URL_COUNT threshold"
    )
    
    # [V3] PII detection flag
    has_pii: bool = Field(
        default=False,
        description="True if email/phone detected and masked in text_normalized"
    )
    
    # Placeholder for future toxicity detection
    is_toxic: bool = Field(
        default=False,
        description="Placeholder for future toxicity detection (always False in Stage 1)"
    )
    
class RawRequest(BaseModel):
    raw_input: Optional[str] = Field(default=None, description="Raw user text")
    env_meta: Optional[EnvMeta] = None
    page_context: Optional[PageContext] = None

    class Config:
        extra = "ignore"
```

### 2.2. UnifiedInputCore (output sang Stage 2)

```python

# --- Main Model ---

class UnifiedInputCore(BaseModel):
    """
    Core Data Envelope chuyển giao từ Stage 1 sang Stage 2.
    
    Đây là output chính của Stage 1, chứa tất cả thông tin đã được chuẩn hóa và xử lý.
    """
    input_id: str = Field(
        description="UUID uniquely identifying this input"
    )
    
    # [V3] Semantic cache key for deduplication
    input_hash: str = Field(
        description="SHA-256 hash of normalized text + user_id + model_version + prompt_version. Used for semantic caching and deduplication."
    )
    
    received_at: str = Field(
        description="ISO-8601 UTC timestamp when request was received by Stage 1"
    )

    input_type: str = Field(
        description="Classification of input: 'TEXT' (no URLs), 'URL' (only URL), 'MIXED' (text + URLs)"
    )

    # Core Data
    query: Query = Field(
        description="Processed query information including normalized text, URLs, and PII mappings"
    )
    env: Dict[str, Any] = Field(
        description="Environment metadata as dictionary (user, session, locale, client info)"
    )
    
    page_context: Optional[PageContext] = Field(
        default=None,
        description="Context about the web page user is currently viewing (URL, title, selected text)"
    )

    # Placeholders for later stages (Stage 1 strictly returns null/None)
    url_context: Optional[None] = Field(
        default=None,
        description="Placeholder for URL content fetched in Stage 2 (always None in Stage 1)"
    )
    doc_context: Optional[None] = Field(
        default=None,
        description="Placeholder for document content processed in Stage 2 (always None in Stage 1)"
    )
    media_context: Optional[None] = Field(
        default=None,
        description="Placeholder for media content processed in Stage 2 (always None in Stage 1)"
    )

    # Metrics & Flags
    telemetry: Telemetry = Field(
        description="Performance metrics and latency breakdown"
    )
    safety_flags: SafetyFlags = Field(
        description="Safety and validation flags"
    )
```

---

## 3. Pipeline tổng quan

```python
import time

def ingest(raw: RawRequest) -> UnifiedInputCore:
    t0 = time.perf_counter()
    modules_latency: Dict[str, float] = {}

    # 1. buildEnv
    t_env0 = time.perf_counter()
    env = buildEnv(raw.env_meta)
    modules_latency["buildEnv"] = (time.perf_counter() - t_env0) * 1000

    # 2. initEnvelope
    t_init0 = time.perf_counter()
    envelope = initEnvelope(raw, env)
    modules_latency["initEnvelope"] = (time.perf_counter() - t_init0) * 1000

    # 3. classify input (TEXT / URL / MIXED + urls_in_text)
    t_cls0 = time.perf_counter()
    envelope = runInputClassifier(envelope)
    modules_latency["inputClassifier"] = (time.perf_counter() - t_cls0) * 1000

    # 4. normalize text + tokenize URLs/PII
    t_norm0 = time.perf_counter()
    envelope = runTextNormalizer(envelope)
    modules_latency["textNormalizer"] = (time.perf_counter() - t_norm0) * 1000

    # 5. compute hash for deduplication
    envelope.input_hash = envelope.compute_hash()

    # 6. attach page_context
    t_page0 = time.perf_counter()
    envelope = attachPageContext(envelope, raw)
    modules_latency["pageContext"] = (time.perf_counter() - t_page0) * 1000

    # 7. telemetry + safety flags
    total_ms = (time.perf_counter() - t0) * 1000
    envelope.telemetry = buildTelemetry(total_ms, modules_latency, envelope)
    envelope.safety_flags = computeSafetyFlags(envelope)

    return envelope
```

---

## 4. Mô tả chi tiết từng module

### 4.1. Module `buildEnv`

**Mục đích:** Chuẩn hoá metadata môi trường (session, timezone, locale, client) → để Stage 2/3 không phải xử lý `env_meta` thô từ client.

**Security & Fail-Safe:**
- **Validate `local_time`**: Bắt buộc phải đúng format ISO 8601. Nếu sai hoặc None → Fallback về Server Time (UTC).
- **Sanitize `location`**: Loại bỏ các ký tự đặc biệt nguy hiểm (newline, control chars, injection patterns) trong `city`, `country` để tránh Prompt Injection.
- **Priority**: User locale/timezone > Client locale/timezone > Default (từ config).

**Input:**

- `RawRequest.env_meta` (Optional[EnvMeta])
    

**Xử lý:**

- Gán default nếu thiếu:
    
    - `timezone` default `"Asia/Bangkok"` (từ config).
        
    - `locale` default `"vi-VN"` (từ config).
        
    - `session_id` nếu thiếu thì `"unknown_session"` (từ config).
        
    - `user_id` nếu thiếu thì `"anon"` (cho hash deduplication).
        
- **Validate `local_time`**: Parse ISO 8601, nếu invalid → Fallback Server Time (UTC).
- **Sanitize `location`**: Loại bỏ injection patterns, chỉ giữ chữ cái/số/ký tự an toàn.
- Convert `client` object thành dict nếu có (đã được sanitize).

**Output:** `Dict[str, Any]` dùng trong `UnifiedInputCore.env`. Dữ liệu `client.location` và `client.local_time` đã được sanitize và validate.

```python
import re
from datetime import datetime, timezone
from typing import Dict, Optional
from dateutil import parser

from ..api.schemas import EnvMeta
from ..core.config import settings


def _validate_and_normalize_local_time(local_time: Optional[str]) -> str:
    """
    Validate và normalize local_time từ client.
    
    - Bắt buộc phải đúng format ISO 8601
    - Nếu sai hoặc None -> Fallback về Server Time (UTC)
    - Fail-safe: Luôn trả về ISO 8601 string hợp lệ
    """
    if not local_time:
        return datetime.now(timezone.utc).isoformat()
    
    try:
        dt = parser.isoparse(local_time)
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return dt.astimezone(timezone.utc).isoformat()
    except (ValueError, TypeError, parser.ParserError):
        # Invalid format -> Fallback về Server Time
        return datetime.now(timezone.utc).isoformat()


def _sanitize_location_string(value: Optional[str], max_length: int = 100) -> Optional[str]:
    """
    Sanitize location string (city, country) để tránh Prompt Injection.
    
    - Loại bỏ các ký tự đặc biệt nguy hiểm (newline, control chars, injection patterns)
    - Giới hạn độ dài để tránh buffer overflow
    - Chỉ cho phép: chữ cái, số, dấu cách, dấu phẩy, dấu gạch ngang, dấu ngoặc đơn
    """
    if not value:
        return None
    
    # Loại bỏ injection patterns và control characters
    dangerous_patterns = [
        r"(?i)ignore\s+(previous|all|every)",
        r"(?i)system\s+prompt",
        r"(?i)you\s+are\s+now",
        r"(?i)act\s+as",
        r"[\r\n\t]",
        r"[\x00-\x08\x0b\x0c\x0e-\x1f\x7f]",
    ]
    
    sanitized = value
    for pattern in dangerous_patterns:
        sanitized = re.sub(pattern, "", sanitized)
    
    # Chỉ giữ lại: chữ cái, số, dấu cách, dấu phẩy, dấu gạch ngang, dấu ngoặc đơn
    # Cho phép Unicode để support tên địa danh tiếng Việt
    sanitized = re.sub(r"[^\w\s,\-()àáảãạâầấẩẫậăằắẳẵặèéẻẽẹêềếểễệòóỏõọôồốổỗộơờớởỡợùúủũụưừứửữựìíỉĩịỳýỷỹỵđ]", "", sanitized, flags=re.UNICODE)
    
    sanitized = sanitized.strip()
    if len(sanitized) > max_length:
        sanitized = sanitized[:max_length]
    
    return sanitized if sanitized else None


def buildEnv(env_meta: Optional[EnvMeta]) -> Dict:
    """
    Chuẩn hóa thông tin môi trường từ client và áp dụng giá trị mặc định.
    
    **Security & Fail-Safe:**
    - Validate `local_time`: Phải đúng ISO 8601, nếu sai -> Fallback Server Time (UTC)
    - Sanitize `location`: Loại bỏ ký tự đặc biệt nguy hiểm để tránh Prompt Injection
    - Priority: User locale/timezone > Default (từ config)
    """
    meta = env_meta or EnvMeta()
    
    # Priority: user locale/timezone > client locale/timezone > default
    user_locale = meta.locale
    user_timezone = meta.timezone
    
    # Process client metadata với sanitization
    client_dict = None
    if meta.client:
        client_raw = meta.client.dict(exclude_none=True)
        
        # Sanitize location nếu có
        if "location" in client_raw and client_raw["location"]:
            location = client_raw["location"]
            sanitized_location = {}
            
            if "city" in location:
                sanitized_location["city"] = _sanitize_location_string(location.get("city"))
            if "country" in location:
                sanitized_location["country"] = _sanitize_location_string(location.get("country"))
            
            # Giữ nguyên latitude, longitude (số thực)
            if "latitude" in location:
                sanitized_location["latitude"] = location.get("latitude")
            if "longitude" in location:
                sanitized_location["longitude"] = location.get("longitude")
            
            if any(v is not None for v in sanitized_location.values()):
                client_raw["location"] = sanitized_location
            else:
                client_raw.pop("location", None)
        
        # Validate và normalize local_time
        if "local_time" in client_raw:
            client_raw["local_time"] = _validate_and_normalize_local_time(client_raw.get("local_time"))
        
        # Lấy locale/timezone từ client nếu chưa có ở meta level
        if not user_locale and "locale" in client_raw:
            user_locale = client_raw.get("locale")
        if not user_timezone and "timezone" in client_raw:
            user_timezone = client_raw.get("timezone")
        
        if client_raw:
            client_dict = client_raw

    return {
        "user_id": meta.user_id or "anon",
        "session_id": meta.session_id or settings.default_session_id,
        "timezone": user_timezone or settings.default_timezone,
        "locale": user_locale or settings.default_locale,
        "client": client_dict,
    }
```

**Lưu ý:** Module này yêu cầu dependency `python-dateutil` để parse ISO 8601. Cần thêm vào `requirements.txt`:
```
python-dateutil>=2.8.2
```

---

### 4.2. Module `initEnvelope`

**Mục đích:** Tạo "khung xương" `UnifiedInputCore` với:

- `input_id`, `received_at`
    
- Nhét `raw_input` vào `query.text_raw`
    
- Kê sẵn các field khác với giá trị rỗng hoặc mặc định.
    

**Input:**

- `RawRequest`
    
- `env` từ `buildEnv` (Dict)
    

**Xử lý:**

- Generate `input_id` (UUID).
    
- `received_at = now()` (ISO UTC format).
    
- `input_type` tạm = `"TEXT"` (sẽ override sau).
    
- `query.text_raw = raw.raw_input or ""`.
    
- `input_hash = ""` (sẽ tính sau khi normalize).
    
- Khởi tạo `urls_map`, `pii_map` rỗng.

**Output:** object `envelope` kiểu `UnifiedInputCore` (chưa classifier, chưa normalize).

```python
from datetime import datetime, timezone
from uuid import uuid4

def initEnvelope(raw: RawRequest, env: dict) -> UnifiedInputCore:
    now_iso = datetime.now(timezone.utc).isoformat()
    raw_text = raw.raw_input or ""

    envelope = UnifiedInputCore(
        input_id=str(uuid4()),
        input_hash="",  # Sẽ tính sau khi normalize
        received_at=now_iso,
        input_type="TEXT",  # Tạm, sẽ override
        query={
            "text_raw": raw_text,
            "text_normalized": "",
            "detected_lang": "unknown",
            "urls_in_text": [],
            "urls_map": {},
            "pii_map": {},
        },
        env=env,
        page_context=raw.page_context,
        url_context=None,
        doc_context=None,
        media_context=None,
        telemetry={
            "stage1_total_latency_ms": 0.0,
            "modules": {},
            "raw_input_length": len(raw_text),
        },
        safety_flags={},
    )
    return envelope
```

---

### 4.3. Module `runInputClassifier`

**Mục đích:** Phân loại **kỹ thuật** input:

- Xem trong `text_raw` có URL không.
    
- Gán:
    
    - `input_type = "TEXT" | "URL" | "MIXED"`
        
    - `urls_in_text = [list URL]`
        

**Input:**

- `envelope.query.text_raw`
    

**Logic:**

- Dùng regex bắt URL: `URL_REGEX` từ constants (hỗ trợ domain, IPv4, localhost)
    
- Nếu:
    
    - Không có URL → `"TEXT"`
        
    - 1 URL & toàn bộ message = URL đó → `"URL"`
        
    - Còn lại (text + URL) → `"MIXED"`
        

**Output:**

- `envelope.input_type` được set.
    
- `envelope.query.urls_in_text` chứa list URL (đã strip).

```python
from ..core.constants import URL_REGEX

def runInputClassifier(envelope: UnifiedInputCore) -> UnifiedInputCore:
    raw = (envelope.query.text_raw or "").strip()
    urls = [m.strip() for m in URL_REGEX.findall(raw)]

    if len(urls) == 0:
        input_type = "TEXT"
    elif len(urls) == 1 and raw == urls[0]:
        input_type = "URL"
    else:
        input_type = "MIXED"

    envelope.input_type = input_type
    envelope.query.urls_in_text = urls
    return envelope
```

---

### 4.4. Module `runTextNormalizer` (V3 Architecture)

**Mục đích:**

Token Preprocessor cho SLM (Stage 2) - Làm sạch và chuẩn hóa text theo kiến trúc V3:

- **Unicode Normalization (NFKC + unidecode)**: Chuẩn hóa ký tự, convert full-width → ASCII
- **URL Tokenization**: Thay thế URLs bằng tokens `{{URL_i}}` và lưu mapping
- **PII Masking**: Thay thế email/phone bằng placeholders `<EMAIL>`, `<PHONE>` và lưu mapping
- **Giữ nguyên Syntax**: Không lowercase, không xóa punctuation, không expand teencode

**Input:**

- `envelope.query.text_raw`

**Xử lý (Pipeline V3):**

#### Bước 1: Unicode Normalization (NFKC + unidecode)

```python
def normalize_unicode(raw: str) -> str:
    # 1. Unify newlines: \r\n, \r → \n
    # 2. Smart quotes → straight quotes
    # 3. Dash repair: –, — → -
    # 4. Remove BOM/zero-width characters
    # 5. Comprehensive whitespace normalization:
    #    - Non-breaking space (\u00A0) → space
    #    - Narrow NBSP (\u202F) → space
    #    - Ideographic space (\u3000) → space
    #    - Remove zero-width chars (\u200B-\u200D, \u2060, \uFEFF)
    # 6. Remove control characters (except \n, \t)
    # 7. Collapse multiple spaces/tabs
    # 8. NFKC normalization (thay vì NFC)
    # 9. unidecode: Convert full-width → ASCII
    #    Ví dụ: "Ｈｅｌｌｏ" → "Hello"
    return text.strip()
```

**Lý do NFKC:**
- Convert full-width characters (từ PDF/Word) về ASCII chuẩn
- Tối ưu số lượng token cho tokenizer của SLM
- Giữ lại "Cú pháp" (Syntax) chuẩn, không can thiệp "Ngữ nghĩa" (Semantics)

#### Bước 2: URL Protection (Tokenization)

```python
def protect_urls(text: str) -> Tuple[str, Dict[str, str], list]:
    """
    Phát hiện TẤT CẢ URLs trong text và thay thế bằng tokens.
    
    Regex hỗ trợ:
    - Domain thông thường: https://example.com
    - IPv4: http://192.168.1.1:8080
    - Localhost: http://localhost:3000
    """
    urls_map = {}
    urls_in_text = []
    
    def replacer(match):
        url = match.group(0)
        idx = len(urls_map) + 1
        token = f"{{{{URL_{idx}}}}}"  # {{URL_1}}, {{URL_2}}, ...
        urls_map[token] = url
        urls_in_text.append(url)
        return token
    
    protected_text = URL_REGEX.sub(replacer, text)
    return protected_text, urls_map, urls_in_text
```

**Ví dụ:**
```
Input:  "Visit https://example.com and https://google.com"
Output: "Visit {{URL_1}} and {{URL_2}}"
Mapping: {
    "{{URL_1}}": "https://example.com",
    "{{URL_2}}": "https://google.com"
}
```

#### Bước 3: PII Masking (Email & Phone)

```python
def redact_pii(text: str) -> Tuple[str, Dict[str, str], bool]:
    """
    Phát hiện TẤT CẢ emails và phones, thay thế bằng placeholders.
    
    Email regex: Chặt chẽ, validate TLD >= 2 ký tự, không match double dots
    Phone regex: Hỗ trợ cả VN (0987654321) và quốc tế (+1-201-555-0123)
    """
    pii_map = {}
    email_counter = 0
    phone_counter = 0
    
    def replace_email(match):
        email_counter += 1
        token = f"<EMAIL_{email_counter}>"
        pii_map[token] = match.group(0)
        return "<EMAIL>"  # Placeholder trong text
    
    def replace_phone(match):
        phone_counter += 1
        token = f"<PHONE_{phone_counter}>"
        pii_map[token] = match.group(0)
        return "<PHONE>"  # Placeholder trong text
    
    text = EMAIL_REGEX.sub(replace_email, text)
    text = PHONE_REGEX.sub(replace_phone, text)      # VN
    text = PHONE_REGEX_INTL.sub(replace_phone, text) # Quốc tế
    
    return text, pii_map, has_pii
```

**Ví dụ:**
```json
Input:  "Contact admin@company.com or call 0987654321"
Output: "Contact <EMAIL> or call <PHONE>"
Mapping: {
    "<EMAIL_1>": "admin@company.com",
    "<PHONE_1>": "0987654321"
}
```


#### Các bước ĐÃ LOẠI BỎ (V3 Architecture):

- ❌ **Teencode expansion**: SLM tự hiểu được, sửa sai bằng regex dễ làm sai ý nghĩa
- ❌ **Stopword removal**: Không cần thiết với architech mới
- ❌ **Money canonicalization**: Không cần thiết với architech mới
- ❌ **Language detection**: Không cần thiết (set `detected_lang = "unknown"`)
- ❌ **Aggressive lowercasing**: Giữ case cho named entities (Apple vs apple)
- ❌ **Punctuation removal**: Giữ dấu câu cho intent detection (?, !, ...)

**Output:**

- `query.text_normalized`: Text đã được normalize và token hóa
- `query.detected_lang`: Luôn `"unknown"` (backward compatibility)
- `query.urls_map`: Map `{{URL_i}}` → URL gốc
- `query.urls_in_text`: List URLs (backward compatibility)
- `query.pii_map`: Map `<EMAIL_i>`, `<PHONE_i>` → giá trị gốc
- `safety_flags.has_pii`: `True` nếu có PII được mask

**Code Implementation:**

```python
def runTextNormalizer(envelope: UnifiedInputCore) -> UnifiedInputCore:
    raw = envelope.query.text_raw or ""
    
    # Validate input length
    if len(raw) > MAX_RAW_INPUT_LENGTH:
        raise Stage1Error(f"Input exceeds max length {MAX_RAW_INPUT_LENGTH}")
    
    # 1. Unicode normalization (NFKC + unidecode)
    text = normalize_unicode(raw)
    
    # 2. URL tokenization
    text, urls_map, urls_in_text = protect_urls(text)
    
    # 3. PII masking
    text, pii_map, has_pii = redact_pii(text)
    
    # Update envelope
    envelope.query.text_normalized = text
    envelope.query.detected_lang = "unknown"  # V3: không detect
    envelope.query.urls_map = urls_map
    envelope.query.urls_in_text = urls_in_text
    envelope.query.pii_map = pii_map
    
    # Update safety_flags.has_pii (handle both dict and object)
    if hasattr(envelope, "safety_flags") and isinstance(envelope.safety_flags, dict):
        envelope.safety_flags["has_pii"] = has_pii
    elif envelope.safety_flags:
        envelope.safety_flags.has_pii = has_pii
    
    return envelope
```

---

### 4.5. Module `attachPageContext`

**Mục đích:**

- Chuyển `page_context` từ request (tab hiện tại) vào `UnifiedInputCore`.
    
- Để Stage 2 biết user đang đứng ở URL nào, tiêu đề gì, có bôi đen đoạn nào không.
    

**Input:**

- `RawRequest.page_context`
    

**Xử lý:**

- Simple copy (có thể là None).
    

**Output:**

- `envelope.page_context` được set.

```python
def attachPageContext(envelope: UnifiedInputCore, raw: RawRequest) -> UnifiedInputCore:
    envelope.page_context = raw.page_context
    return envelope
```

---

### 4.6. Module `buildTelemetry`

**Mục đích:**

- Ghi lại thời gian tổng và thời gian từng module, độ dài input.
    
- Giúp debug & tối ưu latency sau này.
    

**Input:**

- `total_ms`: thời gian pipeline (milliseconds)
    
- `modules_latency`: map `{ module_name: ms }` (camelCase keys: buildEnv, initEnvelope, inputClassifier, textNormalizer, pageContext)
    
- `envelope` (để lấy `raw_input_length`)
    

**Output:**

- `Telemetry` object.

```python
from ..api.schemas import Telemetry, UnifiedInputCore

def buildTelemetry(
    total_ms: float, 
    modules_latency: dict, 
    envelope: UnifiedInputCore
) -> Telemetry:
    
    return Telemetry(
        stage1_total_latency_ms=total_ms,
        modules=modules_latency,
        raw_input_length=len(envelope.query.text_raw)
    )
```

---

### 4.7. Module `computeSafetyFlags`

**Mục đích:**

- Đặt một số cờ kỹ thuật cơ bản để Stage 2/3 cẩn trọng:
    
    - Input quá dài → có thể phải tóm tắt trước.
        
    - Quá nhiều URL → có thể spam / cần rate limit.
        
    - Có PII → đã được mask trong text_normalized.
        

**Input:**

- `envelope.telemetry.raw_input_length`
    
- `envelope.query.urls_in_text`
    
- `envelope.safety_flags.has_pii` (đã được set bởi normalizer)
    

**Xử lý:**

- So sánh với ngưỡng config: `MAX_RAW_INPUT_LENGTH`, `MAX_URL_COUNT`.
    
- Giữ lại `has_pii` từ normalizer.
    
- Set `is_toxic = False` (placeholder).

**Output:**

- `SafetyFlags` object.

```python
from ..api.schemas import SafetyFlags, UnifiedInputCore
from ..core.constants import MAX_RAW_INPUT_LENGTH, MAX_URL_COUNT

def computeSafetyFlags(envelope: UnifiedInputCore) -> SafetyFlags:
    raw_len = (
        envelope.telemetry.raw_input_length
        if hasattr(envelope.telemetry, "raw_input_length")
        else envelope.telemetry.get("raw_input_length", 0)
    )

    has_pii = False
    if hasattr(envelope.safety_flags, "has_pii"):
        has_pii = envelope.safety_flags.has_pii
    elif isinstance(envelope.safety_flags, dict):
        has_pii = envelope.safety_flags.get("has_pii", False)

    flags = SafetyFlags(
        raw_input_too_long=raw_len > MAX_RAW_INPUT_LENGTH,
        too_many_urls=len(envelope.query.urls_in_text or []) > MAX_URL_COUNT,
        has_pii=has_pii,
        is_toxic=False,
    )

    return flags
```

---

## 5. End-to-end – ví dụ 3 case

_(Phần JSON Output giữ nguyên format vì đó là response chuẩn của API, không phụ thuộc ngôn ngữ backend)_

### 5.1. Case 1 – Text thuần (không có URL/PII)

Request:

HTTP

```
POST /v1/input/ingest
Content-Type: application/json
```

JSON

```json
{
  "raw_input": "Giúp tớ giải thích chỉ số P/E là gì?",
  "env_meta": {
    "user_id": "u1",
    "session_id": "s1",
    "timezone": "Asia/Bangkok",
    "locale": "vi-VN",
    "client": {
      "device": "desktop",
      "browser": "Chrome",
      "os": "Windows"
    }
  },
  "page_context": {
    "active_url": "https://vnexpress.net/...",
    "active_title": "Tin tức chứng khoán",
    "selection_text": null
  }
}
```

Output (rút gọn):

JSON

```json
{
  "input_id": "uuid-123",
  "received_at": "2025-12-07T11:11:11.000Z",
  "input_type": "TEXT",
  "query": {
    "text_raw": "Giúp tớ giải thích chỉ số P/E là gì?",
    "text_normalized": "Giúp tớ giải thích chỉ số P/E là gì?",
    "detected_lang": "unknown",
    "urls_in_text": [],
    "urls_map": {},
    "pii_map": {}
  },
  "input_hash": "a1b2c3d4e5f6...",
  "env": {
    "user_id": "u1",
    "session_id": "s1",
    "timezone": "Asia/Bangkok",
    "locale": "vi-VN",
    "client": {
      "device": "desktop",
      "browser": "Chrome",
      "os": "Windows"
    }
  },
  "page_context": {
    "active_url": "https://vnexpress.net/...",
    "active_title": "Tin tức chứng khoán",
    "selection_text": null
  },
  "url_context": null,
  "doc_context": null,
  "media_context": null,
  "telemetry": {
    "stage1_total_latency_ms": 4,
    "modules": {
      "buildEnv": 1,
      "initEnvelope": 0,
      "inputClassifier": 0,
      "textNormalizer": 1,
      "pageContext": 0
    },
    "raw_input_length": 41
  },
  "safety_flags": {
      "raw_input_too_long": false,
      "too_many_urls": false,
      "has_pii": false,
      "is_toxic": false
  }
}
```

---

### 5.2. Case 2 – Text có URLs và PII

**Request:**

```json
{
  "raw_input": "Visit https://example.com and contact admin@company.com or call 0987654321",
  "env_meta": {
    "user_id": "u1",
    "session_id": "s1"
  }
}
```

**Output:**

```json
{
  "input_id": "uuid-456",
  "input_hash": "sha256-hash-of-normalized-text...",
  "received_at": "2025-12-07T11:11:11.000Z",
  "input_type": "MIXED",
  "query": {
    "text_raw": "Visit https://example.com and contact admin@company.com or call 0987654321",
    "text_normalized": "Visit {{URL_1}} and contact <EMAIL> or call <PHONE>",
    "detected_lang": "unknown",
    "urls_in_text": ["https://example.com"],
    "urls_map": {
      "{{URL_1}}": "https://example.com"
    },
    "pii_map": {
      "<EMAIL_1>": "admin@company.com",
      "<PHONE_1>": "0987654321"
    }
  },
  "safety_flags": {
    "raw_input_too_long": false,
    "too_many_urls": false,
    "has_pii": true,
    "is_toxic": false
  }
}
```

**Giải thích quá trình xử lý:**

1. **Unicode Normalization**: Text không có ký tự đặc biệt, giữ nguyên
2. **URL Tokenization**: 
   - Phát hiện `https://example.com`
   - Thay thế bằng `{{URL_1}}`
   - Lưu mapping: `{{URL_1}}` → `https://example.com`
3. **PII Masking**:
   - Phát hiện email `admin@company.com` → thay bằng `<EMAIL>`, lưu `<EMAIL_1>` → `admin@company.com`
   - Phát hiện phone `0987654321` → thay bằng `<PHONE>`, lưu `<PHONE_1>` → `0987654321`
4. **Result**: `text_normalized` chứa tokens, giá trị gốc được lưu trong maps

---

### 5.3. Case 3 – Text với nhiều URLs và emails

**Request:**

```json
{
  "raw_input": "Check https://example.com, https://google.com and email admin@company.com, support@help.com"
}
```

**Output:**

```json
{
  "query": {
    "text_normalized": "Check {{URL_1}}, {{URL_2}} and email <EMAIL> <EMAIL>",
    "urls_in_text": ["https://example.com", "https://google.com"],
    "urls_map": {
      "{{URL_1}}": "https://example.com",
      "{{URL_2}}": "https://google.com"
    },
    "pii_map": {
      "<EMAIL_1>": "admin@company.com",
      "<EMAIL_2>": "support@help.com"
    }
  },
  "safety_flags": {
    "has_pii": true
  }
}
```

**Lưu ý:** 
- Nhiều URLs/emails được phát hiện và token hóa đúng
- Index tăng dần: `{{URL_1}}`, `{{URL_2}}`, `<EMAIL_1>`, `<EMAIL_2>`
- Mapping đầy đủ để có thể recover giá trị gốc

---

## 6. Chi tiết quá trình làm sạch dữ liệu

### 6.1. Unicode Normalization (NFKC + unidecode)

**Mục đích:** Chuẩn hóa ký tự Unicode về dạng chuẩn nhất cho tokenizer của SLM.

**Các bước:**

1. **Newline unification**: `\r\n`, `\r` → `\n`
2. **Quote normalization**: Smart quotes (`"`, `'`, `«`, `»`) → straight quotes (`"`, `'`)
3. **Dash repair**: Em dash (`—`), en dash (`–`) → hyphen (`-`)
4. **BOM/Zero-width removal**: 
   - BOM (`\ufeff`)
   - Zero-width characters (`\u200b-\u200f`, `\u2060`, `\uFEFF`)
5. **Whitespace normalization**:
   - Non-breaking space (`\u00A0`) → space
   - Narrow NBSP (`\u202F`) → space
   - Ideographic space (`\u3000`) → space
6. **Control characters**: Remove except `\n`, `\t`
7. **Space collapsing**: Multiple spaces/tabs → single space
8. **NFKC normalization**: Unicode Normalization Form Compatibility Composition
9. **Unidecode**: Convert full-width → ASCII
   - `Ｈｅｌｌｏ` → `Hello`
   - `ｃａｆé` → `cafe`

**Ví dụ:**

```python
Input:  "Ｈｅｌｌｏ　Ｗｏｒｌｄ" (full-width)
Output: "Hello World" (ASCII)
```

### 6.2. URL Tokenization

**Mục đích:** Bảo vệ URLs khỏi bị xử lý sai trong Stage 2, đồng thời giữ mapping để recover.

**Regex patterns hỗ trợ:**

- Domain: `https://example.com`, `http://www.example.com/path?query=1`
- IPv4: `http://192.168.1.1:8080/api`
- Localhost: `http://localhost:3000/dashboard`

**Quy trình:**

1. Tìm TẤT CẢ URLs trong text bằng `URL_REGEX`
2. Mỗi URL được thay thế bằng token `{{URL_i}}` (i = 1, 2, 3, ...)
3. Lưu mapping: `{{URL_i}}` → URL gốc vào `urls_map`
4. Lưu list URLs vào `urls_in_text` (backward compatibility)

**Ví dụ:**

```json
Input:  "Visit https://example.com and https://google.com"
Step 1: Phát hiện 2 URLs
Step 2: Thay thế:
        "https://example.com" → "{{URL_1}}"
        "https://google.com" → "{{URL_2}}"
Output: "Visit {{URL_1}} and {{URL_2}}"
Mapping: {
    "{{URL_1}}": "https://example.com",
    "{{URL_2}}": "https://google.com"
}
```

### 6.3. PII Masking (Email & Phone)

**Mục đích:** Bảo vệ thông tin nhạy cảm, nhưng giữ cấu trúc câu để SLM hiểu intent.

**Email Detection:**

- Regex chặt chẽ: `\b[a-zA-Z0-9][a-zA-Z0-9._%+-]*@[a-zA-Z0-9][a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b`
- Validate TLD >= 2 ký tự
- Không match: `abc@.com`, `a@b..com`

**Phone Detection:**

- VN: `\b(?:\+?84\s*|0)(?:\d[\s\.-]?){8,10}\b`
  - Hỗ trợ: `0987654321`, `+84 987 654 321`, `84987654321`
- Quốc tế: `\b\+?\d{1,3}(?:[\s\.-]?\d){7,14}\b`
  - Hỗ trợ: `+1-201-555-0123`, `+44 20 7946 0958`

**Quy trình:**

1. Tìm TẤT CẢ emails → thay bằng `<EMAIL>`, lưu `<EMAIL_i>` → email gốc
2. Tìm TẤT CẢ phones (VN + quốc tế) → thay bằng `<PHONE>`, lưu `<PHONE_i>` → phone gốc
3. Set `safety_flags.has_pii = True` nếu có PII

**Ví dụ:**

```json
Input:  "Contact admin@company.com or call 0987654321"
Step 1: Phát hiện email "admin@company.com"
        → Thay bằng "<EMAIL>"
        → Lưu "<EMAIL_1>" → "admin@company.com"
Step 2: Phát hiện phone "0987654321"
        → Thay bằng "<PHONE>"
        → Lưu "<PHONE_1>" → "0987654321"
Output: "Contact <EMAIL> or call <PHONE>"
Mapping: {
    "<EMAIL_1>": "admin@company.com",
    "<PHONE_1>": "0987654321"
}
```

### 6.4. Hash Computation (Deduplication)

**Mục đích:** Tạo semantic cache key để tránh xử lý trùng lặp.

**Algorithm:** SHA-256

**Input cho hash:**

```python
content = f"{user_id}:{text_normalized}:{model_version}:{system_prompt_version}"
hash = SHA256(content)
```

**Lý do bao gồm version:**

- Nếu System Prompt của SLM thay đổi, hash key sẽ thay đổi
- Cache tự động invalidate, tránh trả về kết quả cũ sai lệch

**Ví dụ:**

```python
user_id = "u1"
text_normalized = "Visit {{URL_1}} and contact <EMAIL>"
model_version = "v1.0"
prompt_version = "v1.0"

content = "u1:Visit {{URL_1}} and contact <EMAIL>:v1.0:v1.0"
input_hash = SHA256(content) = "a1b2c3d4e5f6..."
```

---

## 7. Tóm tắt Output Schema - Tất cả các trường

### 7.1. UnifiedInputCore (Root Level)

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `input_id` | `str` | ✅ | UUID uniquely identifying this input |
| `input_hash` | `str` | ✅ | SHA-256 hash of normalized text + user_id + model_version + prompt_version. Used for semantic caching and deduplication |
| `received_at` | `str` | ✅ | ISO-8601 UTC timestamp when request was received by Stage 1 |
| `input_type` | `Literal["TEXT", "URL", "MIXED"]` | ✅ | Classification: 'TEXT' (no URLs), 'URL' (only URL), 'MIXED' (text + URLs) |
| `query` | `Query` | ✅ | Processed query information (see Query schema below) |
| `env` | `Dict[str, Any]` | ✅ | Environment metadata as dictionary (user, session, locale, client info) |
| `page_context` | `Optional[PageContext]` | ❌ | Context about the web page user is currently viewing |
| `url_context` | `None` | ✅ | Placeholder for URL content (always None in Stage 1) |
| `doc_context` | `None` | ✅ | Placeholder for document content (always None in Stage 1) |
| `media_context` | `None` | ✅ | Placeholder for media content (always None in Stage 1) |
| `telemetry` | `Telemetry` | ✅ | Performance metrics and latency breakdown |
| `safety_flags` | `SafetyFlags` | ✅ | Safety and validation flags |

### 7.2. Query Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `text_raw` | `str` | ✅ | Original raw text input from user (unchanged, exactly as received) |
| `text_normalized` | `str` | ✅ | Normalized text after Unicode normalization (NFKC + unidecode), URL tokenization ({{URL_i}}), and PII masking (<EMAIL>, <PHONE>) |
| `detected_lang` | `str` | ✅ | Detected language: 'vi', 'en', or 'unknown'. Note: V3 architecture always sets to 'unknown' |
| `urls_in_text` | `List[str]` | ❌ | List of URLs extracted from text_raw (for backward compatibility) |
| `urls_map` | `Dict[str, str]` | ❌ | Map token {{URL_i}} → original URL. Example: `{'{{URL_1}}': 'https://example.com'}` |
| `pii_map` | `Dict[str, str]` | ❌ | Map token <EMAIL_i>/<PHONE_i> → original value. Example: `{'<EMAIL_1>': 'admin@company.com', '<PHONE_1>': '0987654321'}` |

### 7.3. EnvMeta Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `user_id` | `Optional[str]` | ❌ | Unique user identifier |
| `session_id` | `Optional[str]` | ❌ | Session identifier for tracking |
| `timezone` | `Optional[str]` | ❌ | Timezone string (IANA format), default: "Asia/Bangkok" |
| `locale` | `Optional[str]` | ❌ | Locale string (language-country format), default: "vi-VN" |
| `client` | `Optional[ClientMeta]` | ❌ | Client device and browser metadata (see ClientMeta schema) |

### 7.4. ClientMeta Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `device` | `Optional[str]` | ❌ | Device type (desktop, mobile, tablet) |
| `browser` | `Optional[str]` | ❌ | Browser name (Chrome, Firefox, etc.) |
| `os` | `Optional[str]` | ❌ | Operating system (Windows, macOS, Linux, iOS, Android) |
| `location` | `Optional[ClientLocation]` | ❌ | Geographic location of client (see ClientLocation schema) |
| `local_time` | `Optional[str]` | ❌ | ISO 8601 timestamp of client local time |

### 7.5. ClientLocation Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `latitude` | `Optional[float]` | ❌ | Latitude coordinate |
| `longitude` | `Optional[float]` | ❌ | Longitude coordinate |
| `city` | `Optional[str]` | ❌ | City name |
| `country` | `Optional[str]` | ❌ | Country name |

### 7.6. PageContext Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `active_url` | `Optional[str]` | ❌ | URL of the active browser tab |
| `active_title` | `Optional[str]` | ❌ | Title of the active browser tab |
| `selection_text` | `Optional[str]` | ❌ | Text currently selected/highlighted by user |

### 7.7. Telemetry Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `stage1_total_latency_ms` | `float` | ✅ | Total latency of Stage 1 pipeline in milliseconds |
| `modules` | `Dict[str, float]` | ✅ | Latency breakdown per module in milliseconds. Example: `{'build_env': 1.5, 'text_normalizer': 2.3}` |
| `raw_input_length` | `int` | ✅ | Character length of raw_input |

### 7.8. SafetyFlags Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `raw_input_too_long` | `Optional[bool]` | ❌ | True if raw_input exceeds MAX_RAW_INPUT_LENGTH threshold (default: false) |
| `too_many_urls` | `Optional[bool]` | ❌ | True if number of URLs exceeds MAX_URL_COUNT threshold (default: false) |
| `has_pii` | `bool` | ✅ | True if email/phone detected and masked in text_normalized (default: false) |
| `is_toxic` | `bool` | ✅ | Placeholder for future toxicity detection (always False in Stage 1) |

---

## 8. Checklist triển khai

1. Implement endpoint `POST /v1/input/ingest` (FastAPI/Flask/Django).
    
2. Implement 7 module:
    
    - `buildEnv` (trả về Dict, không phải EnvMeta object)
        
    - `initEnvelope`
        
    - `runInputClassifier`
        
    - `runTextNormalizer`
        
    - `attachPageContext`
        
    - `buildTelemetry`
        
    - `computeSafetyFlags`
        
3. Đảm bảo output luôn đúng shape `UnifiedInputCore`, **không fetch HTML**.
    
4. Unit test 3 nhóm case:
    
    - Text.
        
    - URL.
        
    - Mixed.
        
5. Log tối thiểu: `input_id`, `input_type`, `raw_input_length`, `stage1_total_latency_ms`.