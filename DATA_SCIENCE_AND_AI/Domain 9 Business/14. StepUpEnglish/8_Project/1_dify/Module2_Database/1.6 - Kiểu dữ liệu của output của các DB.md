# Report: V·∫•n ƒë·ªÅ JSON Formatting gi·ªØa MySQL, PostgreSQL v√† orjson

## üîç **Gi·∫£i th√≠ch ƒë∆°n gi·∫£n v·∫•n ƒë·ªÅ:**

### **MySQL JSON Handling:**

```python
# MySQL tr·∫£ v·ªÅ JSON d·∫°ng string
cursor.execute("SELECT json_column FROM table")
result = cursor.fetchone()[0]
# result = '{"name": "value", "id": "123"}'  ‚Üê STRING FORMAT
parsed = json.loads(result)  # Manual parsing needed
```

### **PostgreSQL JSON Handling:**

```python
# PostgreSQL tr·∫£ v·ªÅ parsed object
cursor.execute("SELECT json_column FROM table")
result = cursor.fetchone()[0]
# result = {1: "value", 2: "value"}  ‚Üê OBJECT v·ªõi NUMERIC KEYS
# Kh√¥ng c·∫ßn json.loads()
```

### **orjson Requirements:**

```python
# ‚úÖ orjson ch·∫•p nh·∫≠n
{"name": "value", "id": "123"}  # String keys only

# ‚ùå orjson t·ª´ ch·ªëi  
{1: "value", 2: "value"}        # Numeric keys
# TypeError: Dict key must be str
```

---

## üéØ **V·∫•n ƒë·ªÅ n·∫±m ·ªü ƒë√¢u:**

**Data Flow Problem:**

```
PostgreSQL ‚Üí JSON object {1: "val"} ‚Üí orjson.dumps() ‚Üí ‚ùå ERROR
MySQL ‚Üí JSON string ‚Üí json.loads() ‚Üí orjson.dumps() ‚Üí ‚úÖ OK
```

**Error Location:**

- File: `v2_session_store.py` line 44
- Function: `orjson.dumps(payload)`
- Error: `TypeError: Dict key must be str`

---

## üîç **Nguy√™n nh√¢n:**

1. **PostgreSQL native JSON type** t·ª± ƒë·ªông parse ‚Üí t·∫°o **numeric keys**
2. **MySQL JSON as text** ‚Üí manual parse ‚Üí c√≥ th·ªÉ control key format
3. **orjson strict validation** ‚Üí ch·ªâ ch·∫•p nh·∫≠n **string keys**
4. **Missing data normalization** ·ªü boundary gi·ªØa database v√† serialization

---

## üí° **Gi·∫£i ph√°p:**

### **Approach 1: Database Layer Fix**

```python
# postgres_bot.py
def parsing_json(self, json_data):
    if isinstance(json_data, dict):
        # Convert numeric keys to strings
        return {str(k): v for k, v in json_data.items()}
    return json_data
```

### **Approach 2: Serialization Layer Fix** ‚≠ê **Recommended**

```python
# v2_session_store.py
def normalize_keys_for_orjson(obj):
    """Recursively convert all dict keys to strings"""
    if isinstance(obj, dict):
        return {str(k): normalize_keys_for_orjson(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [normalize_keys_for_orjson(item) for item in obj]
    return obj

async def set_session(redis_client, conversation_id: str, payload: dict):
    try:
        normalized = normalize_keys_for_orjson(payload)
        data = orjson.dumps(normalized).decode('utf-8')
        await redis_client.set(conversation_id, data)
    except Exception as e:
        # Fallback to standard json
        data = json.dumps(payload, ensure_ascii=False)
        await redis_client.set(conversation_id, data)
```

### **Approach 3: Hybrid Solution**

```python
# config.py
USE_ORJSON = True

# utils/json_handler.py
def safe_json_dumps(data):
    if USE_ORJSON:
        try:
            normalized = normalize_keys_for_orjson(data)
            return orjson.dumps(normalized).decode('utf-8')
        except:
            pass
    return json.dumps(data, ensure_ascii=False)
```

---

## üìä **So s√°nh Database JSON Formats:**

|Database|JSON Storage|Return Type|Key Types|orjson Compatible|
|---|---|---|---|---|
|**MySQL**|TEXT/JSON|String|Manual control|‚úÖ (after parse)|
|**PostgreSQL**|JSON/JSONB|Object|Auto-typed|‚ùå (needs normalization)|

---

## üèÜ **Recommended Action:**

**Immediate Fix:**

```python
# Add to v2_session_store.py
def ensure_string_keys(obj):
    if isinstance(obj, dict):
        return {str(k): ensure_string_keys(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [ensure_string_keys(item) for item in obj]
    return obj

# Before orjson.dumps()
payload = ensure_string_keys(payload)
```

**Root Cause:** PostgreSQL returns JSON with typed keys, orjson requires string keys  
**Solution:** Key normalization before serialization  
**Impact:** Minimal performance overhead, maximum compatibility