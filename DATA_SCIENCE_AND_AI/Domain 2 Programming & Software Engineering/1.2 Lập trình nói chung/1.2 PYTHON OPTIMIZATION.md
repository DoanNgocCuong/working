### Hình dung chung khi chạy bằng `docker-compose`

Giả sử bạn có stack kiểu:

- `app` (LLM / service chính) → gọi sang  
- `robot-ai-tool` (container hiện tại, có `ToolPhoneme`) → gọi sang  
- `phoneme-service` (container khác, có API `PHONEME_URL`)

Container `robot-ai-tool` sẽ chạy lâu dài (long‑running process), bên trong có nhiều lần gọi `phoneme_similarity()`.

---

### 1. Cách CŨ (mỗi lần gọi tạo mới `ClientSession`)

Trong container `robot-ai-tool`, với **mỗi lần** bạn gọi `phoneme_similarity(text_1, text_2)`:

1. `phoneme_similarity` gọi:
   ```python
   asyncio.gather(
       self.process(text_1),
       self.process(text_2),
   )
   ```
2. Mỗi `process(...)` lại:
   ```python
   async with aiohttp.ClientSession() as session:
       await session.post(self.url, ...)
       # xong là session bị close
   ```

Với `docker-compose`:

- Container `robot-ai-tool` **sống lâu**, nhưng **mỗi request** từ `app` vào lại:
  - Tạo mới 2 `ClientSession` (1 cho `text_1`, 1 cho `text_2`)
  - Mỗi session lại mở kết nối TCP mới tới container `phoneme-service`, TLS handshake, sau đó đóng luôn.
- Nếu bạn so sánh N cặp câu:
  - **2N lần tạo/đóng session**, rất phí:
    - Nhiều socket connect/disconnect
    - TLS handshake lặp lại
    - Tăng CPU cả 2 container (client + server)

---

### 2. Cách MỚI (dùng lại `ClientSession` trong cùng container)

Trong container `robot-ai-tool`:

- Khi khởi tạo `ToolPhoneme`:
  - `self._session = None`
- Lần ĐẦU gọi `process()` (dù từ `phoneme_similarity` hay chỗ khác):
  - `_get_session()` thấy `self._session` là `None` → tạo **1 `ClientSession`**:
    ```python
    self._session = aiohttp.ClientSession(timeout=...)
    ```
- Các lần SAU trong cùng process/container:
  - `_get_session()` thấy `self._session` **đã tồn tại và chưa closed** → **dùng lại**.
- `phoneme_similarity()` gọi:
  ```python
  asyncio.gather(
      self._get_phoneme_response(text_1),
      self._get_phoneme_response(text_2),
  )
  ```
  → cả 2 `process()` bên dưới đều dùng **cùng một session**.

Trong bối cảnh `docker-compose`:

- Container `robot-ai-tool` chạy lâu:
  - Thường chỉ có **1 session duy nhất** (hoặc rất ít, nếu bạn chủ động `close()`).
  - Mọi request từ `app` vào đều **reuse session** này, tái sử dụng:
    - TCP connection pool
    - TLS handshake
- Nếu bạn so sánh N cặp câu:
  - Vẫn là **2N request HTTP**, nhưng:
    - **1 session** (thay vì 2N session),
    - Nhiều request sẽ reuse **cùng kết nối TCP** → giảm latency, giảm CPU.

---

### 3. Tác động thực tế khi chạy bằng `docker-compose`

- **Trước tối ưu:**
  - Mỗi API call từ `app` → `robot-ai-tool`:
    - Container `robot-ai-tool` tạo/đóng 2 session.
    - Container `phoneme-service` nhận nhiều kết nối chớp nhoáng, chi phí handshakes cao.
  - Khi load cao (nhiều user, nhiều câu), response time **tăng nhanh**, CPU server tăng.

- **Sau tối ưu:**
  - Container `robot-ai-tool` giữ 1 `ClientSession` lâu dài:
    - Reuse socket, ít handshake.
  - Với cùng số lượng user:
    - Thời gian xử lý mỗi request ngắn hơn (ít overhead kết nối),
    - Tải trên `phoneme-service` đều hơn, ít tốn CPU cho kết nối lại.

---

Nếu bạn mô tả cụ thể hơn flow trong `docker-compose` (ví dụ: service nào gọi `ToolPhoneme`, khởi tạo `ToolPhoneme` 1 lần hay nhiều lần), mình có thể gợi ý thêm: nên khởi tạo `ToolPhoneme` ở level nào (singleton, per-request, per-session) để tận dụng tối đa việc reuse `ClientSession`.



---

# Câu hỏi: 1. Cơ chế nào để bạn giữ kết nối khi khởi tạo đoạn đấy mà không bị đóng + 2. Cơ chế nào để bạn cache được kết quả trước, và khi nó phìng to ra thì sao ?
