```
def detect_candoiketoan(text: str, threshold: float = 0.8) -> bool:

    """

    Phát hiện xem văn bản có chứa "bảng cân đối kế toán" hay không.

    Logic:

    1. Loại bỏ tất cả các bảng markdown khỏi văn bản (chỉ check trong text thông thường)

    2. Lowercase toàn bộ văn bản

    3. Loại bỏ dấu tiếng Việt

    4. So khớp fuzzy 80% với "bang can doi ke toan"

    Lưu ý:

        Hàm này KHÔNG tìm kiếm trong các bảng markdown, chỉ tìm trong phần text thông thường.

        Điều này giúp tránh false positive khi các từ khóa xuất hiện trong dữ liệu bảng.

    Args:

        text (str): Văn bản cần kiểm tra

        threshold (float): Ngưỡng so khớp (mặc định: 0.8 = 80%)

    Returns:

        bool: True nếu tìm thấy "bảng cân đối kế toán", False nếu không

    Ví dụ:

        >>> detect_candoiketoan("BẢNG CÂN ĐỐI KẾ TOÁN")  # True

        >>> detect_candoiketoan("BANG CAN DOI KE TOAN")   # True

        >>> detect_candoiketoan("Không có gì")            # False

    """

    # Bước 1: Loại bỏ tất cả các bảng markdown (chỉ check trong text thông thường)

    text_without_tables = _remove_markdown_tables(text)

    # Bước 2: Lowercase và loại bỏ dấu

    text_lower = text_without_tables.lower()

    text_khong_dau = remove_diacritics(text_lower)

    # Pattern chuẩn để so khớp

    pattern = "can doi ke toan"

    # List of words in text không dấu

    words = text_khong_dau.split()

    # List of words in pattern

    pattern_words = pattern.split()

    # Kiểm tra nếu pattern xuất hiện trực tiếp trong text không dấu

    if pattern in text_khong_dau:

        return True

    # Lấy cụm từ cùng độ dài với pattern từ text (4 từ)

    # Dịch chuyển dần từ đầu đến cuối text

    # So sánh từng cụm với pattern bằng SequenceMatcher

    # Nếu tìm thấy cụm giống >= threshold → return True

    for i in range(len(words) - len(pattern_words) + 1):

        candidate = ' '.join(words[i:i+len(pattern_words)])

        similarity = SequenceMatcher(None, pattern, candidate).ratio()

        if similarity >= threshold:

            return True

  

    return False
```


---

## Cần 1 thuật toán tối ưu hơn: 


Phân tích ưu/nhược điểm của hai cách:


[2 tools called]


Phân tích ưu/nhược điểm của hai cách:


[5 tools called]


## So sánh 2 cách

### 1. So sánh trực tiếp (hiện tại)

Ví dụ:
```python
text_compact = "daylabangcandoiketoancuacongty"  # 30 ký tự
reference = "candoiketoan"  # 15 ký tự
score = ratio(reference, text_compact)  # ~0.5 (50%) ❌
```

Vấn đề:
- Pattern chỉ là một phần nhỏ của text
- So sánh toàn bộ text với pattern ngắn → score thấp
- Không tìm được pattern nằm giữa text

Ưu điểm:
- Đơn giản, nhanh (1 lần so sánh)
- Ít code

Nhược điểm:
- Chỉ hoạt động tốt khi pattern chiếm phần lớn text
- Không tìm được pattern ở giữa text dài

---

### 2. Sliding window (cách cũ)

Ví dụ:
```python
text_compact = "daylabangcandoiketoancuacongty"
reference = "candoiketoan"

# Sliding window tìm cụm 15 ký tự:
"daylabangcandoi" → score = 0.6
"ylabangcandoik" → score = 0.7
"bangcandoiketo" → score = 0.9
"candoiketoancu" → score = 1.0 ✅ (exact match!)
```

Ưu điểm:
- Tìm được pattern ở bất kỳ đâu trong text
- Chính xác hơn
- Linh hoạt với text dài

Nhược điểm:
- Phức tạp hơn (nhiều lần so sánh)
- Chậm hơn một chút, nhưng với text ngắn (sau khi loại bỏ bảng) thì không đáng kể

---

## Kết luận: Sliding window phù hợp hơn

Lý do:
1. Pattern ngắn: "candoiketoan" (15 ký tự) so với text có thể dài (30–100+ ký tự)
2. Pattern nằm giữa text: "Đây là BẢNG CÂN ĐỐI KẾ TOÁN của công ty"
3. Text sau khi loại bỏ bảng thường không quá dài → hiệu năng chấp nhận được

Khuyến nghị: Quay lại dùng sliding window, nhưng tối ưu hơn (chỉ tìm cụm có độ dài tương tự reference, không cần thử nhiều độ dài).

Bạn có muốn tôi cập nhật lại code với sliding window đã tối ưu không?


```
"""

Module phát hiện "Bảng Cân Đối Kế Toán" và chuyển đổi bảng sang Excel.

  

MÔ TẢ:

-------

Module này thực hiện 3 bước đơn giản:

1. Phát hiện "bảng cân đối kế toán" trong văn bản (fuzzy matching 80%)

    Logic:

    2. Lowercase toàn bộ văn bản

    3. Loại bỏ dấu tiếng Việt

    4. So khớp fuzzy 80% với "bang can doi ke toan"

5. Trích xuất tất cả các bảng markdown từ văn bản

6. Chuyển đổi các bảng sang file Excel (.xlsx)

  

CHỨC NĂNG:

----------

- detect_candoiketoan(): Phát hiện "bảng cân đối kế toán" (fuzzy 80%)

- process_markdown_file_to_xlsx(): Xử lý file markdown và chuyển đổi sang Excel

  

YÊU CẦU:

--------

- pandas: Để xử lý dữ liệu và tạo Excel

- openpyxl: Để ghi file Excel (.xlsx)

  

CÀI ĐẶT:

---------

    pip install pandas openpyxl

"""

  

import re

from difflib import SequenceMatcher

from pathlib import Path

from typing import Optional

  

# Import functions from utils_markdownTable_to_xlsx

from utils_markdownTable_to_xlsx import (

    markdownTable_to_xlsx,

    extract_markdown_tables,

    remove_diacritics,

    _parse_markdown_table,

    _create_dataframe_from_rows,

    _is_separator_line

)

  
  

def _create_compact(text: str) -> str:

    """

    Tạo phiên bản compact của text: lowercase, loại bỏ dấu, loại bỏ khoảng trắng và ký tự đặc biệt.

    Chỉ giữ lại các chữ cái (a-z).

    Thuật toán:

    - Lowercase text

    - Loại bỏ dấu tiếng Việt

    - Loại bỏ tất cả khoảng trắng và ký tự đặc biệt

    - Chỉ giữ lại chữ cái (a-z)

    Args:

        text (str): Văn bản cần compact hóa

    Returns:

        str: Text đã được compact (chỉ chữ cái, không dấu, không khoảng trắng)

    Ví dụ:

        >>> _create_compact("BẢNG CÂN ĐỐI KẾ TOÁN")

        'bangcandoiketoan'

        >>> _create_compact("BANG CAN DOI KE TOAN")

        'bangcandoiketoan'

    """

    # Lowercase và loại bỏ dấu

    text_lower = text.lower()

    text_khong_dau = remove_diacritics(text_lower)

    # Loại bỏ tất cả khoảng trắng và ký tự đặc biệt, chỉ giữ chữ cái

    compact = re.sub(r'[^a-z]', '', text_khong_dau)

    return compact

  
  

def _remove_markdown_tables(text: str) -> str:

    """

    Loại bỏ tất cả các bảng markdown khỏi văn bản, chỉ giữ lại phần text thông thường.

    Hàm này giúp tránh false positive khi check các từ khóa trong bảng markdown.

    Ví dụ: Tránh match các từ khóa trong bảng với pattern của báo cáo tài chính.

    Args:

        text (str): Văn bản chứa các bảng markdown

    Returns:

        str: Văn bản đã loại bỏ các bảng markdown

    """

    lines = text.split('\n')

    result_lines = []

    in_table = False

    for line in lines:

        stripped = line.strip()

        # Check if line is part of a table

        if stripped.startswith('|'):

            # Check if it's a separator line

            if _is_separator_line(stripped):

                # Skip separator line

                in_table = True

                continue

            # This is a table row, skip it

            in_table = True

            continue

        else:

            # End of table or regular text

            in_table = False

            result_lines.append(line)

    return '\n'.join(result_lines)

  
  

def detect_candoiketoan(text: str, threshold: float = 0.8) -> bool:

    """

    Phát hiện xem văn bản có chứa "bảng cân đối kế toán" hay không.

    Logic sử dụng thuật toán: score = ratio(compact, REFERENCE)

    1. Loại bỏ tất cả các bảng markdown khỏi văn bản (chỉ check trong text thông thường)

    2. Tạo compact version của text: lowercase, loại bỏ dấu, loại bỏ khoảng trắng, chỉ giữ chữ cái

    3. Tạo compact version của pattern REFERENCE: "candoiketoan"

    4. Kiểm tra exact match: nếu reference xuất hiện trực tiếp trong compact text

    5. So khớp fuzzy theo character-level: sử dụng sliding window để tìm pattern ở bất kỳ đâu trong text

    6. Tính score = ratio(candidate, REFERENCE) và so sánh với threshold (mặc định 0.8 = 80%)

    Thuật toán ratio(candidate, REFERENCE) với sliding window:

    - `candidate`: Cụm từ trong text_compact có độ dài bằng reference (tìm bằng sliding window)

    - `REFERENCE`: Pattern chuẩn đã compact hóa (ví dụ: "candoiketoan")

    - `ratio()`: Sử dụng hàm có sẵn SequenceMatcher.ratio() từ difflib (Python standard library)

    - SequenceMatcher.ratio() trả về 0.0 - 1.0 (tương đương 0% - 100%)

    - Sliding window: Dịch chuyển cửa sổ qua text để tìm pattern ở bất kỳ đâu

    Lưu ý:

        Hàm này KHÔNG tìm kiếm trong các bảng markdown, chỉ tìm trong phần text thông thường.

        Điều này giúp tránh false positive khi các từ khóa xuất hiện trong dữ liệu bảng.

    Args:

        text (str): Văn bản cần kiểm tra

        threshold (float): Ngưỡng so khớp (mặc định: 0.8 = 80%)

    Returns:

        bool: True nếu tìm thấy "bảng cân đối kế toán", False nếu không

    Ví dụ:

        >>> detect_candoiketoan("BẢNG CÂN ĐỐI KẾ TOÁN")  # True

        >>> detect_candoiketoan("BANG CAN DOI KE TOAN")   # True

        >>> detect_candoiketoan("Không có gì")            # False

    """

    # Bước 1: Loại bỏ tất cả các bảng markdown (chỉ check trong text thông thường)

    text_without_tables = _remove_markdown_tables(text)

    # Bước 2: Tạo compact version của text

    text_compact = _create_compact(text_without_tables)

    # Bước 3: Pattern REFERENCE đã compact hóa

    # Pattern gốc: "can doi ke toan" → Compact: "candoiketoan"

    reference_pattern = "can doi ke toan"

    reference_compact = _create_compact(reference_pattern)

    # Bước 4: Kiểm tra nếu reference xuất hiện trực tiếp trong compact text (exact match)

    if reference_compact in text_compact:

        return True

    # Bước 5: So khớp fuzzy theo character-level - sử dụng sliding window

    # Sử dụng thuật toán: score = ratio(candidate, REFERENCE)

    #

    # Sử dụng hàm có sẵn: SequenceMatcher.ratio() từ difflib (Python standard library)

    # - ratio() trả về giá trị 0.0 - 1.0 (tương đương 0% - 100%)

    # - Không cần chia 100 vì ratio() đã trả về 0-1

    #

    # Sliding window: Dịch chuyển cửa sổ qua text_compact để tìm cụm có độ dài bằng reference

    # Ví dụ:

    #   text_compact = "daylabangcandoiketoancuacongty"

    #   reference = "candoiketoan"

    #   Tìm cụm 15 ký tự trong text và so sánh với reference

    ref_len = len(reference_compact)

    text_len = len(text_compact)

    # Nếu text ngắn hơn reference, không thể match

    if text_len < ref_len:

        return False

    # Dịch chuyển cửa sổ (sliding window) qua text_compact

    # Tìm cụm có độ dài bằng reference_compact và tính similarity score

    for i in range(text_len - ref_len + 1):

        candidate_compact = text_compact[i:i + ref_len]

        # Sử dụng hàm có sẵn: SequenceMatcher.ratio() từ difflib

        score = SequenceMatcher(None, reference_compact, candidate_compact).ratio()

        if score >= threshold:

            return True

    return False

  
  

def process_markdown_file_to_xlsx(

    input_file: str,

    output_file: Optional[str] = None,

    detect_balance_sheet: bool = True,

    multiple_sheets: bool = True

) -> str:

    """

    Xử lý file markdown: phát hiện bảng cân đối kế toán, trích xuất bảng và chuyển đổi sang Excel.

    Quy trình:

    1. Đọc file markdown

    2. Phát hiện "bảng cân đối kế toán" (nếu detect_balance_sheet=True)

    3. Trích xuất tất cả các bảng markdown

    4. Chuyển đổi sang file Excel

    Args:

        input_file (str): Đường dẫn đến file markdown đầu vào

        output_file (Optional[str]): Đường dẫn đến file Excel đầu ra (tùy chọn).

                                    Nếu None, tự động tạo tên file dựa trên input_file

        detect_balance_sheet (bool): Nếu True, chỉ xử lý nếu phát hiện "bảng cân đối kế toán".

                                     Nếu False, xử lý tất cả các bảng trong file

        multiple_sheets (bool): Nếu True, đặt tất cả bảng vào một file với nhiều sheets.

                                Nếu False, tạo file riêng cho mỗi bảng

    Returns:

        str: Đường dẫn đến file Excel đã tạo

    Raises:

        FileNotFoundError: Nếu file đầu vào không tồn tại

        ValueError: Nếu không phát hiện bảng cân đối kế toán (khi detect_balance_sheet=True)

                   hoặc không tìm thấy bảng markdown nào trong file

    """

    input_path = Path(input_file)

    if not input_path.exists():

        raise FileNotFoundError(f"Input file not found: {input_file}")

    # Bước 1: Đọc file

    print(f"Reading file: {input_file}")

    with open(input_path, 'r', encoding='utf-8') as f:

        content = f.read()

    # Bước 2: Phát hiện "bảng cân đối kế toán" (nếu cần)

    if detect_balance_sheet:

        print("Detecting 'Bang Can Doi Ke Toan'...")

        if not detect_candoiketoan(content):

            raise ValueError(

                "File does not contain 'Bang Can Doi Ke Toan'. "

                "Set detect_balance_sheet=False to process anyway."

            )

        print("Balance sheet detected!")

    # Bước 3: Trích xuất tất cả các bảng markdown

    print("Extracting markdown tables...")

    tables = extract_markdown_tables(content)

    print(f"  Found {len(tables)} table(s)")

    if not tables:

        raise ValueError("No markdown tables found in file")

    # Bước 4: Chuyển đổi sang Excel

    if output_file is None:

        output_file = str(input_path.parent / f"{input_path.stem}_CanDoiKeToan.xlsx")

    print(f"Converting to Excel: {output_file}")

    if multiple_sheets:

        # Tạo một file Excel với nhiều sheets

        try:

            import pandas as pd

        except ImportError:

            raise ImportError("pandas is required. Install with: pip install pandas openpyxl")

        output_path = Path(output_file)

        output_path.parent.mkdir(parents=True, exist_ok=True)

        with pd.ExcelWriter(str(output_path), engine='openpyxl') as writer:

            for idx, table_text in enumerate(tables, 1):

                # Parse table

                rows = _parse_markdown_table(table_text)

                if not rows or len(rows) < 2:

                    continue

                # Create DataFrame

                df = _create_dataframe_from_rows(rows)

                # Sheet name (Excel has 31 char limit)

                sheet_name = f"Bang_{idx}"[:31]

                # Write to sheet

                df.to_excel(writer, sheet_name=sheet_name, index=False)

        result_path = str(output_path)

    else:

        # Tạo file riêng cho mỗi bảng

        output_files = []

        base_path = Path(output_file).parent / Path(output_file).stem

        for idx, table_text in enumerate(tables, 1):

            table_output_path = f"{base_path}_table_{idx}.xlsx"

            markdownTable_to_xlsx(

                table_text,

                output_path=table_output_path,

                sheet_name="Bang"

            )

            output_files.append(table_output_path)

        result_path = output_files[0] if output_files else output_file

    print(f"Successfully saved to: {result_path}")

    return result_path

  
  

def main():

    """

    Hàm chính để xử lý file markdown và chuyển đổi bảng sang Excel.

    """

    input_file = Path(__file__).parent / "Example2_MarkdownCanDoiKeToan.md"

    try:

        result_path = process_markdown_file_to_xlsx(

            input_file=str(input_file),

            detect_balance_sheet=True,

            multiple_sheets=True

        )

        print(f"\nDone! Output file: {result_path}")

    except Exception as e:

        print(f"Error: {e}")

        raise

  
  

if __name__ == "__main__":

    main()
```


---
Thuật toán ban đầu: 
    1. Loại bỏ tất cả các bảng markdown khỏi văn bản (chỉ check trong text thông thường)
    2. Lowercase toàn bộ văn bản
    3. Loại bỏ dấu tiếng Việt
    4. So khớp fuzzy 80% với "bang can doi ke toan"


THUẬT TOÁN MỚI: 

    1. Loại bỏ tất cả các bảng markdown khỏi văn bản (chỉ check trong text thông thường)
    2. Tạo compact version của text: lowercase, loại bỏ dấu, loại bỏ khoảng trắng, chỉ giữ chữ cái
    3. Tạo compact version của pattern REFERENCE: "candoiketoan"
    4. Kiểm tra exact match: nếu reference xuất hiện trực tiếp trong compact text
    5. So khớp fuzzy theo character-level: sử dụng sliding window để tìm pattern ở bất kỳ đâu trong text
    6. Tính score = ratio(candidate, REFERENCE) và so sánh với threshold (mặc định 0.8 = 80%)
    