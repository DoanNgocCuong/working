Các bug memory kiểu bạn gặp có thể chia MECE thành 4 nhóm lớn: leak, bloat, churn và fragmentation; mỗi nhóm có pattern, triệu chứng và root cause khác nhau.nelhage+1​

## 1. Memory leak (rò rỉ bộ nhớ)

- Định nghĩa: Bộ nhớ không còn cần nhưng không được giải phóng, làm RSS/heap tăng dần mãi theo thời gian, không về baseline sau mỗi batch/request.linkedin+1​
    
- Ví dụ trong backend:
    
    - Cache/in-memory map không có TTL/limit nên cứ “phình” dần.huhshal.substack+1​
        
    - Giữ reference conversation_log hoặc message cũ trong global list, long-lived singleton, event listener… nên GC không thu hồi được.droidcon+1​
        

## 2. Memory bloat (dùng quá nhiều, nhưng “hợp lệ”)

- Định nghĩa: Ứng dụng dùng nhiều RAM hơn mức cần thiết để làm cùng một công việc, do thiết kế dữ liệu/luồng xử lý kém tối ưu (nhưng không hẳn là leak).axissoftwaredynamics+1​
    
- Ví dụ trong processing chain:
    
    - conversation_log pass qua nhiều layer, clone/deep copy nhiều lần → mỗi request tạo nhiều bản copy nặng (history, payload, metadata…) → khi concurrent cao thì tổng RAM phình to.ucla+1​
        
    - Parse large payload rồi giữ lại full object / full log trong suốt chain, dù từng bước chỉ cần một phần nhỏ.axissoftwaredynamics+1​
        

## 3. Memory churn (allocate/free quá dày)

- Định nghĩa: Tần suất tạo và giải phóng object/bộ nhớ rất cao (đặc biệt với short-lived objects), khiến heap “sôi” liên tục, GC/allocator chạy nhiều, dù tổng RAM trung bình không hẳn tăng.dynatrace+1​
    
- Ví dụ poison message > 1MB:
    
    - Consumer parse → fail → NACK + requeue → xử lý lại vô hạn; mỗi lần lại allocate buffer + object parse lớn rồi free.dzone+1​
        
    - Kết quả: CPU tăng vì GC/alloc, spike memory lặp đi lặp lại, latency jitter; không phải leak nhưng là pattern rất tốn tài nguyên.dynatrace+1​
        

## 4. Memory fragmentation & allocator issues

- Định nghĩa: Bộ nhớ bị chia nhỏ thành nhiều mảnh lẻ, khó tìm được block liên tục đủ lớn; tổng free memory còn nhưng không dùng được hiệu quả, làm process “trông như” đang thiếu RAM.arxiv+1​
    
- Cause:
    
    - Nhiều allocation/free với kích thước khác nhau, xen kẽ thời gian sống khác nhau.stackoverflow+1​
        
    - Allocator/GC không trả memory lại OS hoặc chỉ thu hồi nội bộ, làm RSS không giảm dù GC đã chạy.nelhage+1​
        

## Bảng phân loại bug memory

|Nhóm bug|Triệu chứng chính|Nguyên nhân điển hình trong case của bạn|
|---|---|---|
|Memory leak|RAM tăng dần, không giảm giữa các batch/requests [linkedin](https://www.linkedin.com/pulse/understanding-memory-leaks-related-attacks-simple-guide-khanna-tv5cc)​|Giữ reference conversation_log, cache không giới hạn huhshal.substack+1​|
|Memory bloat|RAM ổn định ở mức rất cao, nhiều copy/struct dư thừa [axissoftwaredynamics](https://axissoftwaredynamics.com/memory-bloat-vs-memory-leak-understanding-the-culprits-of-memory-woes/)​|conversation_log copy qua nhiều layer, giữ full payload lâu book.scoutapm+1​|
|Memory churn|GC/alloc chạy dày, CPU cao, spike lặp lại dynatrace+1​|Poison messages > 1MB bị retry vô hạn, mỗi lần parse lại từ đầu dzone+1​|
|Fragmentation|Khó allocate block lớn dù tổng free còn arxiv+1​|Nhiều allocation size khác nhau, lifetime khác nhau, mix buffer lớn/nhỏ stackoverflow+1​|

Nếu muốn, có thể đi tiếp 1 layer nữa: MECE theo “nguồn gốc” trong hệ thống messaging của bạn (transport layer, parsing layer, logging/conversation layer, caching layer) để map thành checklist review cụ thể cho code/rabbitmq_consumer.py.

1. [https://blog.nelhage.com/post/three-kinds-of-leaks/](https://blog.nelhage.com/post/three-kinds-of-leaks/)
2. [https://axissoftwaredynamics.com/memory-bloat-vs-memory-leak-understanding-the-culprits-of-memory-woes/](https://axissoftwaredynamics.com/memory-bloat-vs-memory-leak-understanding-the-culprits-of-memory-woes/)
3. [https://www.linkedin.com/pulse/understanding-memory-leaks-related-attacks-simple-guide-khanna-tv5cc](https://www.linkedin.com/pulse/understanding-memory-leaks-related-attacks-simple-guide-khanna-tv5cc)
4. [https://dev.to/gpiechnik/what-are-memory-leaks-257d](https://dev.to/gpiechnik/what-are-memory-leaks-257d)
5. [https://huhshal.substack.com/p/real-life-memory-leaks-in-backend](https://huhshal.substack.com/p/real-life-memory-leaks-in-backend)
6. [https://www.dynatrace.com/resources/ebooks/javabook/excessive-memory-use/](https://www.dynatrace.com/resources/ebooks/javabook/excessive-memory-use/)
7. [https://www.droidcon.com/2023/06/28/understanding-memory-leaks/](https://www.droidcon.com/2023/06/28/understanding-memory-leaks/)
8. [https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/](https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/)
9. [https://book.scoutapm.com/memory-bloat.html](https://book.scoutapm.com/memory-bloat.html)
10. [https://web.cs.ucla.edu/~harryxu/papers/nguyen-tosem18.pdf](https://web.cs.ucla.edu/~harryxu/papers/nguyen-tosem18.pdf)
11. [https://www.dynatrace.com/resources/ebooks/javabook/other-java-memory-issues/](https://www.dynatrace.com/resources/ebooks/javabook/other-java-memory-issues/)
12. [https://stackoverflow.com/questions/8686223/reducing-memory-churn-when-processing-large-data-set](https://stackoverflow.com/questions/8686223/reducing-memory-churn-when-processing-large-data-set)
13. [https://dzone.com/articles/rabbitmq-consumer-retry-mechanism](https://dzone.com/articles/rabbitmq-consumer-retry-mechanism)
14. [https://www.infobip.com/blog/rabbitmq-message-processing-and-retry-logic](https://www.infobip.com/blog/rabbitmq-message-processing-and-retry-logic)
15. [https://www.dynatrace.com/news/blog/radically-speed-up-your-code-by-fixing-slow-or-frequent-garbage-collection/](https://www.dynatrace.com/news/blog/radically-speed-up-your-code-by-fixing-slow-or-frequent-garbage-collection/)
16. [https://arxiv.org/html/2401.03523v1](https://arxiv.org/html/2401.03523v1)
17. [https://runtimerec.com/understanding-memory-leaks-in-embedded-systems-and-how-to-prevent-them/](https://runtimerec.com/understanding-memory-leaks-in-embedded-systems-and-how-to-prevent-them/)
18. [https://stackoverflow.com/questions/70602043/avoid-memory-fragmentation-when-memory-pools-are-a-bad-idea](https://stackoverflow.com/questions/70602043/avoid-memory-fragmentation-when-memory-pools-are-a-bad-idea)
19. [https://developer.android.com/games/engines/unity/unity-lmks](https://developer.android.com/games/engines/unity/unity-lmks)
20. [https://www.perplexity.ai/search/mece-toan-bo-cach-de-trien-kha-VQf3b1G_S9WrNCLk53euKQ](https://www.perplexity.ai/search/mece-toan-bo-cach-de-trien-kha-VQf3b1G_S9WrNCLk53euKQ)
21. [https://www.softwareverify.com/blog/the-nineteen-types-of-memory-leak/](https://www.softwareverify.com/blog/the-nineteen-types-of-memory-leak/)
22. [https://github.com/docker/for-win/issues/14367](https://github.com/docker/for-win/issues/14367)
23. [https://cyfuture.cloud/kb/database/what-causes-high-memory-usage-on-the-server](https://cyfuture.cloud/kb/database/what-causes-high-memory-usage-on-the-server)
24. [https://www.scisemi.com/resources/article-memory-safety-bugs/](https://www.scisemi.com/resources/article-memory-safety-bugs/)
25. [https://techdocs.f5.com/kb/en-us/products/big-ip_ltm/releasenotes/related/relnote-supplement-bigip-16-1-6-1.html](https://techdocs.f5.com/kb/en-us/products/big-ip_ltm/releasenotes/related/relnote-supplement-bigip-16-1-6-1.html)
26. [https://youtrack.jetbrains.com/articles/SUPPORT-A-478/Troubleshooting-of-high-memory-usage-by-JetBrains-Rider-backend-process](https://youtrack.jetbrains.com/articles/SUPPORT-A-478/Troubleshooting-of-high-memory-usage-by-JetBrains-Rider-backend-process)
27. [https://www.code-intelligence.com/blog/memory_safety_corruption](https://www.code-intelligence.com/blog/memory_safety_corruption)