
```
Tôi cần cung cấp các lệnh để check process/service nào đang sử dụng port 9403 và từ đó xác định thư mục làm việc của process đó.

Các lệnh phổ biến:

- Linux/Mac: `lsof`, `netstat`, `ss`, `fuser`
- Windows: `netstat`, `Get-Process`
```

---
# check port server 

`netstat -tlnp | grep -E "30011|30012"`

`ps aux | grep "main.py --start_situation 1 --end_situation 111000000956"`

```
ps -ef | grep "utils_genLessonDetail1000Nghe_22082025_v2/main.py"

ps -ef | grep "02092025_non_work.xlsx"
```
# 2. Dọn docker đã dừng 


```bash
# Xóa các networks không sử dụng 
docker network prune 
# Hoặc xóa toàn bộ các resources không sử dụng 
docker system prune -a
```

Tôi sẽ giúp bạn dừng port 30005 đang bị conflict. Hãy kiểm tra và dừng container/process đang sử dụng port này:
Read file: CKP_v1/tuning/deploy.sh
Bây giờ tôi sẽ hướng dẫn bạn các lệnh để dừng port 30005:

**Các lệnh để dừng port 30005:**

**1. Kiểm tra container Docker đang chạy:**
```bash
docker ps
```

**2. Dừng container đang sử dụng port 30005:**
```bash
docker stop $(docker ps -q --filter "publish=30005")
```

**3. Hoặc dừng tất cả container:**
```bash
docker stop $(docker ps -q)
```

**4. Xóa container nếu cần:**
```bash
docker rm $(docker ps -aq --filter "publish=30005")
```

I see why this still happens.

- Docker re-creates the `docker-proxy` when your container starts.
- If another container already published port 3000, your new one will fail even after you kill the PIDs.
- You must stop/remove the container(s) that are using 3000, not just kill the proxy.

### Find and remove the container using 3000
```bash
# Show containers that publish port 3000 (IPv4 or IPv6)
docker ps --format '{{.ID}} {{.Names}} {{.Ports}}' | grep -E '0\.0\.0\.0:3000|:::3000'

# Stop and remove them (replace <ID> with result above)
docker stop <ID>
docker rm <ID>
```

One-liner:
```bash
CID=$(docker ps --format '{{.ID}} {{.Ports}}' | awk '/0\.0\.0\.0:3000|:::3000/ {print $1}'); \
[ -n "$CID" ] && docker stop $CID && docker rm $CID || echo "No container on 3000"
```

### Clean current project and retry
```bash
# From your project folder
docker compose down
docker compose up --build -d
```


### 5. Trên window
```bash
PS D:\GIT\robot-lesson-workflow> netstat -ano | findstr :30000
  TCP    127.0.0.1:30000        0.0.0.0:0              LISTENING       7172
  TCP    127.0.0.1:30000        127.0.0.1:54350        FIN_WAIT_2      7172
  TCP    127.0.0.1:30000        127.0.0.1:54456        TIME_WAIT       0
  TCP    127.0.0.1:30000        127.0.0.1:54698        TIME_WAIT       0
  TCP    127.0.0.1:30000        127.0.0.1:55963        ESTABLISHED     7172
  TCP    127.0.0.1:30000        127.0.0.1:61565        ESTABLISHED     7172
  TCP    127.0.0.1:54350        127.0.0.1:30000        CLOSE_WAIT      2628
  TCP    127.0.0.1:55963        127.0.0.1:30000        ESTABLISHED     2628
  TCP    127.0.0.1:61565        127.0.0.1:30000        ESTABLISHED     2628
PS D:\GIT\robot-lesson-workflow> taskkill /PID 7172 /F
SUCCESS: The process with PID 7172 has been terminated.
PS D:\GIT\robot-lesson-workflow> 

```
### **5. Kiểm tra process nào đang sử dụng port 30005:**
```bash
	sudo lsof -i :30005
```
( "Super User Do - List Open Files - Internet connections on port 30005" (Dùng quyền admin để liệt kê process nào đang sử dụng port 30005))
**6. Kill process theo PID (nếu có):**
```bash
sudo kill -9 <PID>
```

**7. Hoặc kill tất cả process trên port 30005:**
```bash
sudo fuser -k 30005/tcp
```

**Lệnh tổng hợp để clear port 30005:**
```bash
# Dừng container Docker
docker stop $(docker ps -q --filter "publish=30005") 2>/dev/null || true

# Kill process trên port
sudo fuser -k 30005/tcp 2>/dev/null || true

# Kiểm tra port đã free chưa
sudo lsof -i :30005
```

**Sau khi dừng port, bạn có thể chạy lại:**
```bash
./deploy.sh
```

**Lưu ý:** Tôi thấy trong file `deploy.sh` có lỗi syntax ở dòng 16 (`--api-key hoailb-vllm \` thiếu dấu `\` ở cuối dòng 15).



# thế giờ làm sao để biết vị trí của file nơi port 30001 đang chiếm đóng


```
find . -name "docker-compose*.yml" -o -name "docker-compose*.yaml" | xargs grep -l "30001"
```


## Kiểm tra process vllm 

```bash
# 1. Kiểm tra tất cả process VLLM đang chạy

ps aux | grep -i "vllm\|EngineCore" | grep -v grep

  

# 2. Kiểm tra process Python liên quan đến VLLM

ps aux | grep python | grep -i vllm | grep -v grep

  

# 3. Kiểm tra process trên các port VLLM thường dùng

sudo lsof -i :30010

sudo lsof -i :8000

sudo lsof -i :30005

  

# 4. Kiểm tra process theo tên cụ thể

pgrep -f "vllm serve"

pgrep -f "EngineCore"

  

# 5. Xem chi tiết process VLLM (nếu có)

ps aux | grep "vllm serve" | grep -v grep

  

# 6. Kiểm tra qua nvidia-smi (xem process nào đang dùng GPU)

nvidia-smi --query-compute-apps=pid,process_name,used_memory --format=csv

  

# 7. Kiểm tra các script khởi động có đang chạy không

ps aux | grep "start_vllm" | grep -v grep

  

# 8. Kiểm tra Docker containers (nếu dùng Docker)

docker ps | grep vllm

docker ps -a | grep vllm
```