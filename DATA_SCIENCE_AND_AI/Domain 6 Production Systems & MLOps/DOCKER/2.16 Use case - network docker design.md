### Thực Trạng Network

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  Network 1: context-handling-service_context_handling_network   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Subnet: 10.3.0.0/24                                    │    │
│  │  ┌─────────────────┐                                    │    │
│  │  │ API             │                                    │    │
│  │  │ IP: 10.3.0.2    │                                    │    │
│  │  └─────────────────┘                                    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  Network 2: context-handling-worker_context_handling_network    │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  Subnet: 10.6.0.0/24                                    │    │
│  │  ┌─────────────────┐                                    │    │
│  │  │ Worker          │                                    │    │
│  │  │ IP: 10.6.0.2    │                                    │    │
│  │  └─────────────────┘                                    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  ❌ 2 networks ISOLATED - không thể ping/curl trực tiếp        │
└─────────────────────────────────────────────────────────────────┘
```

### Tại Sao Vẫn "Hoạt Động"?

Từ code grep, tôi thấy **API và Worker KHÔNG gọi trực tiếp nhau**. Chúng giao tiếp qua **shared services**:

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  ┌─────────┐                              ┌──────────┐          │
│  │   API   │                              │  Worker  │          │
│  │ 10.3.x  │                              │  10.6.x  │          │
│  └────┬────┘                              └────┬─────┘          │
│       │                                        │                │
│       │    ┌──────────────────────────────┐    │                │
│       └───►│  External Services (Host)    │◄───┘                │
│            │                              │                     │
│            │  • RabbitMQ (message queue)  │                     │
│            │  • PostgreSQL (database)     │                     │
│            │  • Redis (cache)             │                     │
│            │  • Memory API (103.253.20.30:6699)                 │
│            └──────────────────────────────┘                     │
│                                                                 │
│  ✅ Giao tiếp GIÁN TIẾP qua shared services                    │
└─────────────────────────────────────────────────────────────────┘
```

---

# MECE về network ?

Để đảm bảo tính **MECE** (Mutually Exclusive - Không trùng lặp, Collectively Exhaustive - Không bỏ sót) cho các phương pháp triển khai Network trong Docker Compose, tôi sẽ phân tách vấn đề theo **3 Chiều (Dimensions)** chính.

---

## Chiều 1: Phân loại theo Quyền Quản Lý & Vòng Đời (Lifecycle & Ownership)

_Câu hỏi cốt lõi: Ai là người tạo ra và kiểm soát network này?_

## 1. Implicit Management (Mặc định)

- **Mô tả:** Bạn không khai báo gì cả. Docker Compose tự động tạo một network `default` (driver: bridge) khi chạy `up` và xóa khi `down`.
- **Đặc điểm:** Tên network thường là `<project_name>_default`.
- **Use case:** Hello World, Quick POC, Scripts đơn giản.

## 2. Explicit Management (Khai báo Tường minh)

- **Mô tả:** Bạn định nghĩa rõ block `networks:` trong file YAML nhưng không dùng `external: true`. Compose vẫn quản lý vòng đời (tạo/xóa), nhưng bạn kiểm soát thông số (subnet, driver).
- **Đặc điểm:** Isolated, Custom Driver, Custom Config.
- **Use case:** Production Standard (như mô hình Hybrid đã bàn), Cô lập Database, chia Tier (Frontend/Backend).

## 3. External Management (Khai báo Ngoài)

- **Mô tả:** Network đã tồn tại trước khi chạy Compose (`docker network create`). Bạn dùng `external: true`.
- **Đặc điểm:** Compose chỉ "join" vào, không có quyền xóa hay sửa config của network.
- **Use case:** Chia sẻ giữa nhiều project (Microservices), kết nối với Reverse Proxy (Traefik/Nginx), Shared Infrastructure.

---

## Chiều 2: Phân loại theo Cơ chế Vận chuyển (Driver Technology)

_Câu hỏi cốt lõi: Gói tin (Packet) di chuyển như thế nào?_

## 1. Bridge (Cầu nối - Standard)

- **Cơ chế:** Tạo một switch ảo (software bridge) trên host. Container có IP riêng trong subnet ảo, giao tiếp ra ngoài qua NAT.
- **Cách dùng:** `driver: bridge`.
- **Ưu điểm:** Cô lập tốt (Isolation), Port mapping linh hoạt.
- **Nhược điểm:** Tốn một chút overhead do NAT.
- **Best Practice:** Mặc định cho hầu hết các Web App, DB.

## 2. Host (Chạy trần - Performance)

- **Cơ chế:** Loại bỏ lớp network isolation. Container dùng chung IP và Port với máy Host.
- **Cách dùng:** `driver: host` hoặc `network_mode: host`.
- **Ưu điểm:** Hiệu năng cao nhất (Zero latency), không cần NAT.
- **Nhược điểm:** Rủi ro bảo mật (Container chiếm quyền port host), xung đột port nếu chạy nhiều replica.
- **Best Practice:** **AI Training/Inference** (để tối ưu I/O với GPU), các ứng dụng cần xử lý lượng packet cực lớn.

## 3. None (Không mạng - Security)

- **Cơ chế:** Container có stack network loopback (localhost) nhưng không có card mạng ra ngoài.
- **Cách dùng:** `driver: none` hoặc `network_mode: none`.
- **Ưu điểm:** Bảo mật tuyệt đối (Air-gapped).
- **Best Practice:** Các job xử lý dữ liệu nhạy cảm (Private Key generation), Batch job tính toán thuần túy không cần internet.

## 4. Service / Container (Sidecar Pattern)

- **Cơ chế:** Một container dùng chung namespace network của một container khác.
- **Cách dùng:** `network_mode: service:<tên_service>`.
- **Ưu điểm:** 2 container giao tiếp qua `localhost`.
- **Best Practice:** Monitoring Agent (Datadog), Log collector, hoặc Debugging tool gắn vào service chính.

## 5. Macvlan / IPvlan (Direct Hardware - Legacy/Specialized)

- **Cơ chế:** Cấp cho container một MAC address vật lý riêng, container xuất hiện như một thiết bị vật lý trên mạng LAN của cty.
- **Cách dùng:** `driver: macvlan`.
- **Best Practice:** Ứng dụng Legacy cần IP tĩnh thật, Monitor mạng cấp thấp, tích hợp vào hạ tầng mạng doanh nghiệp (VPN, VLAN).

---

## Chiều 3: Phân loại theo Cấu trúc Định danh & Kết nối (Configuration)

_Câu hỏi cốt lõi: Các service tìm thấy nhau như thế nào?_

## 1. Dynamic IP (DNS Discovery)

- **Cách triển khai:** Mặc định. Docker cung cấp DNS Server nội bộ. Gọi nhau bằng tên service (`db`, `redis`).
- **Tính chất:** IP thay đổi mỗi lần restart.
- **Đánh giá:** Chuẩn mực cho Cloud Native.

## 2. Static IP (Cố định - Anti-pattern in Cloud)

- **Cách triển khai:** Khai báo `ipv4_address: 172.16.238.10` trong service config.
- **Tính chất:** Hard-code địa chỉ IP.
- **Đánh giá:** Nên tránh. Chỉ dùng khi tích hợp với các hệ thống Legacy ngu ngốc không hỗ trợ DNS.

## 3. Aliases (Biệt danh)

- **Cách triển khai:** `aliases: ["database-primary", "db-prod"]`.
- **Tính chất:** Một service có nhiều tên miền nội bộ.
- **Đánh giá:** Hữu ích khi migration hoặc A/B testing (chuyển hướng traffic mà không đổi code app).


---

# Đánh giá thực trạng network

Dựa trên mô hình **MECE** mà chúng ta đã thiết lập và **Thực trạng Network** bạn cung cấp, tôi sẽ phân tích hệ thống của bạn đang nằm ở đâu trong bản đồ này, tại sao nó vẫn chạy ổn, và làm thế nào để tối ưu hóa nó theo chuẩn Production.

Đây là bản **Assessment Report** (Báo cáo đánh giá) cho kiến trúc hiện tại của bạn:

***

### 1. Định vị hệ thống hiện tại trong khung MECE

Dựa vào log `context-handling-service_...` và `context-handling-worker_...`, hệ thống của bạn đang nằm ở các tọa độ sau:


| Chiều (Dimension) | Trạng thái hiện tại | Phân tích chi tiết |
| :-- | :-- | :-- |
| **1. Lifecycle** | **Implicit Management** (Mặc định) | Bạn đang chạy 2 file `docker-compose.yml` riêng biệt. Mỗi lần `up`, Docker tự tạo một mạng riêng (`_default`) cho mỗi project. Đó là lý do tên mạng có tiền tố thư mục và chúng bị cô lập. |
| **2. Driver** | **Bridge** | Subnet `10.3.x` và `10.6.x` là dấu hiệu của Driver Bridge mặc định. Giao tiếp đi qua NAT. |
| **3. Config** | **Static / Host Routing** | Vì 2 container không thấy nhau qua DNS (do khác mạng), bạn đang buộc chúng giao tiếp "đi đường vòng" qua các **External Services** (RabbitMQ, Postgres) nằm trên Host hoặc một Server cố định. |


***

### 2. Tại sao mô hình này vẫn "Hoạt động"? (The Hidden Architecture)

Bạn đang sử dụng mô hình **Event-Driven Architecture (Kiến trúc hướng sự kiện)** thay vì **Direct RPC (Gọi trực tiếp)**.

Trong mô hình MECE, đây là một trường hợp thú vị:

* **Về mặt Network (Lớp 3/4 OSI):** Hệ thống bị **Partitioned** (Chia cắt). API không thể ping Worker.
* **Về mặt Application (Lớp 7 OSI):** Hệ thống vẫn **Connected** (Kết nối) thông qua một "người trung gian" (Middleman/Broker).

**Sơ đồ luồng dữ liệu thực tế:**

1. **API** (Mạng A) -> Gửi Job vào **RabbitMQ** (Nằm ngoài, IP Host).
2. **Worker** (Mạng B) -> Lắng nghe **RabbitMQ** (Nằm ngoài, IP Host).
3. **Kết quả:** API và Worker không cần biết sự tồn tại của nhau, chỉ cần biết RabbitMQ.

**✅ Ưu điểm:**

* **Decoupling cực cao:** Worker có thể sập, API vẫn nhận request (và ngược lại).
* **Scalability:** Bạn có thể bật 10 Worker ở 10 server khác nhau, miễn là cùng kết nối vào RabbitMQ.

**❌ Nhược điểm (Rủi ro hiện hữu):**

* **Phụ thuộc vào IP cứng:** Bạn có thể đang config IP RabbitMQ là `103.253.20.30` hoặc `host.docker.internal`. Nếu IP này đổi, hệ thống sập.
* **Không thể Monitoring trực tiếp:** Prometheus (nếu cài ở mạng API) sẽ không thể scrape metrics của Worker (ở mạng Worker).
* **Khó Debug:** Không thể `exec` vào API để `curl` kiểm tra sức khỏe của Worker.

***

### 3. Giải pháp Tối ưu hóa (Mapping về MECE chuẩn)

Để chuyển hệ thống từ trạng thái "Chạy được" sang "Production Ready" (Dễ quản lý, bảo mật, linh hoạt), bạn nên di chuyển sang mô hình **External Management + Hybrid**.

#### Mục tiêu:

Giữ nguyên tính Decoupling của RabbitMQ, nhưng **gộp Network** để quản trị dễ hơn (DNS Discovery, Metrics gathering).

#### Bước 1: Tạo Shared Network (Lifecycle: External)

Thay vì để Docker tự tạo 2 mạng riêng lẻ, hãy tạo một mạng chung cho toàn bộ hệ sinh thái "Context Handling".

```bash
# Admin chạy lệnh này 1 lần duy nhất
docker network create context_shared_net
```


#### Bước 2: Cập nhật Docker Compose (Lifecycle: External + Config: Dynamic IP)

**File: `api-service/docker-compose.yml`**

```yaml
services:
  api:
    image: context-api
    networks:
      - context_shared_net # <--- Join mạng chung
    environment:
      # Giờ đây có thể gọi các service khác bằng tên container thay vì IP Host
      - RABBITMQ_HOST=rabbitmq 
      - DB_HOST=postgres

networks:
  context_shared_net:
    external: true # <--- Khai báo dùng mạng ngoài
```

**File: `worker-service/docker-compose.yml`**

```yaml
services:
  worker:
    image: context-worker
    networks:
      - context_shared_net # <--- Join cùng mạng với API
    environment:
      - RABBITMQ_HOST=rabbitmq

networks:
  context_shared_net:
    external: true
```


#### Bước 3: Đưa Infrastructure vào cùng mạng (Optional nhưng Recommended)

Nếu RabbitMQ/Postgres cũng chạy bằng Docker, hãy đưa nó vào `context_shared_net`.

***


# Đánh giá network 


### Scenario Analysis: RabbitMQ Ở Đâu?
```
┌─────────────────────────────────────────────────────────────────┐
│                    SCENARIO A: External RabbitMQ                │
│                    (Đang dùng - có vẻ như vậy)                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │              External Services (Host/Cloud)             │   │
│   │  ┌──────────┐  ┌──────────┐  ┌──────────┐               │   │
│   │  │ RabbitMQ │  │ Postgres │  │  Redis   │               │   │
│   │  │ :5672    │  │  :5432   │  │  :6379   │               │   │
│   │  └────▲─────┘  └────▲─────┘  └────▲─────┘               │   │
│   └───────┼─────────────┼─────────────┼─────────────────────┘   │
│           │             │             │                         │
│   ┌───────┴─────────────┴─────────────┴─────────────────────┐   │
│   │                  Docker Containers                      │   │
│   │  ┌─────────┐              ┌──────────┐                  │   │
│   │  │   API   │              │  Worker  │                  │   │
│   │  │ 10.3.x  │              │  10.6.x  │                  │   │
│   │  └─────────┘              └──────────┘                  │   │
│   │  (Network A)              (Network B)                   │   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   ✅ Hoạt động được vì connect qua HOST IP (103.253.20.30)      │
│   ⚠️ Nhưng API <-> Worker không direct call được                │
└─────────────────────────────────────────────────────────────────┘
```
```
┌─────────────────────────────────────────────────────────────────┐
│                 SCENARIO B: Containerized RabbitMQ              │
│                 (Best Practice cho Self-contained)              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐   │
│   │              Shared Network (10.10.0.0/24)              │   │
│   │                                                         │   │
│   │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐  │   │
│   │  │ RabbitMQ │  │  MinIO   │  │   API    │  │ Worker  │  │   │
│   │  │  :5672   │  │  :9000   │  │  :30020  │  │         │  │   │
│   │  └──────────┘  └──────────┘  └──────────┘  └─────────┘  │   │
│   │                                                         │   │
│   │  Gọi nhau bằng DNS: rabbitmq:5672, minio:9000, api:30020│   │
│   └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│   ✅ Tất cả services giao tiếp trực tiếp qua internal DNS       │
│   ✅ Isolated, portable, reproducible                           │
└─────────────────────────────────────────────────────────────────┘


````


#### Pattern 3: Hybrid (Recommended cho Production của bạn)
```
┌─────────────────────────────────────────────────────────────────┐
│                      HYBRID PATTERN                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   EXTERNAL (Managed/Shared)        INTERNAL (Containerized)     │
│   ┌─────────────────────┐          ┌─────────────────────┐      │
│   │ • RabbitMQ (shared) │          │ • MinIO (new)       │      │
│   │ • PostgreSQL        │          │ • API               │      │
│   │ • Redis             │          │ • Worker            │      │
│   └─────────────────────┘          └─────────────────────┘      │
│            ▲                                 │                  │
│            │                                 │                  │
│            └─────────── Connect via ─────────┘                  │
│                      HOST_IP:PORT                               │
│                                                                 │
│   Internal services: Connect via DNS (minio:9000)               │
└─────────────────────────────────────────────────────────────────┘

Hoặc best practices 

┌─────────────────────────────────────────────────────────────────┐
│                      HYBRID PATTERN                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   INFA (Managed/Shared)        INTERNAL (Containerized)     │
│   ┌─────────────────────┐          ┌─────────────────────┐      │
│   │ • RabbitMQ (shared) │          │ •      │      │
│   │ • PostgreSQL        │          │ • API               │      │
│   │ • Redis
       MinIO (new)  
             │          │ • Worker            │      │
│   └─────────────────────┘          └─────────────────────┘      │
│            ▲                                 │                  │
│            │                                 │                  │
│            └─────────── Connect via ─────────┘                  │
│                      HOST_IP:PORT                               │
│                                                                 │
│   Internal services: Connect via DNS (minio:9000)               │
└─────────────────────────────────────────────────────────────────┘
```

---

## Tên pattern tổng thể

- **Hybrid application / Hybrid IT architecture**: Một ứng dụng hoặc hệ thống kết hợp cả tài nguyên on-premise, cloud managed service và workload containerized.[](https://www.databank.com/resources/blogs/securing-microservices-architecture-in-a-hybrid-it-landscape/)​
    

## Hai phần chính

- **Infra managed/external**
    
    - Thành phần: PostgreSQL/MySQL, Redis, RabbitMQ/Kafka, MinIO/S3, Elasticsearch, v.v.
        
    - Đặc điểm:
        
        - Do cloud/platform/service bên ngoài quản lý (RDS, Cloud SQL, managed RabbitMQ, managed Redis…).[](https://www.databank.com/resources/blogs/securing-microservices-architecture-in-a-hybrid-it-landscape/)​
            
        - Được expose qua IP/DNS + port, hoặc private network/VPC peering.
            
- **Application containerized**
    
    - Thành phần: API, worker, scheduler/cron, gateway, background jobs.[](https://microservices.io/patterns/microservices.html)​
        
    - Đặc điểm:
        
        - Đóng gói trong Docker/Kubernetes (Compose, K8s deployment).
            
        - Nói chuyện nội bộ với nhau qua service DNS (Docker network/K8s Service) và nói chuyện với infra managed qua endpoint external.[](https://docs.docker.com/compose/how-tos/networking/)​
            

Nếu muốn đặt tên ngắn để dùng trong tài liệu team, có thể gọi cả cụm này là:

> **Hybrid app with externalized infrastructure**.