* Trước: Transaction mở trong suốt 10-60s khi gọi Memory API → idle in transaction leak
* Sau: Commit mark_processing() trước khi gọi Memory API → Không còn idle in transaction leak


## Luồng hiện tại 

```bash
┌─────────────────────────────────────────────────────────────────┐
│ TIMELINE: Xử lý 1 message                                       │
└─────────────────────────────────────────────────────────────────┘

T=0s:    db = SessionLocal()
         → Transaction tự động mở (autocommit=False)
         → Connection state: active

T=0.1s:  event = repo.get_by_conversation_id(conversation_id)
         → SELECT conversation_events WHERE id = ...
         → Query xong, transaction vẫn mở
         → Connection state: idle in transaction ⚠️

T=0.2s:  conversation_log = ... (từ S3/message/DB)
         → Transaction vẫn mở
         → Connection state: idle in transaction ⚠️

T=0.3s:  processor = ConversationEventProcessingService(db=db, ...)
         → Setup services
         → Transaction vẫn mở
         → Connection state: idle in transaction ⚠️

T=0.4s:  processor.process_single_event_with_log(...)
         → mark_processing(event)  # Update status, chưa commit
         → Transaction vẫn mở
         → Connection state: idle in transaction ⚠️

T=0.5s:  calculate_score_from_conversation_log(...)
         → Gọi Memory API (pika-mem0:6699/extract_facts)
         → ❌ Transaction vẫn mở trong suốt 10-60s!
         → Connection state: idle in transaction ⚠️⚠️⚠️

T=1s:    Memory API đang chạy...
         → Connection state: idle in transaction (1s) ⚠️

T=5s:    Memory API đang chạy...
         → Connection state: idle in transaction (5s) ⚠️

T=15s:   Memory API đang chạy...
         → Connection state: idle in transaction (15s) ⚠️
         → Đây là vấn đề bạn thấy trong pg_stat_activity!

T=30s:   Memory API đang chạy...
         → Connection state: idle in transaction (30s) ⚠️

T=60s:   Memory API timeout hoặc xong
         → Connection state: idle in transaction (60s) ⚠️

T=60.1s: mark_processed() hoặc mark_failed()
         → db.commit() hoặc db.rollback()
         → Transaction đóng
         → Connection state: idle ✅

T=60.2s: finally block: db.close()
         → Connection được release về pool
         → Connection state: closed ✅

─────────────────────────────────────────────────────────────────
VẤN ĐỀ:
- Transaction mở trong suốt 10-60s (khi gọi Memory API)
- Connection ở trạng thái "idle in transaction" → Leak!
- Nhiều messages chạy song song → Nhiều connections leak
- Tích lũy → 105 connections → "too many clients already"
```

## Timeline Cách 3: Khi nào đánh dấu PROCESSED?

```
┌─────────────────────────────────────────────────────────────────┐
│ TIMELINE: Xử lý 1 message                                       │
└─────────────────────────────────────────────────────────────────┘

T=0s:    db = SessionLocal()
         → Transaction mở

T=0.1s:  event = repo.get_by_conversation_id(...)
         → Query event từ DB
         → event.status = "PENDING" (hoặc "FAILED" nếu retry)

T=0.2s:  conversation_log = ... (từ S3/message/DB)

T=0.3s:  processor = ConversationEventProcessingService(db=db, ...)

T=0.4s:  processor.process_single_event_with_log(...)
         → mark_processing(event)  # Line 330
         → event.status = "PROCESSING"  # ✅ Đánh dấu đang xử lý
         → ✅ FIX: db.commit() ngay sau mark_processing()
         → Transaction commit → status = "PROCESSING" đã lưu vào DB ✅
         → Connection state: idle (transaction đã commit)

T=0.5s:  calculate_score_from_conversation_log(...)
         → Gọi Memory API (pika-mem0:6699/extract_facts)
         → ✅ Không có transaction mở
         → Connection state: N/A (không dùng DB)

T=1s:    Memory API đang chạy...
         → event.status = "PROCESSING" (đã lưu trong DB)
         → Connection state: N/A ✅

T=15s:   Memory API đang chạy...
         → event.status = "PROCESSING" (đã lưu trong DB)
         → Connection state: N/A ✅

T=30s:   Memory API đang chạy...
         → event.status = "PROCESSING" (đã lưu trong DB)
         → Connection state: N/A ✅

T=60s:   Memory API xong (hoặc timeout)
         → calc_result = {...}  # Kết quả từ Memory API
         → Connection state: N/A ✅

T=60.1s: update_topic_metrics() hoặc apply_score_change()
         → Update friendship_score trong DB
         → Transaction mở lại (autocommit=False)
         → Connection state: idle in transaction

T=60.2s: mark_processed(event, ...)  # Line 505
         → event.status = "PROCESSED"  # ✅ Đánh dấu đã xử lý xong
         → event.friendship_score_change = score_change
         → event.processed_at = now()
         → db.commit()  # Commit trong mark_processed()
         → Transaction commit → status = "PROCESSED" đã lưu vào DB ✅
         → Connection state: idle

T=60.3s: finally block: db.close()
         → Connection được release về pool
         → Connection state: closed ✅

─────────────────────────────────────────────────────────────────
TÓM TẮT:
- T=0.4s: Đánh dấu PROCESSING (đã commit vào DB)
- T=0.5s-60s: Gọi Memory API (không có transaction mở)
- T=60.2s: Đánh dấu PROCESSED (commit vào DB)
```

## So sánh trạng thái trong DB

| Thời điểm | Status trong DB | Ghi chú                                           |
| ------------ | --------------- | -------------------------------------------------- |
| T=0s         | `PENDING`     | Trạng thái ban đầu                             |
| T=0.4s       | `PROCESSING`  | Đã commit vào DB                                |
| T=0.5s-60s   | `PROCESSING`  | Đang gọi Memory API (không có transaction mở) |
| T=60.2s      | `PROCESSED`   | Đã commit vào DB                                |

## Code cần sửa trong `process_single_event_with_log()`

```python
def process_single_event_with_log(
    self, 
    event_id: int, 
    conversation_log: List[Dict[str, Any]]
) -> Optional[Dict[str, int]]:
    event = self.repository.get_by_id(event_id)
    if not event:
        return None

    stats = {"processed": 0, "failed": 0, "total": 1}
  
    # ✅ FIX: Mark processing và commit TRƯỚC KHI gọi Memory API
    self.repository.mark_processing(event)
    self.db.commit()  # ✅ Commit ngay để release transaction
  
    try:
        # ... extract bot_type, agent_tag ...
      
        # ✅ Gọi Memory API (không có transaction mở)
        calc_result = self.score_service.calculate_score_from_conversation_log(
            conversation_log=conversation_log,
            metadata=metadata
        )
        # Memory API chạy ở đây (10-60s) → Không có transaction mở!
      
        # ... update topic_metrics hoặc apply_score_change ...
      
        # ✅ Đánh dấu PROCESSED sau khi Memory API xong
        self.repository.mark_processed(
            event=event,
            friendship_score_change=calc_result["friendship_score_change"],
            friendship_level=status["friendship_level"],
            score_calculation_details=calculation_details,
        )
        # mark_processed() sẽ commit transaction mới
        stats["processed"] = 1
      
    except Exception as e:
        # ✅ Đánh dấu FAILED nếu có lỗi
        self.repository.mark_failed(...)
        # mark_failed() sẽ commit transaction mới
        stats["failed"] = 1
  
    return stats
```

## Kết luận

- T=0.4s: Đánh dấu `PROCESSING` và commit ngay → Không còn transaction mở khi gọi Memory API
- T=60.2s: Đánh dấu `PROCESSED` sau khi Memory API xong → Commit kết quả vào DB

Cách này tránh `idle in transaction` leak và vẫn đảm bảo trạng thái được lưu đúng. Bạn muốn tôi tạo patch code đầy đủ không?


---
# Check kết quả 

```sql
-- idle in transaction: Connection đang trong transaction nhưng không làm gì - đây mới là vấn đề cần xử lý  
SELECT pg_terminate_backend(pid)  
FROM pg_stat_activity  
WHERE pid <> pg_backend_pid()  
  AND datname = 'robot_context_handling'  
  AND state = 'idle in transaction';  
  
  
SELECT  
    pid,  
    state,  
    now() - state_change AS idle_duration,  
    now() - query_start AS query_duration,  
    LEFT(query, 200) as query_preview  
FROM pg_stat_activity  
WHERE state = 'idle in transaction'  
  AND datname = 'robot_context_handling'  
  AND client_addr = '172.27.0.1'  
ORDER BY idle_duration DESC;
```


Giảm từ giữ 30s xuống 4s

![](image/Pasted%20image%2020260102174452.png)



---


```
-- =====================================================
-- STEP 1: Tổng quan các loại
-- =====================================================
SELECT 
    datname,
    state,
    COUNT(*) as count
FROM pg_stat_activity
WHERE pid <> pg_backend_pid()
GROUP BY datname, state
ORDER BY datname, state;

-- =====================================================
-- STEP 2: Chi tiết connections
-- =====================================================
SELECT
    pid,
    datname,
    usename,
    application_name,
    client_addr,
    state,
    backend_start,
    now() - state_change AS idle_duration,
    LEFT(query, 80) as query_preview
FROM pg_stat_activity
WHERE pid <> pg_backend_pid()
ORDER BY datname, state, idle_duration DESC;
```