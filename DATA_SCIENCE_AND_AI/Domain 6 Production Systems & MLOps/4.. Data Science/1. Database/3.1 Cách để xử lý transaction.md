Cách xử lý lỗi `InFailedSqlTransaction` từ phía database:


[2 tools called]


Đây là các cách sửa lỗi `InFailedSqlTransaction` từ phía database:

## 3 cách xử lý lỗi transaction từ database

### 1. Kiểm tra transactions đang bị stuck

Chạy các query sau trong PostgreSQL để kiểm tra:

```sql
-- 1. Kiểm tra tất cả transactions đang active
SELECT 
    pid,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    state_change,
    wait_event_type,
    wait_event,
    query
FROM pg_stat_activity
WHERE state != 'idle'
  AND datname = 'postgres'  -- Thay bằng database name của bạn
ORDER BY query_start;

-- 2. Kiểm tra transactions đang bị lock (blocked)
SELECT 
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS blocking_statement,
    blocked_activity.query_start,
    now() - blocked_activity.query_start AS blocked_duration
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks 
    ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;

-- 3. Kiểm tra transactions đang chờ quá lâu (có thể bị stuck)
SELECT 
    pid,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    now() - query_start AS duration,
    query
FROM pg_stat_activity
WHERE state = 'active'
  AND now() - query_start > interval '5 minutes'  -- Transactions chạy > 5 phút
  AND datname = 'postgres'
ORDER BY query_start;
```

### 2. Kill transactions bị stuck

Sau khi tìm thấy transaction bị stuck (qua các query trên), kill như sau:

```sql
-- ⚠️ CẨN THẬN: Chỉ kill transaction thực sự cần thiết

-- 1. Kill transaction nhẹ nhàng (TERM - đợi transaction commit/rollback)
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE pid = <PID_NUMBER>  -- Thay bằng PID từ query trên
  AND datname = 'postgres';

-- 2. Kill transaction ngay lập tức (CANCEL - interrupt query)
SELECT pg_cancel_backend(pid)
FROM pg_stat_activity
WHERE pid = <PID_NUMBER>
  AND datname = 'postgres';

-- 3. Kill TẤT CẢ transactions của một user (⚠️ NGUY HIỂM)
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE usename = 'your_username'  -- Thay bằng username
  AND datname = 'postgres'
  AND pid != pg_backend_pid();  -- Không kill chính session hiện tại

-- 4. Kill transactions đang chạy quá lâu (> 10 phút)
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE state = 'active'
  AND now() - query_start > interval '10 minutes'
  AND datname = 'postgres'
  AND pid != pg_backend_pid();
```

### 3. Tự động kill transactions bị stuck (cron job)

Tạo function tự động kill:

```sql
-- Tạo function tự động kill transactions stuck
CREATE OR REPLACE FUNCTION kill_stuck_transactions()
RETURNS TABLE(pid int, killed boolean, query text) AS $$
DECLARE
    rec RECORD;
BEGIN
    FOR rec IN 
        SELECT pid, query
        FROM pg_stat_activity
        WHERE state = 'active'
          AND now() - query_start > interval '10 minutes'
          AND datname = current_database()
          AND pid != pg_backend_pid()
          AND application_name LIKE '%your_app%'  -- Filter theo app
    LOOP
        PERFORM pg_terminate_backend(rec.pid);
        pid := rec.pid;
        killed := true;
        query := rec.query;
        RETURN NEXT;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Chạy function
SELECT * FROM kill_stuck_transactions();
```

## Giải pháp từ code (nên fix)

Đảm bảo rollback transaction khi có lỗi. Hiện code đã có rollback trong exception handlers, nhưng nên bổ sung:

1. Wrap SELECT FOR UPDATE trong try-except
2. Rollback trước khi retry
3. Đảm bảo mỗi thread có DB session riêng (đã có)

### Code fix đề xuất:

```python
# Trong friendship_status_repository.py
def apply_score_change(...):
    try:
        # SELECT FOR UPDATE với error handling
        status = (
            self.db.query(self.model)
            .filter(self.model.user_id == user_id)
            .with_for_update()
            .first()
        )
    except Exception as e:
        # Rollback nếu transaction bị abort
        self.db.rollback()
        # Retry với transaction mới
        status = (
            self.db.query(self.model)
            .filter(self.model.user_id == user_id)
            .with_for_update()
            .first()
        )
```

## Tóm tắt

| Cách | Khi nào dùng | Rủi ro |
|------|--------------|--------|
| Check stuck transactions | Để debug | An toàn |
| Kill từng transaction | Transaction cụ thể bị stuck | Trung bình |
| Kill tất cả | Khẩn cấp, hệ thống bị lock hoàn toàn | Cao |
| Fix từ code | Prevent lỗi từ đầu (khuyến nghị) | Thấp |

Lưu ý: Nên fix từ code để ngăn lỗi xảy ra. Kill transaction từ DB chỉ là giải pháp tạm thời khi hệ thống đang bị stuck.

Cần tôi tạo script SQL hoàn chỉnh để check/kill transactions không?