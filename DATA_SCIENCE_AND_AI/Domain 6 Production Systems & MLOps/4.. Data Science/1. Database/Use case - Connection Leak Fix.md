# Report: PostgreSQL "Too Many Clients Already" - Connection Leak Fix

## 1. VẤN ĐỀ, HIỆN TRẠNG

### 1.1. Sự kiện Lỗi

**Thời gian**: 16:32:20 ngày 2/1/2026
**Lỗi**: `[53300] FATAL: sorry, too many clients already`
**Vị trí**: Data Grid (DBeaver/pgAdmin) không thể kết nối tới PostgreSQL
**Impact**: Không thể query database, app có thể bị ảnh hưởng

### 1.2. Thống Kê Connections

**Từ `pg_stat_activity`**:

```
max_connections: 105
Current connections: 105/105 (100% - FULL!)
```

**Phân bổ connections**:

- **`robot_context_handling`**: ~60-70 connections
  - `idle`: ~50 connections
  - `idle in transaction`: ~10-15 connections
- **`robot_ai_workflow`**: ~20-30 connections
  - `idle`: ~20 connections
- **`postgres` (admin)**: ~10-15 connections
  - `idle`: ~10 connections
- **Data Grid/DBeaver**: 1-2 connections

### 1.3. Pattern Connections

**Connections `idle in transaction` từ `robot_context_handling`**:

```sql
SELECT conversation_events.id, conversation_events.conversation_id, ...
FROM conversation_events
WHERE conversation_events.id = 636
```

**Quan sát**:

- Query đã chạy xong (SELECT đã execute)
- Transaction vẫn mở (chưa COMMIT/ROLLBACK)
- Connection bị treo ở `idle in transaction`
- Không được release về pool

---

## 2. NGUYÊN NHÂN GỐC RỄ

### 2.1. Primary Root Cause: Transaction Không Được Rollback Khi Return Sớm

**Dẫn chứng code**:

```python
# rabbitmq_consumer.py:400-432
db = SessionLocal()  # Tạo session mới
repo = ConversationEventRepository(db)
event = repo.get_by_conversation_id(conversation_id)  # Query đã chạy → transaction mở

if not event:
    should_ack = True
    return  # ❌ RETURN SỚM - Transaction không được rollback!

# Fallback: Try to get from DB
if not conversation_log:
    # ...
    should_ack = True
    return  # ❌ RETURN SỚM - Transaction không được rollback!
```

**Cơ chế gây leak**:

```
1. db = SessionLocal() → Tạo session, mở transaction
2. event = repo.get_by_conversation_id(...) → Query chạy trong transaction
3. if not event: return → RETURN SỚM
4. Transaction vẫn mở (chưa commit/rollback)
5. finally block chạy → db.close() → Nhưng transaction đã "treo"
6. Connection bị giữ ở trạng thái "idle in transaction"
7. Connection không được release về pool
8. Tích lũy dần → 105 connections → "too many clients already"
```

### 2.2. Secondary Root Cause: Pool Size Lớn

**Cấu hình hiện tại**:

```python
DB_POOL_SIZE: int = 50
DB_MAX_OVERFLOW: int = 100
Total max connections: 150
```

**Vấn đề**:

- PostgreSQL `max_connections = 105`
- Pool có thể tạo tối đa 150 connections → Vượt quá giới hạn
- Khi có connection leak → Dễ đầy slot

**Lưu ý**: Pool size lớn không phải nguyên nhân chính, nhưng làm tăng nguy cơ khi có leak.

### 2.3. Tại Sao "Idle In Transaction" Nguy Hiểm?

**`idle` vs `idle in transaction`**:

| State                   | Mô tả                                             | Nguy hiểm                                                              |
| ----------------------- | --------------------------------------------------- | ----------------------------------------------------------------------- |
| `idle`                | Connection rảnh, không có transaction mở        | ✅ Bình thường, chỉ tốn slot                                       |
| `idle in transaction` | Transaction đang mở nhưng không có query chạy | ❌**NGUY HIỂM**: Giữ lock, ngăn VACUUM, chiếm connection lâu |

**Tác động của `idle in transaction`**:

1. **Giữ lock**: Transaction mở có thể giữ row-level locks
2. **Ngăn VACUUM**: VACUUM không thể cleanup rows trong transaction cũ
3. **Chiếm connection**: Connection không được release về pool
4. **Tích lũy**: Mỗi request "bỏ quên" 1 connection → Tích lũy nhanh

---

## 3. GIẢI PHÁP ĐÃ IMPLEMENT

### 3.1. Fix Transaction Rollback Khi Return Sớm

**File**: `src/app/background/rabbitmq_consumer.py`

**Fix 1: Khi event không tìm thấy (Line 405-417)**:

```python
if not event:
    logger.error(
        f"{error('❌ Conversation not found in DB')} | "
        f"{key_value('conversation_id', conversation_id)}"
    )
    # ✅ FIX: Rollback transaction trước khi return để tránh idle in transaction
    if db:
        try:
            db.rollback()
        except Exception:
            pass
    should_ack = True  # ACK để xóa message khỏi queue
    return
```

**Fix 2: Khi conversation_log không tìm thấy (Line 426-438)**:

```python
else:
    logger.error(
        f"{error('❌ conversation_log not found in S3, message, or DB')} | "
        f"{key_value('conversation_id', conversation_id)}"
    )
    # ✅ FIX: Rollback transaction trước khi return để tránh idle in transaction
    if db:
        try:
            db.rollback()
        except Exception:
            pass
    should_ack = True
    return
```

**Impact**:

- ✅ Mọi transaction đều được rollback trước khi return
- ✅ Connection được release về pool ngay
- ✅ Không còn `idle in transaction` leak

### 3.2. Giữ Nguyên Pool Size (Theo Yêu Cầu)

**Cấu hình hiện tại**:

```python
DB_POOL_SIZE: int = 50  # Giữ nguyên
DB_MAX_OVERFLOW: int = 100  # Giữ nguyên
Total max: 150 connections
```

**Lưu ý**:

- Pool size lớn không phải nguyên nhân chính
- Fix transaction rollback sẽ giải quyết vấn đề gốc rễ
- Nếu vẫn gặp vấn đề sau khi fix, có thể cân nhắc giảm pool size

---

## 4. HƯỚNG DẪN CLEANUP

### 4.1. Cleanup Connections Hiện Tại (Chữa Cháy)

**Bước 1: Vào server PostgreSQL và dùng psql**

```bash
# Trên server PostgreSQL
psql "postgres://USER:PASS@HOST:PORT/postgres"
```

**Bước 2: Xem chi tiết connections**

```sql
SELECT pid,
       datname,
       usename,
       application_name,
       client_addr,
       state,
       query
FROM pg_stat_activity
ORDER BY state, application_name, pid;
```

```sql
SELECT 
    pid,
    datname,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    state_change,
    now() - state_change AS idle_duration
FROM pg_stat_activity
WHERE datname = 'robot_context_handling'
ORDER BY state, idle_duration DESC;
```

**Bước 3: Terminate connections `idle in transaction`**

```sql
-- Terminate tất cả connections "idle in transaction" của robot_context_handling
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE pid <> pg_backend_pid()
  AND datname = 'robot_context_handling'
  AND state = 'idle in transaction';
```

**Hoặc terminate tất cả connections của service**:

```sql
-- Terminate tất cả connections của robot_context_handling (trừ phiên hiện tại)
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE pid <> pg_backend_pid()
  AND datname = 'robot_context_handling';
```

**Bước 4: Kiểm tra lại**

```sql
SELECT COUNT(*) FROM pg_stat_activity;
-- Kết quả mong đợi: < 105
```

```
-- Xem chi tiết connections
SELECT pid,
       datname,
       usename,
       application_name,
       client_addr,
       state,
       query
FROM pg_stat_activity
ORDER BY state, application_name, pid;

-- Xem chi tiết connection của context handling
SELECT
    pid,
    datname,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    state_change,
    now() - state_change AS idle_duration
FROM pg_stat_activity
WHERE datname = 'robot_context_handling'
ORDER BY state, idle_duration DESC;




-- Terminate tất cả connections "idle in transaction" của robot_context_handling
-- idle in transaction: Connection đang trong transaction nhưng không làm gì - đây mới là vấn đề cần xử lý
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE pid <> pg_backend_pid()
  AND datname = 'robot_context_handling'
  AND state = 'idle in transaction';

-- Terminate tất cả connections idle (trừ connection hiện tại)
-- idle: Connection đang rảnh, chờ query mới - đây là bình thường, thường là connections trong connection pool
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE pid <> pg_backend_pid()
  AND datname = 'robot_context_handling'
  AND state = 'idle';

SELECT
    pid,
    datname,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    state_change,
    now() - state_change AS idle_duration
FROM pg_stat_activity
WHERE datname = 'robot_context_handling'
ORDER BY state, idle_duration DESC;

```

### 4.2. Restart Worker Service

**Sau khi cleanup, restart worker để áp dụng fix**:

```bash
# Docker/K8s
docker restart robot-context-handling-worker
# hoặc
kubectl rollout restart deployment/robot-context-handling-worker
```

---

## 5. MONITORING VÀ PREVENTION

### 5.1. Query Monitoring Connections

**Xem tổng số connections**:

```sql
SELECT 
    COUNT(*) as total_connections,
    COUNT(*) FILTER (WHERE state = 'active') as active,
    COUNT(*) FILTER (WHERE state = 'idle') as idle,
    COUNT(*) FILTER (WHERE state = 'idle in transaction') as idle_in_transaction,
    COUNT(*) FILTER (WHERE state = 'idle in transaction (aborted)') as idle_in_transaction_aborted
FROM pg_stat_activity;
```

**Xem connections theo application**:

```sql
SELECT 
    application_name,
    COUNT(*) as connection_count,
    COUNT(*) FILTER (WHERE state = 'idle in transaction') as idle_in_transaction_count
FROM pg_stat_activity
WHERE datname = 'robot_context_handling'
GROUP BY application_name
ORDER BY connection_count DESC;
```

**Xem connections `idle in transaction` lâu**:

```sql
SELECT 
    pid,
    application_name,
    state,
    now() - state_change AS idle_duration,
    query
FROM pg_stat_activity
WHERE state = 'idle in transaction'
  AND datname = 'robot_context_handling'
ORDER BY idle_duration DESC;
```

### 5.2. Alert Khi Connections Cao

**Có thể thêm alert trong code**:

```python
# Trong health check hoặc monitoring
total_connections = get_connection_count()
max_connections = 105
connection_percent = (total_connections / max_connections) * 100

if connection_percent > 80:
    send_alert_safe(
        alert_type=AlertType.DATABASE_CONNECTION_HIGH,
        level=AlertLevel.HIGH,
        message=f"PostgreSQL connections high: {total_connections}/{max_connections} ({connection_percent:.1f}%)",
        context={
            "total_connections": total_connections,
            "max_connections": max_connections,
            "connection_percent": connection_percent
        },
        component="database"
    )
```

### 5.3. PostgreSQL Configuration (Nếu Cần)

**Nếu vẫn gặp vấn đề, có thể cấu hình timeout**:

```sql
-- Set timeout cho idle in transaction (PostgreSQL 9.6+)
ALTER SYSTEM SET idle_in_transaction_session_timeout = '10min';
SELECT pg_reload_conf();
```

**Hoặc tăng max_connections (nếu thực sự cần)**:

```sql
-- Xem file config
SHOW config_file;

-- Sửa postgresql.conf
-- max_connections = 200  # Tăng từ 105 lên 200

-- Restart PostgreSQL
```

**Lưu ý**: Tăng max_connections tốn RAM, nên ưu tiên fix code trước.

---

## 6. TÓM TẮT

### Vấn đề:

- PostgreSQL đạt max_connections (105/105)
- Data Grid không thể kết nối
- Nhiều connections `idle in transaction` từ `robot_context_handling`

### Nguyên nhân gốc rễ:

1. **Transaction không được rollback khi return sớm** (nguyên nhân chính)
   - Line 411: `return` khi event không tìm thấy
   - Line 432: `return` khi conversation_log không tìm thấy
2. Pool size lớn (50 + 100 = 150) làm tăng nguy cơ

### Giải pháp đã implement:

1. ✅ Thêm `db.rollback()` trước khi return sớm (2 chỗ)
2. ✅ Giữ nguyên pool size (theo yêu cầu)

### Kết quả mong đợi:

- ✅ Không còn `idle in transaction` leak
- ✅ Connections được release đúng cách
- ✅ Không còn "too many clients already" error

### Cần làm tiếp:

1. Cleanup connections hiện tại (SQL script ở trên)
2. Restart worker service
3. Monitor connections sau khi restart

---

**Document này mô tả vấn đề và giải pháp cho PostgreSQL connection leak trong service `robot_context_handling`**